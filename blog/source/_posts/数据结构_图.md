---
title: 数据结构_图
date: 2018-12-27 23:59:36
---

# 前言

**图**，是由可以有多个边的顶点组成的结构。

两个顶点之间有边连接，则称这两个顶点是**邻接**的。

几个相互邻接的顶点组成的线叫做**路径**,至少有一条路径可以到达所有顶点的图叫做**连通图**。

如果图的顶点只能从A→B，不能从B→A，就称图是**有向图**。

如果边被赋予一定的权值（数字），就称图为**带权图**

<img width='30%' height='30%' src='https://jixiaoyong.github.io/images/20181227232301.png'></img>

# 存储方式

图一般有两种存储方式：

* 邻接矩阵 用N*N的数组保存图中所有的顶点,`Arr[m][n]`即表示m、n顶点是否邻接（Y:1,N:0）。

  比较占地方。

  ![邻接矩阵](https://jixiaoyong.github.io/images/20181227233341.png)

* 邻接表 用一个N大小的数组保存，数组元素是保存着顶点和他所有的邻接点的链表。

  ![邻接表](https://jixiaoyong.github.io/images/20181227233435.png)

# 操作

图的操作有插入（顶点），搜索等等。

以下操作以邻接表方式为例。

## 插入

插入分为插入顶点和插入边。

插入边的时候需要注意，要同时更新start和end两个顶点对应的链表。

## 移除

原理同插入边。

## 搜索

搜索要求从某个特定顶点开始，沿着边移动到其他顶点，移动完毕后要保证访问了每个顶点。

搜索又分为DFS（深度优先搜索）、BFS（广度优先搜索）。

### DFS

DFS的思想是，依次沿着顶点某一个邻接点，纵深访问，将该邻接点当做新的顶点压入栈中，继续纵深访问，直到有顶点没有可以访问的邻接顶点，将其打印出来（从栈中推出）；然后再返回上一层的邻接顶点中还可以访问的顶点（查找当前栈顶元素未访问的邻接点），直到没有可以访问的顶点。

用栈实现，会先往深处遍历完一条路径，再遍历下一条。每个顶点只访问一次

规则：

*      1/3 访问一个邻接的未访问顶点，访问并标记，将其压入栈中；
*      2/3 当规则1不能满足时，如果栈不为空，从栈中弹出一个顶点；
*      3/3 1,2都无法满足时，搜索结束；



```kotlin
private fun dfs() {
    var stacks = DfsStacks(hashMap.size)
    var keyArr = hashMap.keys.toIntArray()
    stacks.push(keyArr[0])
    hashMap[keyArr[0]]?.isVisited = true
    var index = hashMap[keyArr[0]]
    while (stacks.size > 0) {
        var availableKey = getAvailableNode(index!!.data)
        if (availableKey != -1) {
            index = hashMap[availableKey]//深度优先搜索，会先顺着一个邻接点一直走到头
            index!!.isVisited = true
            stacks.push(availableKey)
        } else {
            var pop = stacks.pop()
            print("$pop ")
            index = hashMap[stacks.peek()]//如果一个邻接点再没有未访问的邻接点，那么去访问下一个未访问的邻接点
        }
    }
}
```

### BFS

BFS的思想是，向将当前顶点的所有可以访问的邻接点访问完毕；之后将该顶点打印（推出），再去访问其邻接点的所有可以访问邻接点（从队列头取出一个顶点，查找其未访问的邻接点）。

用队列实现，会先遍历完本层所有的顶点，然后再移向下一层

规则：

*      1/3 先访问当前顶点的所有邻接顶点，标记，并插入到队列
*      2/3 如果没有可以访问的邻接点，且队列不为空，从队列头取出一个顶点[此处又用到了一次该点]，使其成为当前顶点，重复1
*      3/3 如果2不能满足，搜索结束

```kotlin
private fun bfs() {
    var queue = BfsQueue()
    var keyArr = hashMap.keys.toIntArray()
    queue.push(keyArr[0])
    hashMap[keyArr[0]]!!.isVisited = true
    var index = hashMap[keyArr[0]]
    while (queue.size > 0) {
        var availableKey = getAvailableNode(index!!.data)
        if (availableKey != -1) {
            var current = hashMap[availableKey]!!//广度优先搜索，优先将一个节点的所有邻接点依次访问
            current.isVisited = true
            queue.push(current.data)
        } else {
            var pop = queue.pop()
            print("$pop ")
            if (queue.peek() == -1) {
                break
            }
            index = hashMap[queue.peek()]//如果该点没有未访问的邻接点，就选择去访问该点邻接点的邻接点
        }
    }
}
```

# 最小生成树MST

最小生成树MST

> 生成树（Template:Lang-en-short）是具有图G的全部顶点，但边数最少的连通子图.
>
> ——维基百科

带权图的生成树中，总权重最小的称为最小生成树。最小生成树边比顶点树小1

* 当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。

* 如果图的每一条边的权值都互不相同，那么最小生成树将只有一个。

无向不带权图中，只需要找出最小数量的边即可。用DFS比较好实现，因为他对每个顶点只访问一次。

# 源码

[👉点这里](https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/GraphClazz.kt) 查看源码