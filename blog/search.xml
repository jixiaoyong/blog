<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>数据结构_图</title>
      <link href="/blog/posts/a71f2ecc/"/>
      <url>/blog/posts/a71f2ecc/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>图</strong>，是由可以有多个边的顶点组成的结构。</p><p>两个顶点之间有边连接，则称这两个顶点是<strong>邻接</strong>的。</p><p>几个相互邻接的顶点组成的线叫做<strong>路径</strong>,至少有一条路径可以到达所有顶点的图叫做<strong>连通图</strong>。</p><p>如果图的顶点只能从A→B，不能从B→A，就称图是<strong>有向图</strong>。</p><p>如果边被赋予一定的权值（数字），就称图为<strong>带权图</strong></p><p><img width="30%" height="30%" src="https://jixiaoyong.github.io/images/20181227232301.png"></p><h1 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h1><p>图一般有两种存储方式：</p><ul><li><p>邻接矩阵 用N*N的数组保存图中所有的顶点,<code>Arr[m][n]</code>即表示m、n顶点是否邻接（Y:1,N:0）。</p><p>比较占地方。</p><p><img src="https://jixiaoyong.github.io/images/20181227233341.png" alt="邻接矩阵"></p></li><li><p>邻接表 用一个N大小的数组保存，数组元素是保存着顶点和他所有的邻接点的链表。</p><p><img src="https://jixiaoyong.github.io/images/20181227233435.png" alt="邻接表"></p></li></ul><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>图的操作有插入（顶点），搜索等等。</p><p>以下操作以邻接表方式为例。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入分为插入顶点和插入边。</p><p>插入边的时候需要注意，要同时更新start和end两个顶点对应的链表。</p><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>原理同插入边。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>搜索要求从某个特定顶点开始，沿着边移动到其他顶点，移动完毕后要保证访问了每个顶点。</p><p>搜索又分为DFS（深度优先搜索）、BFS（广度优先搜索）。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS的思想是，依次沿着顶点某一个邻接点，纵深访问，将该邻接点当做新的顶点压入栈中，继续纵深访问，直到有顶点没有可以访问的邻接顶点，将其打印出来（从栈中推出）；然后再返回上一层的邻接顶点中还可以访问的顶点（查找当前栈顶元素未访问的邻接点），直到没有可以访问的顶点。</p><p>用栈实现，会先往深处遍历完一条路径，再遍历下一条。每个顶点只访问一次</p><p>规则：</p><ul><li>1/3 访问一个邻接的未访问顶点，访问并标记，将其压入栈中；</li><li>2/3 当规则1不能满足时，如果栈不为空，从栈中弹出一个顶点；</li><li>3/3 1,2都无法满足时，搜索结束。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stacks = DfsStacks(hashMap.size)</span><br><span class="line">    <span class="keyword">var</span> keyArr = hashMap.keys.toIntArray()</span><br><span class="line">    stacks.push(keyArr[<span class="number">0</span>])</span><br><span class="line">    hashMap[keyArr[<span class="number">0</span>]]?.isVisited = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> index = hashMap[keyArr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> (stacks.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> availableKey = getAvailableNode(index!!.<span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (availableKey != -<span class="number">1</span>) &#123;</span><br><span class="line">            index = hashMap[availableKey]<span class="comment">//深度优先搜索，会先顺着一个邻接点一直走到头</span></span><br><span class="line">            index!!.isVisited = <span class="literal">true</span></span><br><span class="line">            stacks.push(availableKey)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pop = stacks.pop()</span><br><span class="line">            print(<span class="string">"<span class="variable">$pop</span> "</span>)</span><br><span class="line">            index = hashMap[stacks.peek()]<span class="comment">//如果一个邻接点再没有未访问的邻接点，那么去访问下一个未访问的邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS的思想是，向将当前顶点的所有可以访问的邻接点访问完毕；之后将该顶点打印（推出），再去访问其邻接点的所有可以访问邻接点（从队列头取出一个顶点，查找其未访问的邻接点）。</p><p>用队列实现，会先遍历完本层所有的顶点，然后再移向下一层</p><p>规则：</p><ul><li>1/3 先访问当前顶点的所有邻接顶点，标记，并插入到队列；</li><li>2/3 如果没有可以访问的邻接点，且队列不为空，从队列头取出一个顶点[此处又用到了一次该点]，使其成为当前顶点，重复1；</li><li>3/3 如果2不能满足，搜索结束。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> queue = BfsQueue()</span><br><span class="line">    <span class="keyword">var</span> keyArr = hashMap.keys.toIntArray()</span><br><span class="line">    queue.push(keyArr[<span class="number">0</span>])</span><br><span class="line">    hashMap[keyArr[<span class="number">0</span>]]!!.isVisited = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> index = hashMap[keyArr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> (queue.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> availableKey = getAvailableNode(index!!.<span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (availableKey != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> current = hashMap[availableKey]!!<span class="comment">//广度优先搜索，优先将一个节点的所有邻接点依次访问</span></span><br><span class="line">            current.isVisited = <span class="literal">true</span></span><br><span class="line">            queue.push(current.<span class="keyword">data</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pop = queue.pop()</span><br><span class="line">            print(<span class="string">"<span class="variable">$pop</span> "</span>)</span><br><span class="line">            <span class="keyword">if</span> (queue.peek() == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            index = hashMap[queue.peek()]<span class="comment">//如果该点没有未访问的邻接点，就选择去访问该点邻接点的邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树MST"><a href="#最小生成树MST" class="headerlink" title="最小生成树MST"></a>最小生成树MST</h1><blockquote><p>生成树（Template:Lang-en-short）是具有图G的全部顶点，但边数最少的连通子图.</p><p>——维基百科</p></blockquote><p>带权图的生成树中，总权重最小的称为最小生成树。</p><p>最小生成树边比顶点数小1。</p><ul><li><p>当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。</p></li><li><p>如果图的每一条边的权值都互不相同，那么最小生成树将只有一个。</p></li></ul><p>无向不带权图中，只需要找出最小数量的边即可。用DFS比较好实现，因为他对每个顶点只访问一次。</p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序是指<strong>有向图</strong>的顶点排序，满足以下条件<a href="#参考资料">*</a>：</p><ol><li>每个顶点出现且只出现一次；</li><li>若A在序列中排在B的前面，则在图中不存在从B到A的<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%84_(%E5%9B%BE%E8%AE%BA" target="_blank" rel="noopener">路径</a>)。</li></ol><p>实现思路是：</p><ul><li><p>依次推出有向图中没有后继点的顶点作为排序的最后项，这是因为按照拓扑排序<code>条件2</code>没有后继点的顶点必然排在后面；</p></li><li><p>当去掉没有后继点的顶点后又会产生新的没有后继点的顶点，这样依次循环，当图中没有顶点的时候，就可以在有向无环图中完成拓扑排序。</p></li></ul><p>对于有环存在（即存在类似A→B，B→C，C→A的情况）的有向图，会出现找不到<code>没有后继点的顶点</code>，但同时<code>图中顶点数不为0</code>的情况，遇到这种情况退出循环，并说明有环存在即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拓扑排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">topologicalSort</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashMap.size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> displayList = ArrayList&lt;T?&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hashMap.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> successorKey = getSuccessorNode()</span><br><span class="line">        <span class="keyword">if</span> (successorKey == <span class="literal">null</span>) &#123;<span class="comment">//图中还有顶点，但却找不到“没有后继点的顶点”，说明有环</span></span><br><span class="line">            println(<span class="string">"图中有环"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.remove(successorKey)<span class="comment">//如果找到满足条件的顶点，从图中删除并保存的排序结果中</span></span><br><span class="line">            displayList.add(successorKey)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"\n <span class="subst">$&#123;displayList.reversed()&#125;</span> \n"</span>)<span class="comment">//以正确的顺序输出排序结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历图，查找没有后继点的顶点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> -1表示没有这样的点 否则返回该点key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSuccessorNode</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">val</span> result: T? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> ketSet = hashMap.keys</span><br><span class="line"></span><br><span class="line">    ketSet.map &#123;<span class="comment">//遍历图中每个顶点</span></span><br><span class="line">        <span class="comment">//如果顶点没有后继点(没有邻接点，或者邻接点已经被删除)就是满足条件</span></span><br><span class="line">        <span class="keyword">var</span> node: GraphicNode&lt;T&gt;? = hashMap[it]?.next ?: <span class="keyword">return</span> it</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> realNode = hashMap[node.<span class="keyword">data</span>]</span><br><span class="line">            <span class="keyword">if</span> (realNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@map</span><span class="comment">//有后继点，不满足条件，查找下一个顶点</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next<span class="comment">//还有其他邻接点，依次遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result<span class="comment">//没有找到“没有后继点的顶点”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/GraphClazz.kt" target="_blank" rel="noopener">👉点这里</a> 查看<code>DFS/BFS/MST</code>源码</p><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/Digraph.kt" target="_blank" rel="noopener">👉点这里</a> 查看<code>拓扑排序</code>源码</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">拓扑排序——维基百科</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>数据结构_堆</title>
      <link href="/blog/posts/b3af796a/"/>
      <url>/blog/posts/b3af796a/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆是一种特殊的二叉树，用他实现的优先级队列插入和删除时间复杂度都是$O(LogN)$ 。</p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ol><li>堆是完全二叉树<a href="#完全二叉树">*</a></li><li>常用数组实现</li><li>每个堆的节点都满足堆的条件，即堆的每个节点关键字都大于（或等于）子节点的关键字</li></ol><p><code>特征3</code>保证了根节点是堆中最大的值，以及顺着某一个节点一直到遇到叶节点的路径上的节点关键字是依次递减的，但是没法保证这个值是这个堆中的最小值，这是因为堆中每个节点的左右子节点的位置和大小无关，两条这样的路径之前的值的大小没有一定的关系。</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>堆可以进行插入、移除，遍历等操作，时间复杂度都是$O(LogN)$。初次之外，利用堆根节点关键值最大这个属性，还可以进行堆排序,时间复杂度为$O(N*LogN)$。</p><p>对于在数组中保存的堆，设元素下标为<code>x</code>，则各个相关元素下标如下：</p><ul><li>父节点<code>(x-1)/2</code></li><li>左子节点 <code>2*x+1</code></li><li>右子节点 <code>2*x+2</code></li></ul><p>在插入，移除的时候为了保证满足堆的条件，需要对堆进行向上或向下的遍历，将修改的值移动到对应的位置，在这过程中涉及到复制和交换。如果每次比较都需要交换数据的话会复制很多次，而如果将最终要移动值保存在临时变量中，用一个值专门记录要移动到的下标，在每次符合条件时只复制参与对比的值，在最后再将要临时保存的值复制到目的下标，就会减少复制的次数。</p><p>如下图就将复制次数从9次减少到了5次。</p><p><img src="https://jixiaoyong.github.io/images/20181225213813.png" alt=""></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入操作思路是，将元素插入到数组最后一位，然后依次向元素父节点遍历，将不满足的元素下沉，直到找到满足<code>堆特征3</code>（父节点关键字大于该点，并且子节点关键字小于该点）的下标，或者指向了根目录，将该元素插入该处。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下向上遍历</span></span><br><span class="line"><span class="comment">    * 如果父节点比插入值小，就将父节点移动到插入值的位置，将toIndex指向空出的地方</span></span><br><span class="line"><span class="comment">    * 依次查找，直到查找到父节点比插入值大，子节点比插入值小的地方，或者指向了根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkUp</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">       <span class="keyword">var</span> bottom = headArray[index]<span class="comment">//headArray是保存堆元素的数组</span></span><br><span class="line">       <span class="keyword">var</span> toIndex = index</span><br><span class="line">       <span class="keyword">var</span> father = (toIndex - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">       <span class="keyword">while</span> (toIndex &gt; <span class="number">0</span> &amp;&amp; bottom!!.key &gt; headArray[father]!!.key) &#123;</span><br><span class="line">           headArray[toIndex] = headArray[father]<span class="comment">//将父节点下沉</span></span><br><span class="line">           toIndex = father</span><br><span class="line">           father = (toIndex - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">       &#125;</span><br><span class="line">       headArray[toIndex] = bottom<span class="comment">//将该值插入到对应下标</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>移除指的是将根节点推出堆中。</p><p>基本思路是将根节点推出，再将数组最后一个节点（同时也是堆的最后一个节点）移动到根节点空出的位置，再依次向下遍历，直到将该节点放到符合堆条件的位置或者到达叶子节点。</p><p>和插入相比，移除时要移动的节点要比较的稍微多些。</p><ul><li>该节点是叶节点    直接插入✅</li><li>有两个子节点        和两个叶子节点中最大的比较，如果小于则交换，并再和新的子节点比较</li><li>只有左节点    如果左节点大于本节点则交换，否则就是该位置</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从上向下遍历</span></span><br><span class="line"><span class="comment"> * 如果遇到比当前值top大的就将其复制到当前位置toIndex，并记录下空出的位置为toIndex</span></span><br><span class="line"><span class="comment"> * 再以toIndex为起点向下比较，直到遇到top比父节点小，比子节点大的位置，或者叶子节点</span></span><br><span class="line"><span class="comment"> * 将top移动到该位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkDown</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> toIndex = index</span><br><span class="line">    <span class="keyword">var</span> top = headArray[size - <span class="number">1</span>]!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (toIndex &lt; size / <span class="number">2</span>) &#123;<span class="comment">//非叶子节点</span></span><br><span class="line">        <span class="keyword">var</span> leftIndex = <span class="number">2</span> * toIndex + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> rightIndex = <span class="number">2</span> * toIndex + <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (headArray[rightIndex] == <span class="literal">null</span>) &#123;<span class="comment">//只有左节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (headArray[leftIndex]!!.key &gt; top.key) &#123;</span><br><span class="line">                headArray[toIndex] = headArray[leftIndex]</span><br><span class="line">                toIndex = leftIndex</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (headArray[leftIndex] != <span class="literal">null</span> &amp;&amp; headArray[rightIndex] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (headArray[leftIndex]!!.key &gt;= headArray[rightIndex]!!.key) &#123;<span class="comment">//如果左节点比较大</span></span><br><span class="line">                <span class="keyword">if</span> (headArray[leftIndex]!!.key &gt; top.key) &#123;</span><br><span class="line">                    headArray[toIndex] = headArray[leftIndex]</span><br><span class="line">                    toIndex = leftIndex</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果右节点比较大</span></span><br><span class="line">                <span class="keyword">if</span> (headArray[rightIndex]!!.key &gt; top.key) &#123;</span><br><span class="line">                    headArray[toIndex] = headArray[rightIndex]</span><br><span class="line">                    toIndex = rightIndex</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    headArray[toIndex] = top<span class="comment">//将该节点移动到找到的下标处</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>利用堆<code>根节点关键值最大</code>这一特性，可以进行堆排序。</p><p>只需要将待排序的数组依次插入堆中，然后再依次移除即可。</p><p>这样需要有两倍与待排序数组大小的空间。如果每次插入时候只保存数据，不进行向上遍历，在每次移除数据时进行向下遍历，将当前剩余数据最大值选出来（其余数据仍然无序）从堆中移除根元素时都会在数组末尾空出一个位置，将该值存储在该位置即可，这样等完全插入、移除后就得到一个有序数组【从数组末尾开始依次减小】</p><p>堆排序和快速排序时间复杂度都是 <code>O(N*LogN)</code> ，但是由于向上、向下遍历耗时，实际上要比快速排序稍慢一些。但是堆排序堆数据初始分布不敏感一直都是 <code>O(N*LogN)</code> ，快速排序在某些情况下时间复杂度可达到 <code>O(N^2)</code> 。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>满二叉树指除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。</p><p>如果一个二叉树的层数为K，且节点总数是 $(2^k) -1$  ，则它就是满二叉树。</p><p><img src="https://jixiaoyong.github.io/images/20181225210750.png" alt="满二叉树"></p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树 如果将二叉树每层从左到右遍历，那么完全二叉树只有最后一层的右边会出现没有叶子节点的情况，即在前1~n之间没有“洞”。</p><p>如下图就是一个完全二叉树：</p><p><img src="https://jixiaoyong.github.io/images/20181225211304.png" alt="完全二叉树"></p><p>但下图不是完全二叉树：</p><p><img src="https://jixiaoyong.github.io/images/20181223211217.png" alt="不是完全二叉树"></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/HeadClazz.kt" target="_blank" rel="noopener">👉点这里</a> 查看源码</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">满二叉树——百度百科</a></p><p><a href="https://blog.csdn.net/u013812939/article/details/46798743" target="_blank" rel="noopener">完全二叉树与满二叉树的区别</a></p><p>《Java数据结构和算法 （第二版）》 Robert Lafore 陈维宁</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>数据结构_Hash表</title>
      <link href="/blog/posts/1f6681a0/"/>
      <url>/blog/posts/1f6681a0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hash表是一种可以快速插入和查找的数据结构，将数据保存在通过hash函数计算得到的下标中。</p><p>插入和删除 所需时间为O(1)。在确定容量、无需遍历时效果最好。</p><p>当其大小接近容量时，效率会变得很差。</p><h1 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h1><p>Hash表有两种存储方式</p><ol><li><p>开放地址法</p><p>开放地址法，直接将数据存储在数组中。</p><p>当hash算出的地址已经被占用时，则走过一定的步长找到另外一个空位（在填充质数很大时就会很耗时）并保存数据。</p></li><li><p>链地址法</p><p>链地址法，创建保存数据的数组，该数组中不直接保存数据，而是保存一个用来存储这些数据的链表，将数据项直接存储的链表中。</p><p>当hash算法计算出的地址时，遍历数组中对应的链表找到空位并保存。</p></li></ol><p>其中，开放地址法又分为3种实现：</p><ul><li><p>线性探测</p><p>每次前进的步长为1</p><p>即查找的位置依次是<code>x + 1,2,3,4,5,……</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储达到容量2/3以上时候读写性能会很差</span><br></pre></td></tr></table></figure></li><li><p>二次探测</p><p>每次前进的步长为当前查找次数的平方</p><p>即查找的位置依次是<code>x + 1,4,9,……</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前几次找不到之后就会很恐慌，步长越来越大到后面无法继续下去</span><br></pre></td></tr></table></figure></li><li><p>再哈希法</p><p>每次前进的步长是根据另外一个hash算法计算出来的值</p><p>这个算法要求如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 与第一次hash输出不同  </span><br><span class="line"><span class="number">2</span>. 不能输出<span class="number">0</span></span><br></pre></td></tr></table></figure><p>已经有一个公认的比较好的二次hash算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stepSize = constant - (key % constant)</span><br><span class="line">如：stepSize = <span class="number">5</span> - (key % <span class="number">5</span>)</span><br><span class="line">* constant 是小于数组容量的质数</span><br></pre></td></tr></table></figure></li></ul><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p><strong>再哈希法 VS 二次探测法</strong></p><p>在小型哈希表中，再哈希法比二次探测好；</p><p>但如果容量充足，并且容量大小不再变化时，二次探测效果好，在装填因子小于0.5时几乎没有性能损失</p><p><strong>开放地址法 VS 链地址法</strong></p><p>hash表容器大小未知时，用链地址法比较好</p><p>当装填因子变得很大时，开放地址法性能下降很快，但链地址法只是线性下降。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/Hash.kt" target="_blank" rel="noopener">👉点这里</a>查看源码</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>数据结构_红黑树</title>
      <link href="/blog/posts/11c01876/"/>
      <url>/blog/posts/11c01876/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为$O(log_2N)$。</p><p>红黑树必须满足以下条件：</p><ol><li><p>必须有颜色（黑/红）</p></li><li><p>根节点颜色为黑</p></li><li>若节点是红色，则子节点必须是黑色（反之则不然）</li><li>到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色）</li></ol><p>如果不满足可以通过以下方式修正：</p><ul><li>改变节点颜色</li><li>旋转（左、右）</li></ul><h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>以某个支点旋转（右旋为例，旋转时注意更新各个节点的父节点）：</p><p>本质是将该<code>节点a</code>向下进一位插入到其<code>右节点b</code>原先的位置，将其<code>左节点c</code>向上进一位插入到该<code>节点a</code>原先的位置，并将<code>左节点c的右节点</code>赋值给该<code>节点a</code>。</p><p>步骤：</p><ol><li><p>将该<code>节点a</code>放到<code>右节点b</code>的位置，将该<code></code>左节点c<code>放到</code>节点a`原先的位置，依次类推</p></li><li><p>特殊的，将该<code>点a的内侧孙子</code>（<code>a的左子节点c</code>的<code>右子节点d</code>）断开与其<code>父节点c</code>的连接，转而连接到<code>a</code>上，成为<code>a的左子节点</code></p></li></ol><p>如图，依次插入<code>6,34,23</code>，<strong>以<code>34</code>为支点右旋</strong>：</p><p><img src="https://jixiaoyong.github.io/images/20181223175956.png" width="50%" height="50%"></p><p>对获得的结果，由于<font color="#ff0000">23</font>，<font color="#ff0000">34</font>都是红色违反了<code>规则3</code>，将<code>34的父节点23</code>设置黑，<code>祖父节点6</code>设为红，<strong>以<code>祖父节6</code>点为支点左旋</strong>：</p><p><img src="https://jixiaoyong.github.io/images/20181223180637.png" alt="最终结果"></p><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>每次插入红色节点，能够避免规则4。</p><p>一般先以二叉搜索树的规则将数据插入表中，然后再对照规则检查是否需要调整红黑树。</p><p>红黑树插入情况分类如下：</p><ol><li>插入位置为根节点，将节点颜色更改为黑色</li><li>插入位置的父节点为根节点或父节点颜色为黑色，直接插入</li><li>父节点为红色。</li></ol><p>只有父节点为红色这种情况需要进行修正，这时又可以细分为以下三种情况：</p><p><img src="https://jixiaoyong.github.io/images/20181223182532.jpg" alt="表格来自 http://www.cnblogs.com/skywang12345/p/3245399.html#a1"></p><p>【注意】对于<code>Case 3</code>当祖父节点没有<strong>左节点</strong>无法右旋时的特殊处理：</p><p>需要对先对当前节点的父节点进行右旋，再以父节点作为<strong>新插入的点N</strong>，将N的父节点设置为黑色，祖父节点设置为红色，以祖父节点为支点左旋。</p><p>如依次插入如下值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32,3,53,13,983,[137],237,83,483,43,183</span><br></pre></td></tr></table></figure><p>当插入<code>137</code>后红黑树如图：</p><p><img src="https://jixiaoyong.github.io/images/20181223210305.png" alt="插入137后的树"></p><p>本来按照<code>Case 3 父红 叔黑 是左节点</code> 应该要以祖节点右旋，但是组节点53没有左子节点，无法右旋，所以先对父节点983进行右旋：</p><p><img src="https://jixiaoyong.github.io/images/20181223210800.png" alt=""></p><p>再以<code>983</code>为新节点，<code>父红 叔黑 是右节点</code>，将<code>父节点137</code>设置为黑色，<code>祖节点53</code>设置为红色，以<code>组节点53</code>为支点左旋：</p><p><img src="https://jixiaoyong.github.io/images/20181223211217.png" alt=""></p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>删除比较复杂，可以有两种操作：</p><ol><li>在节点中保存一个标志位，标记该节点是否被删除，并不针真的删除该点。</li><li>在执行删除操作时真正删除该点。</li></ol><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/RedBlackTree.kt" target="_blank" rel="noopener">👉点这里</a>查看源码</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://sandbox.runjs.cn/show/2nngvn8w" target="_blank" rel="noopener">在线操作红黑树</a></p><p><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a1" target="_blank" rel="noopener">红黑树(一)之 原理和算法详细介绍</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>利用travis通过Hexo在Github上自动部署Markdown文档</title>
      <link href="/blog/posts/b00ac86a/"/>
      <url>/blog/posts/b00ac86a/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文介绍了一个只需要更新Markdown文档到Github，即可实时更新博客内容的方法。</p><p>本文参考<a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener">这篇文章</a> 实现，并根据我的需求更改了部分内容，以实现<strong>部署多个hexo工程到同一Github项目不同目录下</strong>。</p></blockquote><p>Github为我们提供了<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 方便我们建立简单的网页来介绍项目，很多时候我们用他来搭建静态博客。</p><p>通过<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>可以将我们写的<code>Markdown文档</code>格式化为<code>静态网页</code>，再将其部署到Github上面对应的<code>user_name.github.io</code>上面，就可以拥有一个在线的静态博客。</p><p>但是受Hexo的限制，每次更新博客内容都需要在更新完Markdown文档后，都需要再次重新创建对应的静态网页、将更新提交到Github。这样的步骤繁琐且没有意义，而且更换电脑后这些环境都需要重新设置一次。</p><p>通过<a href="https://www.travis-ci.org" target="_blank" rel="noopener">travis</a>提供的免费CI技术，可以让云服务器代替我们实现Hexo创建以及同步Github等步骤，每次更新博客时<strong>只需要将写好的Markdown文档推送到Github项目对应目录中，等待一会儿就可以看到更新后的博客了</strong>。</p><p>具体搭建过程可以参考<a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener">这篇文章</a> 本文只讲述实现<strong>部署多个hexo工程到同一Github项目不同目录下</strong>需要注意的地方：。</p><blockquote><p><strong>懒——是第一生产力</strong></p></blockquote><h1 id="具体差异"><a href="#具体差异" class="headerlink" title="具体差异"></a>具体差异</h1><h2 id="hexo分支的结构"><a href="#hexo分支的结构" class="headerlink" title="hexo分支的结构"></a>hexo分支的结构</h2><p>因为有多个hexo项目，所以在github项目的hexo分支下，对不同的hexo项目分别新建文件夹存放。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- your_name.github.io //github项目，切换到hexo分支</span><br><span class="line">  --hexo_project1 //本地hexo项目1的所有文件</span><br><span class="line">  --hexo_project2 //本地hexo项目2的所有文件</span><br></pre></td></tr></table></figure><h2 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a>.travis.yml</h2><p>重点修改<code>script:</code>和<code>after_script:</code>两部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="comment"># 1. 创建对应的静态博客内容</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">blog</span> <span class="comment"># 第一个本地hexo项目</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">imissyou</span> <span class="comment"># 第二个本地hexo项目</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"jixiaoyong"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"jixiaoyong1995@gmail.com"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">mkdir</span> <span class="string">publish</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">publish</span></span><br><span class="line">  <span class="comment"># 2. 在这里再拉取master分支的文件，并删除旧的博客内容</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">clone</span> <span class="attr">https://$&#123;GH_TOKEN&#125;@github.com/jixiaoyong/jixiaoyong.github.io.git</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">rm</span> <span class="bullet">-rf</span> <span class="string">./jixiaoyong.github.io/blog/*</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">rm</span> <span class="bullet">-rf</span> <span class="string">./jixiaoyong.github.io/imissyou/*</span></span><br><span class="line">   <span class="comment"># 3. 将第1步生成的静态博客内容添加到master分支，并同步到github上面</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cp</span> <span class="bullet">-rf</span> <span class="string">jixiaoyong.github.io/blog/public/*</span> <span class="string">publish/jixiaoyong.github.io/blog/</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cp</span> <span class="bullet">-rf</span> <span class="string">jixiaoyong.github.io/imissyou/public/*</span> <span class="string">publish/jixiaoyong.github.io/imissyou/</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">publish/jixiaoyong.github.io/</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"auto update by www.travis-ci.org"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure><p>文档链接：<a href="https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/.travis.yml" target="_blank" rel="noopener">.travis.yml</a></p><h1 id="更新博客内容"><a href="#更新博客内容" class="headerlink" title="更新博客内容"></a>更新博客内容</h1><p>当以上内容都配置完成后，只要新建一个符合hexo要求的文档，并提交到Github对应项目的hexo分支中<code>source</code>目录，Travis便会自动帮我们创建并更新静态网页。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener">Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程</a> （完全在该文档指导下完成，部分步骤有差异，感谢作者<a href="https://juejin.im/user/56efe6461ea493005565dafd" target="_blank" rel="noopener">MichaelX</a> ）</p>]]></content>
      
      
      
        <tags>
            
            <tag> ci </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android运行时权限</title>
      <link href="/blog/posts/a2863875/"/>
      <url>/blog/posts/a2863875/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了Android运行时权限的一些处理流程。</p><p>Android运行时权限是Android6之后出现的处理权限的新方式，此前开发者只需要应用需要的权限在AndroidManifest.xml文件中声明即可，现在则需要在使用到对应权限时检测是否有该权限并作出相应处理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><ol><li><p>在<code>AndroidManifest.xml</code>中声明所需权限</p></li><li><p>在使用之前检查是否有该权限<code>checkSelfPermission()</code>,如果有则继续相应操作</p></li><li><p>如果没有权限则检测是否需要向用户解释为什么需要该权限<code>ActivityCompat.shouldShowRequestPermissionRationale()</code>，再决定如何申请权限<code>requestPermissions()</code></p><blockquote><p>需要说明的是，shouldShowRequestPermissionRationale()在第一次申请该权限时会返回false，第二次申请时返回true；</p><p>但是如果用户选择了<em>不再提醒</em> 则会一直返回false。所以如果判断当前并非第一次申请该权限，并且返回结果为false，就说明用户选择了不再提示，一般就需要提示用户到设置中开启对应权限。</p></blockquote></li><li><p>申请权限的结果在<code>onRequestPermissionsResult()</code>方法中返回，根据用户对权限的处理结果决定接下来的操作</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>onCreate()</code>方法中调用对应方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mSharedPreferences = getSharedPreferences(packageName, Context.MODE_PRIVATE)</span><br><span class="line">checkCameraDeviceAndPremissions()</span><br></pre></td></tr></table></figure><p><code>checkCameraDeviceAndPremissions()</code>具体内容</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkCameraDeviceAndPremissions</span><span class="params">()</span></span> &#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="comment">//[2]每次使用之前检测是否有改权限</span></span><br><span class="line">        <span class="keyword">if</span> (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            safeRequestCameraPermission()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            safeOpenCamera(cameraId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对申请结果进行处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            <span class="comment">//[4]处理请求权限的结果</span></span><br><span class="line">            REQUEST_CAMERA -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    safeOpenCamera(cameraId)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> noCameraPermissionDialog = AlertDialog.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line">                        .setTitle(<span class="string">"警告⚠️"</span>)</span><br><span class="line">                        .setMessage(<span class="string">"没有相机权限，不可继续！\n请赋予相机权限"</span>)</span><br><span class="line">                        .setCancelable(<span class="literal">false</span>)</span><br><span class="line">                        .setPositiveButton(<span class="string">"Yes"</span>) &#123; _, _ -&gt;</span><br><span class="line">                            safeRequestCameraPermission()</span><br><span class="line">                        &#125;</span><br><span class="line">                        .setNegativeButton(<span class="string">"No"</span>) &#123; _, _ -&gt; finish() &#125;</span><br><span class="line">                        .create()</span><br><span class="line">                    noCameraPermissionDialog.show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>safeRequestCameraPermission()</code>的内容，这里才是处理申请权限的相关代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">safeRequestCameraPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//[3]检测是否需要解释为什么需要改权限</span></span><br><span class="line">    <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, Manifest.permission.CAMERA)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次请求时为false</span></span><br><span class="line"><span class="comment">         * 第二次请求时为true，需要解释为什么需要这个权限</span></span><br><span class="line"><span class="comment">         * 若用户选择了不再提示则一直为false</span></span><br><span class="line"><span class="comment">         * 综上，如果不是第一次请求该权限，并且返回值为false，那么可以判断用户选择了不再提示</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//向用户解释为什么需要改权限</span></span><br><span class="line">        <span class="keyword">var</span> noCameraDialog = AlertDialog.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line">            .setTitle(<span class="string">"提示️"</span>)</span><br><span class="line">            .setMessage(<span class="string">"本应用正常运行需要相机权限，点击确认开始赋予权限"</span>)</span><br><span class="line">            .setCancelable(<span class="literal">false</span>)</span><br><span class="line">            .setPositiveButton(<span class="string">"Yes"</span>) &#123; _, _ -&gt;</span><br><span class="line">                <span class="comment">//用户同意后开始申请权限</span></span><br><span class="line">                doRequestCameraPermission()</span><br><span class="line">            &#125;</span><br><span class="line">            .create()</span><br><span class="line">        noCameraDialog.show()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.d(<span class="string">"TAG"</span>, <span class="string">"count "</span> + mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> (mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, <span class="number">0</span>) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//TODO 用户拒绝了赋予权限，并且选择了“不再提醒”，提示用户到设置中开启</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doRequestCameraPermission()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doRequestCameraPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//每次申请权限时更新计数器</span></span><br><span class="line">    <span class="keyword">var</span> count = mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    mSharedPreferences.edit().putInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, count).apply()</span><br><span class="line">    requestPermissions(arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>样例代码: <a href="https://github.com/jixiaoyong/Notes-Files/commit/f41afa99c24cde1dab619462754435f2a2afc64e#diff-67ccb5e5c6c34760486a1071b23338a2" target="_blank" rel="noopener">Github</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java中的泛型</title>
      <link href="/blog/posts/b2cdb69e/"/>
      <url>/blog/posts/b2cdb69e/</url>
      
        <content type="html"><![CDATA[<p>Java中的泛型实现了<strong>参数类型化</strong>的概念。</p><p>主要有以下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneClazz</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    &lt;Y&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文主要记录Java泛型一些比较特殊的知识点。</p><h1 id="泛型特性"><a href="#泛型特性" class="headerlink" title="泛型特性"></a>泛型特性</h1><p>泛型在Java SE5被引入，可以在类和方法中，将类型作为类型参数传入。</p><p>泛型类型参数会在实际运行时被<strong>擦除</strong>到他的第一个边界。如<code>&lt;T&gt;</code>会被擦除为<code>Objet</code>，而<code>&lt;T extends ClazzA&gt;</code>则会被擦除为<code>ClazzA</code>。</p><h1 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h1><h2 id="不能有泛型数组"><a href="#不能有泛型数组" class="headerlink" title="不能有泛型数组"></a>不能有泛型数组</h2><p>这是因为Java中Object[]默认为所有数组的父类，如下代码虽然在编译期不会报错，但是在运行时会被检查出objArr指向的数组实际类型（String）和要赋予的类型（Integer）不一致而报错。</p><p>也就是说，数组只能存放<strong>定义的实际类型</strong>以及他们的<strong>子类型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] objArr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">objArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但是，如果支持泛型数组：由于泛型类型参数会在运行时被擦除，导致即使到了运行时也无法发现这个错误，从而会导致错误。</p><p>如下，加入支持泛型参数，则objArr1中实际保存的类型（Map&lt;String,Integer&gt;），在编译的时候由于objArr1和objArr2都是Object类型的数组，编译通过；在运行的时候，由于Map中的泛型参数类型已经被擦除，也无法区分objArr1和objArr2中实际指向的两个Map&lt;K,V&gt;数组，也是合法的，这样原本定义的是Map&lt;String,Integer&gt;数组，却可以保存任何类似的Map，而这本来是不允许的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] objArr1 = <span class="keyword">new</span> Map&lt;String,Integer&gt;[<span class="number">10</span>];</span><br><span class="line">Object[] objArr2 = <span class="keyword">new</span> Map&lt;Double,Integer&gt;[<span class="number">10</span>];</span><br><span class="line">objArr1[<span class="number">0</span>] = objArr2[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p>Collections 类通过一种别扭的方法绕过了这个问题，在 Collections 类编译时会产生类型未检查转换的警告。</p><p><code>ArrayList</code>具体实现的构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">private</span> V[] backingArray;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;         backingArray = (V[])<span class="keyword">new</span> Object()[DEFAULT_SIZE];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>为何这些代码在访问 <code>backingArray</code>时没有产生 <code>ArrayStoreException</code>呢？无论如何，都不能将 <code>Object</code>数组赋给 <code>String</code>数组。因为泛型是通过擦除实现的，<code>backingArray</code>的类型实际上就是 <code>Object[]</code>，因为 <code>Object</code>代替了 <code>V</code>。</p><p><strong>这意味着：实际上这个类期望 <code>backingArray</code>是一个 <code>Object</code>数组，但是编译器要进行额外的类型检查，以确保它包含 <code>V</code>类型的对象。</strong></p><p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp01255.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp01255.html</a></p></blockquote><h1 id="泛型容器"><a href="#泛型容器" class="headerlink" title="泛型容器"></a>泛型容器</h1><p>由于泛型的类型在运行时会被擦除，所以将类型检查放到了编译期。</p><p><code>List&lt;Clazz&gt;</code> 泛型列表只能保存指定泛型类型<code>T</code>的数据，而不能保存其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//编译时报错，类型不兼容</span></span><br><span class="line">List&lt;Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br></pre></td></tr></table></figure><p>但是能保存Fruit的容器应该也要能安全的保存Apple，为了实现这一点，类似于数组中<code>Object[] arr = Apple[]</code>的向上转型，可以使用<code>?</code>引入协变。</p><h2 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h2><p><code>List&lt;? extends T&gt;</code> 可以<strong>合法的指向一个<code>List&lt; SubT&gt;</code></strong>，这个过程会完成自动<strong>向上转型</strong>，成为可以持有<strong>某个诸如T或者T的子类</strong>的List，但是编译器不知道这个<strong>类</strong>具体是什么，所以拒绝向其中传递任何类型对象，即使Object也不行。</p><p>可以这么想，<code>&lt;? extends T&gt;</code>表示的是T的子类，那么<code>List&lt;? extends T&gt;</code> 保存的便是<strong>T的某个子类</strong>，所以不能保存Object或者T等类型，又由于列表不能保存不同的类型，所以也不能保存任何T的子类,即容器将数组在运行时才会有的类型检查放到了编译期（原因是运行时类型会被擦除）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();<span class="comment">//可以安全的应用</span></span><br><span class="line">fruits2.add(<span class="keyword">new</span> Apple());<span class="comment">//编译时报错，类型转化错误</span></span><br><span class="line">fruits2.add(<span class="keyword">new</span> Fruit());<span class="comment">//编译时报错</span></span><br></pre></td></tr></table></figure><h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h2><p><code>List&lt;? super T&gt;</code> <strong>主动声明</strong>通配符<code>?</code>的超类型为<code>T</code>,即List保存的是<strong>T的某个父类</strong>，那么List也可以安全的保存<strong>T或者T的子类</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span></span>&#123;</span><br><span class="line">    apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Fruit());<span class="comment">//error 类型错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/20928981/answer/39234969" target="_blank" rel="noopener">java为什么不支持泛型数组？ - ylxfc的回答 - 知乎</a></p><p><a href="https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html" target="_blank" rel="noopener">Oracle Java 泛型原理</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp01255.html" target="_blank" rel="noopener">Java 理论和实践-了解泛型-识别和避免学习使用泛型过程中的陷阱</a></p><p><a href="https://www.jianshu.com/p/2bf15c5265c5" target="_blank" rel="noopener">Java泛型（二） 协变与逆变</a></p><p>《Java编程思想 第4版》</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flutter Widget简单入门</title>
      <link href="/blog/posts/e35c106d/"/>
      <url>/blog/posts/e35c106d/</url>
      
        <content type="html"><![CDATA[<p>Flutter是Google提出的跨平台开发框架，使用Dart语言，支持Android，IOS系统。Flutter一个重要的概念即是——<em>“万物皆控件（Widget）”</em>，像<code>Padding</code>,<code>Center</code>等都是Widget。</p><p>Widget和Android中的View很相似但又有不同，Widget一旦生成便“一成不变”，直到下一次因为Widget更改或者state更新而被重新创建（Flutter’s framework creates a new tree of widget instances.），而View则只会被<code>drawn</code>一次，直到<code>invalidate</code>方法被调用。</p><p>本文主要记录一下Flutter中两个重要的控件：StatelessWidget和StatefulWidget，以及Flutter开发的一些基础知识。</p><h1 id="Flutter基础知识"><a href="#Flutter基础知识" class="headerlink" title="Flutter基础知识"></a>Flutter基础知识</h1><p>Flutter以Dart开发，其工程基本的结构如下：</p><ul><li>android</li><li>ios</li><li>lib<ul><li>main.dart</li></ul></li><li>pubspec.yaml //Flutter工程的配置信息</li></ul><p>Flutter项目启动后会首先加载<code>/lib/main.dart</code>中的<code>main()</code>方法。<br>一个标准的material app的main.dart内容如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./product_manager.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() =&gt; runApp(MyApp());<span class="comment">//在main()方法中调用了material的runApp()方法，里面传入了要展示的Widget——APP的界面，相当于Android的setContentView()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.deepOrange</span><br><span class="line">      ),</span><br><span class="line">      home: Scaffold(<span class="comment">//脚手架，一个预制的APP界面结构，也可以使用自定义Widget</span></span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">"EasyList"</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: ProductManager(<span class="string">"Test"</span>),<span class="comment">//这里是自定义的控件，布局信息主要在这里展示</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="StatelessWidget-amp-StatefulWidget"><a href="#StatelessWidget-amp-StatefulWidget" class="headerlink" title="StatelessWidget &amp; StatefulWidget"></a>StatelessWidget &amp; StatefulWidget</h1><p>StatelessWidget和StateFulWidget区别在于：前者一旦创建，状态便不会再更改，而后者则可以动态改变State从而使flutter改变其状态。但是两者都会在每一帧被rebuild。</p><h2 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2><blockquote><p>A <code>StatelessWidget</code> is just what it sounds like—a widget with no state information.</p></blockquote><p>StatelessWidget一旦创建便不会更改，其状态只和构造函数中的参数有关。下面是一个StatelessWidget示例，一般只需要重写其build()方法，返回要展示的控件即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomerWidget();<span class="comment">//在这里构建一个页面并返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><blockquote><p><code>StatefulWidget</code> has a <code>State</code> object that stores state data across frames and restores it.</p></blockquote><p>StatefulWidget可以通过动态更改其包含的State，从而使flutter在下一次更新界面时依据state更新StateWidget，<em>本质上还是更新了一个可以在多帧之间存活的State，在下一帧更新控件</em>。</p><p>下面是一个StatefulWidget的示例:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductManager</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> ProductManagerState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductManagerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ProductManager</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomerWidget();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到StatefulWidget重写了<code>createState()</code>，而该方法返回了自定义的<code>ProductManagerState</code>类对象，在该类中<code>build()</code>方法实现和StatelessWidget中的方法类似，返回要展示的页面控件。</p><p>两者的不同之处在于，StatefulWidget中可以调用<code>setState()</code>，更改其相应的<code>state</code>，以便告诉flutter在下一次rebuild的时候更新UI。</p><p>StatelessWidget要想实现动态更新其内容，可以在其外部包裹一层StatefulWidget，通过StatefulWidget更改状态state，将更改后的state传给StatelessWidget，从而间接更新了StatelessWidget的状态。</p><p>可以通过对该方法就行包装，使得在StatelessWidget控件中调用StatefulWidget控件的<code>setState()</code>方法，达到刷新页面的效果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatefulWidget</span></span><br><span class="line">  <span class="keyword">void</span> aFun()&#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// update UI</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">AStatelessWidget(aFun);<span class="comment">// 将该方法传入StatelessWidget中</span></span><br><span class="line"><span class="comment">// StatelessWidget</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">Function</span> aFun</span><br><span class="line">AStatelessWidget(<span class="keyword">this</span>.aFun);<span class="comment">// 接收传入的方法</span></span><br><span class="line">aFun();<span class="comment">// 执行该方法，从而实现调用StatelessWidget中的方法也可以刷新UI</span></span><br></pre></td></tr></table></figure><h1 id="与Android的对比"><a href="#与Android的对比" class="headerlink" title="与Android的对比"></a>与Android的对比</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Android的Intent有两个主要作用：</p><ul><li>Activity间跳转</li><li>组件间传递数据</li></ul><p>Flutter对此相应：</p><ul><li>使用Navigator和<code>Route</code>s实现在同一个“Activity”中不同的界面间（ “screen” or “page”）跳转（push，pop），Navigator类似于Android中的Activity栈。</li><li>通过Android原生Intent组件获取到其他App传来的数据，然后中通过下面的方法实现Android和Flutter交互：</li></ul><p>示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Android</span></span><br><span class="line"> MethodChannel(getFlutterView(), <span class="string">"app.channel.shared.data"</span>)</span><br><span class="line">      .setMethodCallHandler(MethodChannel.MethodCallHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public <span class="keyword">void</span> onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123;</span><br><span class="line">          <span class="keyword">if</span> (methodCall.method.contentEquals(<span class="string">"getSharedText"</span>)) &#123;</span><br><span class="line">            result.success(sharedText);</span><br><span class="line">            sharedText = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"> <span class="comment">//Flutter</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">_SampleAppPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">SampleAppPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> platform = <span class="keyword">const</span> MethodChannel(<span class="string">'app.channel.shared.data'</span>);</span><br><span class="line">  <span class="built_in">String</span> dataShared = <span class="string">"No data"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    getSharedText();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(body: Center(child: Text(dataShared)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSharedText() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sharedData = <span class="keyword">await</span> platform.invokeMethod(<span class="string">"getSharedText"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sharedData != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        dataShared = sharedData;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>Flutter是单线程的，他的线程和Android的UI线程绑定，在进行网络请求，IO操作等时，可以使用<code>sync/await</code> 在执行完耗时操作后，再去更新state刷新UI。</p><blockquote><p>Since Flutter is single threaded and runs an event loop (like Node.js), you don’t have to worry about thread management or spawning background threads. If you’re doing I/O-bound work, such as disk access or a network call, then you can safely use async/await and you’re all set. </p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> dataURL = <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>;</span><br><span class="line">  http.Response response = <span class="keyword">await</span> http.<span class="keyword">get</span>(dataURL);</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    widgets = json.decode(response.body);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果有特别频繁的cpu计算以至于能导致UI挂起，可以考虑使用<code>Isolate</code>s利用CPU多核心处理任务，但是这样就不能和主线程共享数据，通过<code>ReceivePort</code>，<code>SendPort</code>等传递数据。</p><blockquote><p>Isolates(隔离) are separate execution threads that do not share any memory with the main execution memory heap. This means you can’t access variables from the main thread, or update your UI by calling <code>setState()</code>. Unlike Android threads, Isolates are true to their name, and cannot share memory (in the form of static fields, for example).</p></blockquote><h2 id="本地资源"><a href="#本地资源" class="headerlink" title="本地资源"></a>本地资源</h2><p>截止Flutter beta 2 仍然不能直接访问Android assets或者其他本地资源，但是Android可以访问flutter的assets资源：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val flutterAssetStream = assetManager.open(<span class="string">"flutter_assets/assets/my_flutter_asset.png"</span>)</span><br></pre></td></tr></table></figure><p>通过Channel，flutter可以间接访问Android资源，反之亦然。</p><blockquote><p>主要是通过Channel完成，可以称之为隧道。主要是MethodChannel和MessageChannel两种，第一种是调用方法，第二种是传递信息。首先通信的双方是Flutter和本地操作系统或者应用，而且方法的调用和消息的方法可以从任何一方发起，类似RPC（远程过程调用）。</p><p>作者：黄马</p><p>链接：掘金  <a href="https://juejin.im/post/5b35a75e51882574ea3a25e3" target="_blank" rel="noopener">https://juejin.im/post/5b35a75e51882574ea3a25e3</a></p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Flutter生命周期没有Android中那么“重要”，可以重写 <code>didChangeAppLifecycleState()</code> 监听。</p><ul><li><code>inactive</code> — 应用处于非活动状态，不接受输入。iOS</li><li><code>paused</code> — 应用在后台运行，不可见，不接受输入。类似Android的<code>onPause()</code></li><li><code>resumed</code> — 应用可见，并接受输入。类似Android的<code>onPostResume()</code></li><li><code>suspending</code> — 应用请求暂停。类似Android的<code>onStop()</code></li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>Flutter有布局Widget如：</p><ul><li>Column 列</li><li>Row 行</li><li>Stack 左上角堆积，类似FrameLayout</li></ul><h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>FLutter中的“<code>onClick()</code>”: <code>onPressed</code>,<code>onTap</code>等等。</p><p>添加点击事件,在Widget外面添加一个<code>GestureDetector</code>Widget：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">  child: Padding(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">      child: Text(<span class="string">"Row <span class="subst">$i<span class="string">")),</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  onTap: () &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    print('row tapped');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;,</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">);</span></span></span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.youtube.com/watch?v=GLSG_Wh_YWc" target="_blank" rel="noopener">Flutter Tutorial for Beginners - Build iOS and Android Apps with Google’s Flutter &amp; Dart</a></p><p><a href="https://flutter.io/flutter-for-android/" target="_blank" rel="noopener">Flutter for android</a></p><p><a href="https://juejin.im/post/5b35a75e51882574ea3a25e3" target="_blank" rel="noopener">Flutter 访问本地资源</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AIDL在Android中的使用</title>
      <link href="/blog/posts/f931e8ae/"/>
      <url>/blog/posts/f931e8ae/</url>
      
        <content type="html"><![CDATA[<p>AIDL（Android Interface Definition Language ，Android接口定义语言）用于Android IPC，适用于大量并发请求。</p><p>主要分为两部分：</p><ol><li>服务端 创建Service监听Client的请求，通过创建AIDL将接口暴露给客户端</li><li>客户端 绑定到服务端获取BInder对象，将其转化为对应AIDL，并调用接口对应方法。</li></ol><blockquote><p>两者的连线就是AIDL，因此两个APP的AIDL必须一致，可以将AIDL文件放到一个Android Library中，或者打成aar文件供二者依赖。</p><p>也可以将AIDL涉及到的AIDL文件、java都放到AIDL文件夹下，然后在build.gradle的android{…}中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;    sourceSets&#123;</span><br><span class="line">&gt;         main&#123;</span><br><span class="line">&gt;             java.srcDirs = [&apos;src/main/java&apos;,&apos;src/main/adil&apos;]</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>即添加一个java路径</p></blockquote><h1 id="AIDL-文件特点"><a href="#AIDL-文件特点" class="headerlink" title="AIDL 文件特点"></a>AIDL 文件特点</h1><h2 id="1-支持数据格式"><a href="#1-支持数据格式" class="headerlink" title="1.支持数据格式"></a>1.支持数据格式</h2><p>基本数据类型、List（ArrayList）、Map（HashMap）以及实现了Parcelable接口的对象、AIDL接口。</p><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h2><ul><li>自定义的Parcelable对象、AIDL对象必须显示import。</li><li>AIDL中用到的Parcelable对象必须新建一个同名AIDL接口，声明其为Parcelable类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// People.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line">parcelable People;</span><br></pre></td></tr></table></figure><ul><li>AIDL中除了基本数据类型，其他的参数必须标记方向（in,out,inout）。</li><li>AIDL中只支持方法，不支持静态变量。</li></ul><h1 id="AIDL用法"><a href="#AIDL用法" class="headerlink" title="AIDL用法"></a>AIDL用法</h1><h2 id="1-AIDL"><a href="#1-AIDL" class="headerlink" title="1.AIDL"></a>1.AIDL</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ManagerAidl.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.TaskCallBack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ManagerAidl</span> </span>&#123;</span><br><span class="line">    <span class="comment">//客户端提供的方法</span></span><br><span class="line">    <span class="function">List&lt;People&gt; <span class="title">getPeopleList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addPeople</span><span class="params">(in People people)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调接口，用于服务端往客户端通信</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerCallBack</span><span class="params">(in TaskCallBack callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterCallBack</span><span class="params">(in TaskCallBack callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskCallBack.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://blog.csdn.net/woshiwoshiyu/article/details/54266101</span></span><br><span class="line"><span class="comment">//回调的具体方法，供服务端回调</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TaskCallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callBack</span><span class="params">(in <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPeopleChange</span><span class="params">(in List&lt;People&gt; peoples)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//People.java</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PeopleManager.java</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个管理类，封装了客户端绑定服务端的一些方法</span></span><br><span class="line"><span class="comment"> * 属于客户端部分，不过放在AIDL中便于多个客户端开发</span></span><br><span class="line"><span class="comment"> * Created by jixiaoyong on 2018/8/6.</span></span><br><span class="line"><span class="comment"> * email:jixiaoyong1995@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PeopleManager mPeopleManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Context mContext;</span><br><span class="line">    <span class="keyword">private</span>  Listener mListener;</span><br><span class="line">    <span class="keyword">private</span> ManagerAidl managerAidl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;People&gt; peopleList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现该回调方法，用于调用客户端的具体方法</span></span><br><span class="line">    <span class="comment">//注意这里是new TaskCallBack.Stub()，而非new TaskCallBack(),否则服务器无法接收到callback</span></span><br><span class="line">    <span class="keyword">private</span> TaskCallBack callBack = <span class="keyword">new</span> TaskCallBack.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callBack</span><span class="params">(<span class="keyword">int</span> size)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mListener.onCallback(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeopleChange</span><span class="params">(List&lt;People&gt; peoples)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            peopleList = peoples;</span><br><span class="line">            mListener.onPeopleListChange(peoples);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection serviceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在连接上服务端后，客户端从IBinder对象中获取到AIDL接口对象，并执行其方法</span></span><br><span class="line">            managerAidl =  ManagerAidl.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                peopleList = managerAidl.getPeopleList();</span><br><span class="line">                managerAidl.registerCallBack(callBack);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            mListener.onCreate(mPeopleManager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                managerAidl.unregisterCallBack(callBack);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PeopleManager</span><span class="params">(Context context,Listener listener)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mListener = listener;</span><br><span class="line">        peopleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"cf.android666.demo"</span>,</span><br><span class="line">                <span class="string">"cf.android666.demo.MService"</span>));<span class="comment">//Android5.0后必须显示的启动服务</span></span><br><span class="line">        context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context,Listener listener)</span> </span>&#123;</span><br><span class="line">        mPeopleManager = <span class="keyword">new</span> PeopleManager( context, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPeople</span><span class="params">(People people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            managerAidl.addPeople(people);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;People&gt; <span class="title">getPeopleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> peopleList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类可以实现该Listener的方法，在服务端调用这些方法时执行对应操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(PeopleManager peopleManager)</span></span>;<span class="comment">//服务连接成功</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCallback</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onPeopleListChange</span><span class="params">(List&lt;People&gt; peoples)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2.服务端"></a>2.服务端</h2><p>注意MService在AndroidManife.xml中配置:</p><p><code>android:exported=&quot;true&quot;android:enabled=&quot;true&quot;android:process=&quot;:people&quot;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MService.java</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteCallbackList;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.text.InputFilter;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.ManagerAidl;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.TaskCallBack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by jixiaoyong on 2018/8/6.</span></span><br><span class="line"><span class="comment"> * email:jixiaoyong1995@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MService</span> <span class="keyword">extends</span> <span class="title">Service</span> <span class="keyword">implements</span> <span class="title">ManagerAidl</span>.<span class="title">Stub</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;People&gt; mPeopleList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RemoteCallbackList&lt;TaskCallBack&gt; callbackList = <span class="keyword">new</span> RemoteCallbackList&lt;&gt;();;</span><br><span class="line">    <span class="keyword">private</span> TaskCallBack mCallBack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用AIDL接口生成mIBinder，在服务端实现接口各个方法，供客户端调用</span></span><br><span class="line">    <span class="keyword">private</span> IBinder mIBinder = <span class="keyword">new</span> ManagerAidl.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;People&gt; <span class="title">getPeopleList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mPeopleList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPeople</span><span class="params">(People people)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mPeopleList.add(people);</span><br><span class="line">            onPeopleChange(mPeopleList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCallBack</span><span class="params">(TaskCallBack callback)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mCallBack = callback;</span><br><span class="line">            Log.d(<span class="string">"TAG"</span>, <span class="string">"registerCallBack注册回调方法 callback == null"</span> + callback);</span><br><span class="line">            <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;<span class="comment">//注意这里一定要判断非空</span></span><br><span class="line">                callbackList.register(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterCallBack</span><span class="params">(TaskCallBack callback)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callbackList.unregister(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"tag"</span>, <span class="string">"onBind  MService开始了"</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPeopleList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPeopleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            mPeopleList.add(<span class="keyword">new</span> People(<span class="string">"people"</span> + i, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mIBinder;<span class="comment">//返回开始用AIDL创建的IBinder</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现DeathRecipient接口的方法，在客户端终止后自动调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callbackList.unregister(mCallBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里时在服务端调用回调方法的写法，是从callbackList依次取出来执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onPeopleChange</span><span class="params">(List&lt;People&gt; peoples)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = callbackList.beginBroadcast();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                callbackList.getBroadcastItem(i).onPeopleChange(peoples);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            callbackList.finishBroadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-客户端"><a href="#3-客户端" class="headerlink" title="3.客户端"></a>3.客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PeopleManager.init(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务连接成功后，可以开始调用服务的一系列方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(PeopleManager peopleManager)</span> </span>&#123;</span><br><span class="line">    mPeopleManager = peopleManager;</span><br><span class="line">    peopleList = peopleManager.getPeopleList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; peopleList.size(); i++) &#123;</span><br><span class="line">        Log.d(<span class="string">"tag"</span>, <span class="string">"people list is "</span> + peopleList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他回调方法，等服务端回调时会执行对应方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeopleListChange</span><span class="params">(List&lt;People&gt; peoples)</span> </span>&#123;</span><br><span class="line">    Log.d(<span class="string">"TAG"</span>, <span class="string">"demo2 people变化了"</span> + peoples.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> aidl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android事件分发</title>
      <link href="/blog/posts/c0fefed0/"/>
      <url>/blog/posts/c0fefed0/</url>
      
        <content type="html"><![CDATA[<p>Android事件分发，指手指点击屏幕后，从Activity、ViewGroup到View的一系列过程。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Android系统的窗口机制如下图：</p><p>Activity内有一个Window对象，其实现类是PhoneWindow；</p><p>DecorView为顶层View，DecorView是一个FrameLayout，其中有TitleView和ContentView；</p><p><img src="https://github.com/jixiaoyong/jixiaoyong.github.io/blob/master/images/blog/2018-04/AndroidDispatchTouchEvent.png?raw=true" alt="Android系统窗口管理机制"></p><p>TitleView为标题栏，ContentView就是平时在Activity的onCreate()方法中设置的视图，TitleView可以用<code>this.requestWindowFeature(Window.FEATURE_NO_TITLE);</code>隐藏掉，但是必须注意要在setContentView()之前，原因如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(view);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="点击事件-Activity-–-gt-ViewGroup"><a href="#点击事件-Activity-–-gt-ViewGroup" class="headerlink" title="点击事件 Activity –&gt; ViewGroup"></a>点击事件 Activity –&gt; ViewGroup</h1><p>点击事件发生后，首先被调用的是<code>Activity.dispatchTouchEvent()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其内部先调用了<code>getWindow().superDispatchTouchEvent(ev)</code>这个方法，getWindow()返回的mWindow是PhoneWindow的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br></pre></td></tr></table></figure><p>再看看PhoneWindow.superDispatchTouchEvent()方法，显然又调用了DecorView的superDispatchTouchEvent()方法,在该方法中，调用了FrameLayout.dispatchKeyEvent(event)，此时<strong>点击事件从Activity转到了ViewGroup中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhoneWindow</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchKeyEvent(event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DecorView extends FrameLayout</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Give priority to closing action modes if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">        <span class="comment">// Back cancels action modes first.</span></span><br><span class="line">        <span class="keyword">if</span> (mPrimaryActionMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                mPrimaryActionMode.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="点击事件-ViewGroup-–-gt-View"><a href="#点击事件-ViewGroup-–-gt-View" class="headerlink" title="点击事件 ViewGroup –&gt; View"></a>点击事件 ViewGroup –&gt; View</h1><p>ViewGroup与事件分发的方法有三个：</p><ul><li><code>dispatchTouchEvent()</code>  分发事件</li><li><code>onInterceptTouchEvent()</code>  拦截事件</li><li><code>onTouchEvent()</code>  处理点击事件</li></ul><p>当ViewGroup.dispatchTouchEvent()被调用后，会通过一系列条件判断是由ViewGroup拦截该事件，还是由子View消耗该事件。</p><p>主要流程分为两部分</p><p><strong>1.检查是否需要拦截</strong></p><ul><li>每次ACTION_DOWN事件都需要调用<code>onInterceptTouchEvent()</code>方法判断是否需要拦截</li><li>其他MotionEvent事件，如果有能处理点击事件的子View（<code>mFirstTouchTarget != null</code>）且<code>disallowIntercept</code>为false也需要调用<code>onInterceptTouchEvent()</code>方法判断是否需要拦截，否则不需要拦截</li><li>其余情况都需要拦截（没有可以处理点击事件的子View，并且不是ACTION_DOWN事件）</li></ul><p><strong>2.遍历ViewGroup的所有子View，寻找一个可以处理点击事件的子View</strong></p><ul><li><code>dispatchTransformedTouchEvent()</code>   调用了子View的<code>dispatchTouchEvent()</code></li><li><code>addTouchTarget()</code>   对<code>mFirstTouchTarget</code>进行更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1. Check for interception.判断是否需要拦截</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;<span class="comment">//mFirstTouchTarget表示能处理点击事件的子View</span></span><br><span class="line">            <span class="comment">//FLAG_DISALLOW_INTERCEPT每次ACTION_DOWN都会被重置</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);<span class="comment">//调用拦截方法</span></span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.遍历子View，寻找可以处理点击事件的子View</span></span><br><span class="line">    <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                     <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                     ...</span><br><span class="line">                     newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                     alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchTransformedTouchEvent()方法如下，由于<code>child != null</code>其内部调用<code>child.dispatchTouchEvent(event)</code>方法，如此循环直到子View是一个View（单就ViewGroup和View而论）即<strong>将点击事件从ViewGroup分发到了View</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有子View可以处理点击事件，在<code>addTouchTarget()</code>方法内部对<code>mFirstTouchTarget</code>进行更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="点击事件-View内部"><a href="#点击事件-View内部" class="headerlink" title="点击事件 View内部"></a>点击事件 View内部</h1><p>View的点击事件分发主要涉及到两个方法：</p><ul><li><code>dispatchTouchEvent()</code></li><li><code>onTouchEvent()</code></li></ul><p>其点击事件分发用伪代码表示如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mListenerInfo.mOnTouchListener.onTouch(<span class="keyword">this</span>, event))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见View的dispatchTouchEvent()方法中，如果View注册了OnTouchListener则会先执行<code>mOnTouchListener.onTouch()</code>方法,如果该方法返回false才会执行<code>onTouchEvent()</code>。</p><p>在看onTouchEvent()方法：</p><ul><li>如果View处于<strong>不可用状态</strong>下，也会消耗点击事件，只不过没有反应</li><li>如果注册了OnClickListener会在ACTION_UP的时候调用<code>mOnClickListener.onClick(this)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(CLICKABLE&amp;&amp;LONG_CLICKABLE)&#123;<span class="comment">//LONG_CLICKABLE默认为false，CLICKABLE、LONG_CLICKABLE会在设置点击事件时被设置为true</span></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:&#123;</span><br><span class="line">                ...</span><br><span class="line">                performClick();<span class="comment">//如果注册了OnClickListener则会调用其onClick()方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mListenerInfo.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个Android的时间分发始于Activity,经过PhoneWindow、DecorView到达ViewGroup，再逐层分发到View中。</p><p>如果底层没有处理点击事件，则又一层层向上返回，直到最顶层消耗掉点击事件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AsyncTask源码解析</title>
      <link href="/blog/posts/7ee9086b/"/>
      <url>/blog/posts/7ee9086b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是AsyncTask源码的简单分析，主要基于《Android开发艺术探索》一书的内容。</p></blockquote><p>AsyncTask是Android中多线程处理方式之一（其余为1.HandlerThread、2.IntentService以及普通的线程Thread）。</p><p>AsyncTask本质是线程池和Handler的包装类，适合实时更新后台任务进度的工作，特别耗时的工作应当交给线程池处理。</p><p>AsyncTask常用方法：</p><ul><li>onPreExecute()</li><li>doInBackground()</li><li>onProgressUpdate()</li><li>onPostExecute()</li></ul><p>AsyncTask有一下限制：</p><ol><li>AsyncTask对象必须在主线程（UI线程，下同）创建</li><li>AsyncTask的execute()必须在主线程调用，且只能被调用一次</li><li>不能<strong>直接调用</strong>其4种常用方法（见上）</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>继承自AsyncTask，重写对应方法。（注意如果需要更新进度，要在doInBackground()方法中调用publishProgress()方法）</li><li>在<strong>UI线程</strong> 实例化AsyncTask对象，并调用其execute()方法，传入参数开始执行。</li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>在execute(params)执行后，将参数params传入mWorker.call()方法</strong></p><p>{调用doInBackground(params)后台执行任务，同时通过postResult()方法发送执行结果，由InternalHandler.handleMessage()判断该执行finish()还是onProgressUpdate()}</p><p>{将mWorker传入mFuture中作为其callable在runAndReset()方法中执行c.call()方法。}</p><p><strong>通过exec.execute(mFuture)将其压入SerialExecutor线程池中排队，并在THREAD_POOL_EXECUTOR.execute(mActive)真正执行。</strong></p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>创建对象（代码有节略，下同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment">//注意这里的要求，必须在ui线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()<span class="comment">//此处创建InternalHandler用于在UI线程处理消息</span></span><br><span class="line">        : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = doInBackground(mParams);<span class="comment">//注意这里会调用doInBackground()方法，后台线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> tr;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postResult(result);<span class="comment">//此处发送msg到mHandler那里接受处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;<span class="comment">//这里将mWorker传了进去</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看FutureTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable; <span class="comment">//将mWorker当做了他的callable</span></span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                 result = c.call(); <span class="comment">//会在这里回调mWorker的call()方法，即前文所说的doInBackgroud()之类的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在主线程调用execute()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123; <span class="comment">//此处限制execute()只能被执行一次</span></span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task is already running."</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task has already been executed "</span></span><br><span class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    onPreExecute(); <span class="comment">//开始前准备工作</span></span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params; <span class="comment">//将参数传入mWorker，并一并传入mFuture中</span></span><br><span class="line">    exec.execute(mFuture);<span class="comment">//将准备好参数、执行时间的mFuture排队放入串行线程池中，等待执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了常用方法之一onPreExecute();</p><p>mWorker和mFuture的关系前文已经描述了，在看一下exec.execute(mFuture)执行了什么：</p><p>exec是execute()传入的，对应于sDefaultExecutor，再查下去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An &#123;<span class="doctag">@link</span> Executor&#125; that executes tasks one at a time in serial</span></span><br><span class="line"><span class="comment">     * order.  This serialization is global to a particular process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br></pre></td></tr></table></figure><p>再看看SerialExecutor这个线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SerialExecutor主要的作用是将这些线程放到线程池中，并按照串行的顺序依次调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//offer() Inserts the specified element at the end of this deque.</span></span><br><span class="line">        <span class="comment">//将r插入到线程池中</span></span><br><span class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//等到当前的执行完了，就调用下一个</span></span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);<span class="comment">//在这里面才是真正的执行线程的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再仔细看一下THREAD_POOL_EXECUTOR</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">        sPoolWorkQueue, sThreadFactory);</span><br><span class="line">threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Executes the given task sometime in the future.  The task</span></span><br><span class="line"> <span class="comment">//may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line">ThreadPoolExector.executr()</span><br></pre></td></tr></table></figure><p>以上介绍了线程和线程池部分的内容，接下来看一下在主线程和后台线程之间是如何依靠handler机制来传递消息的。</p><p>关于构造函数，由于我们开发者只能接触到AsyncTask()这个构造函数，所以<code>mHandler=getMainHandler()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((Looper) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@hide，普通开发者不可见</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">        mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getMainHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sHandler = <span class="keyword">new</span> InternalHandler(Looper.getMainLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sHandler;<span class="comment">//sHandler是一个类变量，取的是主线程的looper,所以限制了AsyncTask只能在主线程实例化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再看一下InternalHandler类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123; <span class="comment">//在这里处理后台线程发过来的消息，UI线程</span></span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在doInBackground()方法中可以使用publishProgress()在后台更新进度，即是使用了handler发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，AsyncTask的finish()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可见，最后会根据情况调用onCancelled()或者onPostExecute()</span></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>加载已安装应用、未安装apk中的资源</title>
      <link href="/blog/posts/8d60b485/"/>
      <url>/blog/posts/8d60b485/</url>
      
        <content type="html"><![CDATA[<p> 加载已安装应用、未安装apk中的资源，其思路主要是获取到对应的ClassLoader/Context，通过ClassLoader加载R.java等类，再通过反射获取对应的资源id及资源。</p><h1 id="加载已安装应用资源"><a href="#加载已安装应用资源" class="headerlink" title="加载已安装应用资源"></a>加载已安装应用资源</h1><h2 id="sharedUserId"><a href="#sharedUserId" class="headerlink" title="sharedUserId"></a>sharedUserId</h2><p>在当前应用中加载已安装的其他应用资源，需要二者有相同的<code>sharedUserId</code>，这样Android系统为二者分配同一个Linux用户ID，两个App可以相互访问代码、资源等。</p><blockquote><p>通过Shared User id,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是可以互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件.就像访问本程序的数据一样。</p><p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/51316688" target="_blank" rel="noopener">Android逆向之旅—Android中的sharedUserId属性详解 - CSDN博客</a></p></blockquote><p>具体设置方法如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"cf.android666.dynamicloadapk"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:sharedUserId</span>=<span class="string">"cf.android666.dynamic"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="筛选所有已安装应用信息"><a href="#筛选所有已安装应用信息" class="headerlink" title="筛选所有已安装应用信息"></a>筛选所有已安装应用信息</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> packageBeanList: ArrayList&lt;PackageInfoBean&gt; = arrayListOf()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> packageInfoList: ArrayList&lt;PackageInfo&gt; = arrayListOf()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> packageInfoList = packageManager.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES) <span class="keyword">as</span> ArrayList&lt;PackageInfo&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (packageInfoList.isNotEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> packageInfoList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.sharedUserId != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; x.sharedUserId.equals(sharedUid)</span><br><span class="line">            &amp;&amp; !x.packageName.equals(packageName)) &#123;</span><br><span class="line">            <span class="comment">//sharedUserId与当前App相同，且packageName和当前App不同的App信息，即插件App</span></span><br><span class="line">            packageBeanList.add(PackageInfoBean(packageManager</span><br><span class="line">                                                .getApplicationLabel(x.applicationInfo).toString(), x.packageName))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="生成插件App的Context"><a href="#生成插件App的Context" class="headerlink" title="生成插件App的Context"></a>生成插件App的Context</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activity.createPackageContext(<span class="string">"cf.android666.pluginapp"</span>,</span><br><span class="line">        Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY)</span><br></pre></td></tr></table></figure><h2 id="通过Context反射获取插件App中的资源"><a href="#通过Context反射获取插件App中的资源" class="headerlink" title="通过Context反射获取插件App中的资源"></a>通过Context反射获取插件App中的资源</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ClassLoader</span></span><br><span class="line"><span class="keyword">var</span> pClassLoader = PathClassLoader(pluginContext.packageResourcePath</span><br><span class="line">                , ClassLoader.getSystemClassLoader())</span><br><span class="line"><span class="comment">//反射获取该类及其资源</span></span><br><span class="line"><span class="keyword">var</span> clazz = pluginContext.classLoader</span><br><span class="line">        .loadClass(pluginContext.packageName + <span class="string">".R\$mipmap"</span>)</span><br><span class="line"><span class="keyword">var</span> abc = clazz.getField(s)</span><br><span class="line"><span class="keyword">var</span> id = abc.getInt(R.mipmap::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="comment">//调用插件App的Context获取其资源</span></span><br><span class="line"><span class="keyword">var</span> bg = pluginContext.resources.getDrawable(id)</span><br></pre></td></tr></table></figure><h1 id="加载未安装Apk内资源"><a href="#加载未安装Apk内资源" class="headerlink" title="加载未安装Apk内资源"></a>加载未安装Apk内资源</h1><h2 id="获取apk信息"><a href="#获取apk信息" class="headerlink" title="获取apk信息"></a>获取apk信息</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sdPath = Environment.getExternalStorageDirectory().absolutePath</span><br><span class="line"><span class="keyword">val</span> apkPath = <span class="string">"<span class="variable">$sdPath</span>/plugin/plugin.apk"</span></span><br><span class="line"><span class="keyword">var</span> info = packageManager.getPackageArchiveInfo(apkPath, PackageManager.GET_ACTIVITIES)<span class="comment">//获取未安装apk的packageInfo</span></span><br></pre></td></tr></table></figure><h2 id="获取ClassLoader"><a href="#获取ClassLoader" class="headerlink" title="获取ClassLoader"></a>获取ClassLoader</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = getDir(<span class="string">"dex"</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">var</span> dexClassLoader = DexClassLoader(apkPath, file.absolutePath, <span class="literal">null</span>, ClassLoader.getSystemClassLoader())</span><br></pre></td></tr></table></figure><blockquote><p>getDir()调用了Context的getDir()</p><p>Retrieve, creating if needed, a new directory in which the application can place its own custom data files.  You can use the returned File object to create and access files in this directory.  Note that files created through a File object will only be accessible by your own application; you can only set the mode of the entire directory, not of individual files.</p></blockquote><h2 id="通过反射加载类，获取资源"><a href="#通过反射加载类，获取资源" class="headerlink" title="通过反射加载类，获取资源"></a>通过反射加载类，获取资源</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawableClazz = dexClassLoader.loadClass(<span class="string">"cf.android666.pluginapp.R\$drawable"</span>)</span><br><span class="line"><span class="keyword">var</span> onePng = drawableClazz.getDeclaredField(<span class="string">"abc"</span>)</span><br><span class="line"><span class="keyword">var</span> onId = onePng.getInt(R.id::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)//反射获取资源<span class="title">id</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resources = getUninstallApkResource()<span class="comment">//resource也是通过反射获取到</span></span><br><span class="line"><span class="keyword">var</span> drawable = resources.getDrawable(onId)</span><br></pre></td></tr></table></figure><p><code>AssetManager.addAssetPath()</code>方法是用来将apk等中的资源添加到<code>AssetManager</code>中，再通过其获取到<code>Resources对象</code>，这样就获取到未安装apk中的资源了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUninstallApkResource</span><span class="params">()</span></span>: Resources &#123;</span><br><span class="line">    <span class="keyword">var</span> assetManager = AssetManager::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">newInstance</span></span>()</span><br><span class="line">    <span class="keyword">var</span> addAssetPath = assetManager.javaClass.getMethod(<span class="string">"addAssetPath"</span>,String::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    addAssetPath.invoke(assetManager, apkPath)<span class="comment">//设置了apkPath</span></span><br><span class="line">    <span class="keyword">return</span> Resources(assetManager, resources.displayMetrics, resources.configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a href="https://www.cnblogs.com/lee0oo0/p/3665066.html" target="_blank" rel="noopener">Android之Android apk动态加载机制的研究（二）：资源加载和activity生命周期管理 - lee0oo0 - 博客园  </a></p><p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/51316688" target="_blank" rel="noopener">Android逆向之旅—Android中的sharedUserId属性详解 - CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM类加载机制之ClassLoader</title>
      <link href="/blog/posts/b3994218/"/>
      <url>/blog/posts/b3994218/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文为<a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">《一看你就懂，超详细java中的ClassLoader详解 - CSDN博客》</a>阅读笔记</p></blockquote><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>JVM有三种类加载器：</p><ol><li><strong>BootStrap ClassLoader</strong> 加载核心类库，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。</li><li><strong>Extention ClassLoader</strong> 扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。</li><li><strong>App ClassLoader</strong> 加载当前应用的classpath的所有类。</li></ol><h1 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h1><p>在加载类时，通过<strong>“双亲委托”</strong>机制，依次从<strong>1</strong> -&gt; <strong>3</strong>向上查询，再从<strong>3</strong>-&gt;<strong>1</strong>依次返回结果：</p><ol><li>调用<code>findLoadedClass(className)</code>查询是否已经加载该类</li><li>调用父加载器的<code>loadClass(className,false)</code>，若父加载器为空，则调用<code>BootStrap ClassLoader</code></li><li>如果还是没有加载到该类，调用<code>findClass(className)</code></li></ol><p>这样子保证了每个类都是先经过最顶端的类加载器<code>BootStrap ClassLoader</code>，如果没有加载到再依次经过<code>Extention ClassLoader</code>、<code>App ClassLoader</code> 加载，确保如String等关键类不会被自定义的ClassLoader加载而导致异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//父加载器没有找到，则调用findclass</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                <span class="comment">//调用resolveClass()</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AppClassLoader</code>和<code>ExtClassLoader</code>都继承自<code>URLClassLoader</code></p><p><code>AppClassLoader</code>的父加载器是<code>ExtClassLoader</code>，<code>ExtClassLoader</code>的父加载器为<code>null</code>，故而会调用<code>BootStrap ClassLoader</code></p><p>ClassLoader如果没有指定父加载器，则默认的父加载器为<code>AppClassLoader</code>，自定义ClassLoader也是如此。</p><h1 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h1><p>自定义ClassLoader一般步骤：</p><ol><li>继承自<code>ClassLoader</code></li><li>重写<code>findClass()</code></li><li>在<code>findClass()</code>方法中调用并返回<code>defineClass()</code></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MClasLoader</span>:<span class="type">ClassLoader</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findClass</span><span class="params">(name: <span class="type">String</span>?)</span></span>: Class&lt;*&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sysDir = System.getProperty(<span class="string">"user.dir"</span>)</span><br><span class="line">        <span class="keyword">var</span> classPath = <span class="string">"<span class="variable">$sysDir</span>/src/main/res/<span class="variable">$name</span>.class"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> classFile = File(classPath)</span><br><span class="line">        <span class="comment">//【注意】这里一次只读取一个字节，否则会报错java.lang.ClassFormatError:</span></span><br><span class="line">        <span class="comment">// Extra bytes at the end of class file TestClass</span></span><br><span class="line">        <span class="keyword">var</span> bytes = ByteArray(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">var</span> fileInputStream = FileInputStream(classFile)</span><br><span class="line">        <span class="keyword">var</span> len = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> byteBuffer = ByteOutputStream()</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            len = fileInputStream.read(bytes)</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.write(bytes)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> byteArr = byteBuffer.toByteArray()</span><br><span class="line">        <span class="keyword">return</span> defineClass(name,byteArr,<span class="number">0</span>,byteArr.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clazz = MClasLoader().loadClass(<span class="string">"TestClass"</span>)</span><br><span class="line">    <span class="keyword">var</span> say = clazz.getDeclaredMethod(<span class="string">"say"</span>,String::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    say.invoke(clazz.newInstance(),<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">    print(MClasLoader().parent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>defineClass()</code>则将一个字节数组转化为一个类的实例（Converts an array of bytes into an instance of class with an optional ProtectionDomain）</p><h1 id="contextClassLoader"><a href="#contextClassLoader" class="headerlink" title="contextClassLoader"></a>contextClassLoader</h1><p>每个线程都有一个ClassLoader：<code>contextClassLoader</code>，通过将其设置为自定义的ClassLoader可以在加载类的时候做一些特殊的事情。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().contextClassLoader = MClasLoader()</span><br><span class="line"><span class="keyword">var</span> clazz = Class.forName(<span class="string">"TestClass"</span>,</span><br><span class="line">        <span class="literal">true</span>, Thread.currentThread().contextClassLoader)</span><br><span class="line"><span class="keyword">var</span> say = clazz.getDeclaredMethod(<span class="string">"say"</span>,String::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">say.invoke(clazz.newInstance(),<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">println(Thread.currentThread().contextClassLoader )</span><br><span class="line">println(Thread.currentThread().contextClassLoader.parent )</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">MClasLoader@1d44bcfa</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JVM_ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 异步消息机制 Handler、Message、Looper</title>
      <link href="/blog/posts/5962504e/"/>
      <url>/blog/posts/5962504e/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此文为鸿洋博客阅读笔记，配合原文食用口味更佳。</p><p><a href="https://blog.csdn.net/lmj623565791/article/details/38377229" target="_blank" rel="noopener">Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系 - CSDN博客</a></p></blockquote><h1 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h1><p><img src="https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/Handler_Message_Looper.png?raw=true" alt="android消息机制思维图"></p><h1 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h1><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><h3 id="Looper-perpare"><a href="#Looper-perpare" class="headerlink" title="Looper.perpare()"></a><strong>Looper.perpare()</strong></h3><p><code>Looper.perpare()</code>方法创建<code>Looper对象</code>（同时创建<code>MessageQueue对象</code>），并与当前线程关联保存在<code>sThreadLocal</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(<span class="keyword">true</span>));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;  </span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);  </span><br><span class="line">        mRun = <span class="keyword">true</span>;  </span><br><span class="line">        mThread = Thread.currentThread();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a><strong>Looper.loop()</strong></h3><p><code>Looper.loop()</code>方法获取保存的<code>Looper对象</code>并由此获取到<code>MessageQueue对象</code>。</p><p>通过<code>for循环</code>，不停的通过<code>mQueue</code>获取到<code>msg</code>，并调用<code>msg.target.dispatchMessage(msg)</code>执行msg对应的处理方法。</p><p>最后通过<code>msg.recycle()</code>回收使用完的msg。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block  </span></span><br><span class="line">        ...</span><br><span class="line">        msg.target.dispatchMessage(msg); </span><br><span class="line">        ...</span><br><span class="line">        msg.recycle();  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Looper-myLooper"><a href="#Looper-myLooper" class="headerlink" title="Looper.myLooper()"></a><strong>Looper.myLooper()</strong></h3><p><code>myLooper()</code>内部调用<code>sThreadLocal</code>获取已有的<code>Looper对象</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Android的Activity默认在UI线程调用了Looper的<code>prepare()</code>和<code>loop()</code>方法</strong></p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><h3 id="handler-sendMessage"><a href="#handler-sendMessage" class="headerlink" title="handler.sendMessage()"></a>handler.sendMessage()</h3><p>Handler构造方法会获取到<code>mLooper</code>和<code>mQueue</code>以及<code>mCallback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mLooper = Looper.myLooper();  </span><br><span class="line">mQueue = mLooper.mQueue;  </span><br><span class="line">mCallback = callback;  <span class="comment">// Handler()中此值为null</span></span><br></pre></td></tr></table></figure><p><code>sendMessage()</code>方法最终会调用<code>sendMessageAtTime()</code>方法,在其内部调用<code>enqueueMessage()</code>方法，将handler赋予msg.target，并将msg压入mQueue中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enqueueMessage方法</span></span><br><span class="line">msg.target = <span class="keyword">this</span>;</span><br><span class="line">queue.enqueueMessage(msg, uptimeMillis);<span class="comment">//将handler发送的msg压入到当前线程的Looper持有的MessageQueue中</span></span><br></pre></td></tr></table></figure><h3 id="handler-dispatchMessage"><a href="#handler-dispatchMessage" class="headerlink" title="handler.dispatchMessage()"></a>handler.dispatchMessage()</h3><p>Handler的<code>dispatchMessage()</code>方法会在<code>Looper.loop()</code>中被调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;  <span class="comment">//msg自带的回调方法</span></span><br><span class="line">            handleCallback(msg);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;  <span class="comment">//handler指定的回调方法</span></span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            handleMessage(msg);  <span class="comment">//handler的handleMessage()方法</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中执行顺序是：<code>msg.callback</code> &gt; <code>mCallback</code> &gt; <code>handleMessage()</code></p><h3 id="handler-post"><a href="#handler-post" class="headerlink" title="handler.post()"></a>handler.post()</h3><p><code>handler.post(new Runnable())</code>调用了<code>getPostMessage(r)</code>方法将r赋予msg.callback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span>  </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;  </span><br><span class="line">      Message m = Message.obtain();  </span><br><span class="line">      m.callback = r;  </span><br><span class="line">      <span class="keyword">return</span> m;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后也是在<code>sendMessageDelayed方法</code>中调用<code>sendMessageAtTime()方法</code>将msg压入MessageQueue中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="msg的获取"><a href="#msg的获取" class="headerlink" title="msg的获取"></a>msg的获取</h2><ul><li><code>Message.obtain();</code> 复用MessageMessage池中已有的对象，避免出现分配内存 <strong>推荐</strong> </li><li><code>new Message();</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>Looper</strong>在<strong><code>perfare()</code></strong>方法中创建<code>Looper及MessageQueue对象</code>并保存在<code>sThreadLocal</code>中，</p><p>在<strong><code>loop()</code></strong>方法中通过<code>myLooper()</code>从<code>sThreadLocal</code>中取出<code>mLooper</code>，并由此获得<code>mQueue</code>，在for循环中通过<code>mQueue.next()</code>获取<code>msg</code>，用<code>msg.target.dispatchMessage()</code>方法回调<code>handler中的msg处理方法</code>。</p><p><strong>Handler</strong>在<strong><code>构造函数</code></strong>中通过<code>Looper.myLooper()</code>获取到<code>当前线程的Looper和MessageQueue</code>；</p><p><strong><code>sendMessage()</code></strong>方法最终通过<code>sendMessageAtTime()</code>调用<code>enqueueMessage()</code>方法<code>将msg压入到MessageQueue</code>中。</p><p>至此将<em>Looper和Handler通过MessageQueue联系在一起</em>，并共同参与处理Message。</p><p>此外<strong><code>handler.post(runnable)</code></strong>也是通过在<strong><code>post()</code></strong>内部调用<code>getPostMessage()</code>方法将<code>runnable赋予msg.callback</code>，并在<code>post()</code>中通过<code>sendMessageDelayed()</code>方法调用<code>sendMessageAtTime()方法</code>将<code>msg压入MessageQueue</code>中</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android多渠道打包知识</title>
      <link href="/blog/posts/a3a3dc4c/"/>
      <url>/blog/posts/a3a3dc4c/</url>
      
        <content type="html"><![CDATA[<p>国内Android应用常常要分发到多个应用商店，使用Android Studio正确配置build.gradle与AndroidManifest.xml文件可以<strong>一步打包多个渠道</strong>。</p><p>本文实现的多渠道打包可实现不同渠道：</p><ul><li>有不同的项目id（applicationId）</li><li>不同App名称（android:label）</li><li>不同App图标（android:icon）</li><li>等等</li></ul><h1 id="1-友盟配置"><a href="#1-友盟配置" class="headerlink" title="1.友盟配置"></a>1.友盟配置</h1><p>*具体配置请参考UMeng官方文档。</p><p>作为第三方统计平台，国内很多软件都使用的是Umeng的产品，故而大多数软件多渠道打包配置如下：</p><ul><li>添加依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">../app/build.gradle</span><br><span class="line">dependencies &#123;</span><br><span class="line"><span class="comment">//友盟sdk</span></span><br><span class="line">compile <span class="string">'com.umeng.sdk:common:latest.integration'</span></span><br><span class="line">compile <span class="string">'com.umeng.sdk:analytics:latest.integration'</span></span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure><ul><li>修改AndroidManifest.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!--友盟初始化appkey和channel--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:value</span>=<span class="string">"$&#123;APP_KEY&#125;"</span> <span class="attr">android:name</span>=<span class="string">"UMENG_APPKEY"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"UMENG_CHANNEL"</span> <span class="attr">android:value</span>=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改build.gradle</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line"> productFlavors &#123;</span><br><span class="line">        beta &#123;&#125;</span><br><span class="line">        baidu &#123;&#125;</span><br><span class="line">        zhushou91  &#123;&#125; <span class="comment">//不能以数字开头</span></span><br><span class="line">        anzhi &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123;</span><br><span class="line"></span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name</span><br><span class="line">                                                 ,APP_KEY:umenInfo[<span class="string">'APP_KEY'</span>]]</span><br><span class="line">            <span class="comment">//这里有一个知识点，用build.gradle读取properties文件信息，用于将部分信息统一放置在本地配置文件中，避免泄漏，若无此类要求可直接使用 APP_KEY:'da15d26d1a'等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决flavor Dimensions问题  http://blog.csdn.net/syif88/article/details/75009663</span></span><br><span class="line">    flavorDimensions <span class="string">"versionCode"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他umeng要求的配置</span></span><br></pre></td></tr></table></figure><p>这样编译完之后，通过通过build&gt;Generate Signed APK…便可以打包不同渠道的apk，在友盟统计平台上统计各个渠道的App信息了。</p><h1 id="2-Android-Studio实现多渠道打包"><a href="#2-Android-Studio实现多渠道打包" class="headerlink" title="2.Android Studio实现多渠道打包"></a>2.Android Studio实现多渠道打包</h1><p>方法1要求依赖umeng模块，使用场景难免有些受限，其实我们也可以自己实现多渠道打包，方法1使用的应该也是此原理。</p><ul><li>AndroidManifest.xml</li></ul><p>在需要根据渠道不同而变化的地方使用<code>${KEY}</code>形式替换掉原先的值。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:label</span>=<span class="string">"$&#123;APP_NAME&#125;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"APP_TEXT"</span> <span class="attr">android:value</span>=<span class="string">"$&#123;APP_TEXT&#125;"</span>/&gt;</span>//可以在java文件中获取到</span><br></pre></td></tr></table></figure><ul><li>app/build.gradle</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">    beta &#123;applicationId = <span class="string">"cf.android666.mykotlin.beta"</span><span class="comment">//每个渠道有不同的包名</span></span><br><span class="line">        manifestPlaceholders = [APP_NAME : name ,APP_TEXT:<span class="string">'beta'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    baidu &#123;applicationId = <span class="string">"cf.android666.mykotlin.baidu"</span></span><br><span class="line">        manifestPlaceholders = [APP_NAME:<span class="string">'A APP'</span>,APP_TEXT:<span class="string">'baidu'</span>]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在java中获取<code>meta-data</code>（非必须）</li></ul><blockquote><p>Android获取Manifest中<meta-data>元素的值 - CSDN博客  <a href="https://blog.csdn.net/zhang31jian/article/details/29868235" target="_blank" rel="noopener">https://blog.csdn.net/zhang31jian/article/details/29868235</a></meta-data></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//application中的meta-data</span></span><br><span class="line"><span class="keyword">var</span> appInfo = context.packageManager.getApplicationInfo(context.packageName,</span><br><span class="line">        PackageManager.GET_META_DATA)</span><br><span class="line"><span class="comment">//service、receiver中的meta-data</span></span><br><span class="line"><span class="keyword">var</span> appInfo = context.packageManager.getServiceInfo(ComponentName(context,MService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>),<span class="type"></span></span></span><br><span class="line">                PackageManager.GET_META_DATA)</span><br><span class="line"><span class="keyword">var</span> appName = appInfo.metaData.getString(<span class="string">"APP_NAME"</span>)</span><br></pre></td></tr></table></figure><h1 id="3-生成多个渠道文件夹"><a href="#3-生成多个渠道文件夹" class="headerlink" title="3.生成多个渠道文件夹"></a>3.生成多个渠道文件夹</h1><p>还有一种方法，通过在项目中生成多个渠道的文件夹，在里面替换对应的资源文件，从而实现多渠道打包不同项目名，不同icon等等</p><ul><li><p>在../app/src/目录下新建对应渠道文件夹，和main同级</p></li><li><p>在该渠道目录下新建对应的资源目录，在打包时自动替换对应资源</p><p>​</p><p>目录树如下</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line"></span><br><span class="line">--baidu</span><br><span class="line"></span><br><span class="line">----res/drawable</span><br><span class="line"></span><br><span class="line">--beta</span><br><span class="line"></span><br><span class="line">--main</span><br><span class="line"></span><br><span class="line">----res/drawable</span><br></pre></td></tr></table></figure><h1 id="4-More"><a href="#4-More" class="headerlink" title="4.More"></a>4.More</h1><p>此外还有美团的多渠道打包技术等</p><p>具体可参考文章：<a href="https://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="noopener">美团Android自动化之旅—生成渠道包</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EventBus3简介</title>
      <link href="/blog/posts/c1d65822/"/>
      <url>/blog/posts/c1d65822/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>EventBus is a publish/subscribe event bus for Android and Java.</p><p>若无特殊说明，英文注释引自官方源码或文档，后同</p></blockquote><p>EventBus在android中可以用于组件间，组件和后台线程间的通信，他基于订阅、发布的机制，将事件的收/发解耦，开销小。</p><p>其流程如下（示意图来自官方github库）：</p><p><img src="https://github.com/greenrobot/EventBus/raw/master/EventBus-Publish-Subscribe.png" alt="EventBus-Publish-Subscribe"></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="EventBus的三个要素"><a href="#EventBus的三个要素" class="headerlink" title="EventBus的三个要素"></a>EventBus的三个要素</h2><ul><li><p>Event</p><p>事件，要传递的事件（一个类），EventBus传递该事件的对象，要传递的信息包含在该对象的属性中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>Subscriber</p><p>订阅者，当事件发生时要对事件执行的操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span>  <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Publisher</p><p>发布者，在合适的时候发布事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(Event())</span><br></pre></td></tr></table></figure><p>此外还需要注册、注销EventBus以便订阅者能够正常接收消息</p><p>​</p></li></ul><h2 id="Subscriber的5个线程模式（ThreadMode）"><a href="#Subscriber的5个线程模式（ThreadMode）" class="headerlink" title="Subscriber的5个线程模式（ThreadMode）"></a>Subscriber的5个线程模式（ThreadMode）</h2><ul><li><p>POSTING</p><p>默认的，订阅者和发布者在同一个线程（Subscriber will be called directly in the same thread, which is posting the event）。因为有可能是在主线程，所以不要耗时操作，以免ANR。</p></li><li><p>MAIN</p><p>Android中，订阅者会在UI线程被唤起，同样不能耗时操作</p><blockquote><p>If the posting thread is the main thread, subscriber methods will be called directly, blocking the posting thread. Otherwise the event is queued for delivery (non-blocking). </p></blockquote></li><li><p>MAIN_ORDERED</p><p>Android，订阅者会在UI线程被唤起，不能耗时操作。</p><blockquote><p>Different from MAIN, the event will always be queued for delivery. This ensures that the post call is non-blocking.</p></blockquote></li><li><p>BACKGROUND</p><p>Android中，如果post在主线程，那么订阅者在新开的后台线程，否则在post的线程被唤起。</p><p>在如果不是在Android中，则都在后台线程唤起。</p></li><li><p>ASYNC</p><p>订阅者在新的子线程中运行，独立于UI线程和post线程</p></li></ul><h1 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h1><h2 id="普通事件"><a href="#普通事件" class="headerlink" title="普通事件"></a>普通事件</h2><ol><li><p>定义事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span>(s: String)&#123;</span><br><span class="line">    <span class="keyword">var</span> string : String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        string = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(context)</span><br></pre></td></tr></table></figure></li><li><p>设置订阅者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">      Log.d(<span class="string">"tag"</span>,event.string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发布</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(Event(<span class="string">"hello"</span>))</span><br></pre></td></tr></table></figure></li><li><p>注销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(context)</span><br></pre></td></tr></table></figure></li></ol><h2 id="粘性事件"><a href="#粘性事件" class="headerlink" title="粘性事件"></a>粘性事件</h2><p>粘性事件即事件发生（<code>postSticky()</code>）之后，再订阅，也可对事件进行处理</p><p>发布（<code>postSticky()</code>）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(Event(<span class="string">"粘性事件"</span>))</span><br></pre></td></tr></table></figure><p>订阅者（<code>sticky = true</code>）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true)</span><span class="comment">//sticky默认为false，可以不写</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">"tag"</span>,event.string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上修改<code>发布</code>和<code>订阅者</code> 之后，当<code>postSticky()</code>之后，只有下次<code>注册事件</code>时，<code>订阅者</code>才会对事件进行反应。</p><p>如下代码就只会在点击事件之后，<code>订阅者</code>才会对<code>postSticky()</code>事件做反应</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span>&#123;</span><br><span class="line">    EventBus.getDefault().register(context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">greenrobot/EventBus: Event bus for Android and Java that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality.</a></p><p><a href="http://blog.csdn.net/itachi85/article/details/52205464" target="_blank" rel="noopener">Android事件总线（一）EventBus3.0用法全解析 - CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM类加载机制解析</title>
      <link href="/blog/posts/cf83ef31/"/>
      <url>/blog/posts/cf83ef31/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文介绍了java虚拟机类加载机制。</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>JVM类加载一共7步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的1,2,3步，在实际中有可能从其中间某一步开始。</p><p>类加载机制一般分为三部分：<strong>加载Loading -&gt; 连接Linking -&gt; 初始化Initializing</strong></p><p><img src="https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true" alt="JVM Class Loader"></p><p>其中<strong>加载、验证、准备和初始化</strong>发生的顺序是确定的，但<strong>解析</strong>可以在初始化之后开始（java动态绑定）</p><blockquote><p>java绑定分为静态绑定和动态绑定：</p><ul><li><strong>静态绑定</strong>：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</li><li><strong>动态绑定</strong>：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</li></ul><p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/17881581</a></p></blockquote><h1 id="类加载机制具体过程"><a href="#类加载机制具体过程" class="headerlink" title="类加载机制具体过程"></a>类加载机制具体过程</h1><h2 id="I-Loading"><a href="#I-Loading" class="headerlink" title="I.Loading "></a><strong>I.Loading </strong></h2><p><strong>加载</strong>，JVM将文件（class，jar，zip，网络等）中的二进制字节流保存到虚拟机方法区和堆中,并用该二进制表示形式创建类或者接口的过程。</p><blockquote><p>Loading is the process of finding the binary representation of a class or interface type with a particular name and <em>creating</em> a class or interface from that binary representation</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html</a> (<em>英文文档若无特殊说明都是引用官方文档，下同</em>)</p></blockquote><ol><li>用<strong>类全限定名</strong>获取类的二进制字节流</li><li>将字节流中<strong>静态存储结构</strong>转化为<strong>方法区</strong>的运行时数据结构</li><li><u><em>在<strong>堆</strong>中生成一个代表该类的java.lang.Class对象，作为方法区数据的访问入口。</em></u>（<strong>这句话存疑</strong> ，有人说<a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">在堆中</a> ,也有人说在<a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener">方法区</a> ,官方文档未相关描述）</li></ol><p>类加载的地方是开发人员可控性最强的地方。除了可以使用系统的ClassLoader外还可以自定义ClassLoader（后文详述）。</p><hr><h2 id="II-Linking"><a href="#II-Linking" class="headerlink" title="II.Linking "></a><strong>II.Linking </strong></h2><p><strong>连接</strong>，是将类或者接口组合到java虚拟机运行状态的过程，这样他就可以被运行。</p><blockquote><p>Linking is the process of taking a class or interface and combining(组合) it into the run-time state of the Java Virtual Machine so that it can be executed(运行)</p></blockquote><p>连接一般分为3部分：验证Verification 、准备Preparation 、解析Resolution 。</p><blockquote><p>Linking a class or interface involves(包括) verifying and preparing(验证和准备) that class or interface, its direct(直接) superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.</p></blockquote><h3 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a><strong>Verification</strong></h3><p><strong>验证</strong>，保证class文件中的字节流信息符合虚拟机的要求。</p><blockquote><p>Verification(<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.10" target="_blank" rel="noopener">§4.10</a>) ensures that the binary representation(二进制格式) of a class or interface is structurally correct(结构正确) (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.9" target="_blank" rel="noopener">§4.9</a>). Verification may cause additional classes and interfaces to be loaded (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.3" target="_blank" rel="noopener">§5.3</a>) but need not cause them to be verified or prepared.</p></blockquote><p>验证内容包括：</p><ol><li>文件格式验证，验证字节流符合class文件格式规范；</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation "></a><strong>Preparation </strong></h3><p><strong>准备</strong>，在方法区对类变量分配内存，<strong>初始化为默认值</strong></p><p>比如：<code>static int i = 5；</code>在这一步只会进行到<code>i = 0</code> ，而<code>i = 5</code>要在初始化那一步才进行。</p><blockquote><p><em>Preparation</em> involves creating the static fields for a class or interface and initializing such fields to their default values (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.3" target="_blank" rel="noopener">§2.3</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.4" target="_blank" rel="noopener">§2.4</a>). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">§5.5</a>), not preparation.</p></blockquote><p>准备工作可能在创建之后的任何时候发生，但是必须在初始化之前完成。</p><h3 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a><strong>Resolution</strong></h3><p><strong>解析</strong>，是在运行时常量池中动态确定符号引用的具体值的过程。</p><p>每个栈帧frame都有一个<code>当前方法</code>到<code>运行时常量池</code> 的引用，用来支持方法代码(method code)的<strong>动态链接（dynamic linking）</strong>。</p><p>method code：要被执行的方法以及通过符号引用的变量。</p><blockquote><p>Each frame (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">§2.6</a>) contains a reference to the run-time constant pool (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.5" target="_blank" rel="noopener">§2.5.5</a>) for the type of the current method to support <em>dynamic linking</em> of the method code.</p></blockquote><p>动态链接将符号引用（symbolic references）转化为具体方法的调用（concrete method references），根据需要加载类来解析未定义的符号，将变量访问转化为运行时内存（runtime location）。</p><blockquote><p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.</p><p><em>方法和变量的这种后期绑定,使得方法使用的其他类的更改不太可能破坏这个代码。</em></p></blockquote><p>解析分为：</p><ol><li>类，接口解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><hr><h2 id="III-Initialization"><a href="#III-Initialization" class="headerlink" title="III.Initialization"></a><strong>III.Initialization</strong></h2><p><strong>初始化</strong> ，<em>Initialization</em> of a class or interface consists of executing its class or interface initialization method（执行类，接口的构造方法<code>clinit()</code>）</p><p>类或接口在被初始化之前，必须先被连接linked（ verified, prepared, and optionally（可选） resolved.）。</p><p><code>clinit()</code> ,有<strong>类变量赋值，静态语句块</strong>会由编译器合并为<code>clinit()</code>方法,分为两种：</p><ol><li>类 父类的<code>clinit()</code>方法会先于子类执行</li><li>接口  接口<code>clinit()</code>方法无需调用父类接口的<code>clinit()</code>方法；接口的实现类也无需执行接口的<code>clinit()</code>方法</li></ol><p><code>clinit()</code>和<code>init()</code>不同如下：</p><blockquote><p><strong>init</strong>是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法<u>（是在<strong>new对象</strong>的时候<strong>初始化非静态变量</strong>）</u>；</p><p>而clinit是类构造器方法，也就是在jvm进行类<strong>加载—–验证—-解析—–初始化</strong>，中的初始化阶段jvm会调用clinit方法<u>（是在<strong>JVM初始化类</strong>的时候<strong>初始化静态变量</strong>）</u>。</p><p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener">http://blog.csdn.net/u013309870/article/details/72975536</a></p></blockquote><p><code>clinit()</code>先于<code>init()</code>执行。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener">Java Virtual Machine Specification Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.2" target="_blank" rel="noopener">Chapter 2. The Structure of the Java Virtual Machine</a></p><p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">【深入Java虚拟机】之四：类加载机制</a></p><p><a href="http://blog.csdn.net/zhangliangzi/article/details/51319033" target="_blank" rel="noopener">JVM类加载机制详解（一）JVM类加载过程</a></p><p><a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener">Jvm系列3—类的加载 - Gityuan博客 | 袁辉辉博客  </a></p><p><a href="http://wiki.jikexueyuan.com/project/java-vm/class-loading-mechanism.html" target="_blank" rel="noopener">类加载机制 - 深入理解 Java 虚拟机 - 极客学院Wiki </a></p><p><a href="http://blog.csdn.net/javazejian/article/details/70768369" target="_blank" rel="noopener">深入理解Java类型信息(Class对象)与反射机制 - CSDN博客</a></p><p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener">深入理解jvm–Java中init和clinit区别完全解析 - CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM类加载机制解析</title>
      <link href="/blog/posts/cf83ef31/"/>
      <url>/blog/posts/cf83ef31/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文介绍了java虚拟机类加载机制。</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>JVM类加载一共7步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的1,2,3步，在实际中有可能从其中间某一步开始。</p><p>类加载机制一般分为三部分：<strong>加载Loading -&gt; 连接Linking -&gt; 初始化Initializing</strong></p><p><img src="https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true" alt="JVM Class Loader"></p><p>其中<strong>加载、验证、准备和初始化</strong>发生的顺序是确定的，但<strong>解析</strong>可以在初始化之后开始（java动态绑定）</p><blockquote><p>java绑定分为静态绑定和动态绑定：</p><ul><li><strong>静态绑定</strong>：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</li><li><strong>动态绑定</strong>：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</li></ul><p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/17881581</a></p></blockquote><h1 id="类加载机制具体过程"><a href="#类加载机制具体过程" class="headerlink" title="类加载机制具体过程"></a>类加载机制具体过程</h1><h2 id="I-Loading"><a href="#I-Loading" class="headerlink" title="I.Loading "></a><strong>I.Loading </strong></h2><p><strong>加载</strong>，JVM将文件（class，jar，zip，网络等）中的二进制字节流保存到虚拟机方法区和堆中,并用该二进制表示形式创建类或者接口的过程。</p><blockquote><p>Loading is the process of finding the binary representation of a class or interface type with a particular name and <em>creating</em> a class or interface from that binary representation</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html</a> (<em>英文文档若无特殊说明都是引用官方文档，下同</em>)</p></blockquote><ol><li>用<strong>类全限定名</strong>获取类的二进制字节流</li><li>将字节流中<strong>静态存储结构</strong>转化为<strong>方法区</strong>的运行时数据结构</li><li><u><em>在<strong>堆</strong>中生成一个代表该类的java.lang.Class对象，作为方法区数据的访问入口。</em></u>（<strong>这句话存疑</strong> ，有人说<a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">在堆中</a> ,也有人说在<a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener">方法区</a> ,官方文档未相关描述）</li></ol><p>类加载的地方是开发人员可控性最强的地方。除了可以使用系统的ClassLoader外还可以自定义ClassLoader（后文详述）。</p><hr><h2 id="II-Linking"><a href="#II-Linking" class="headerlink" title="II.Linking "></a><strong>II.Linking </strong></h2><p><strong>连接</strong>，是将类或者接口组合到java虚拟机运行状态的过程，这样他就可以被运行。</p><blockquote><p>Linking is the process of taking a class or interface and combining(组合) it into the run-time state of the Java Virtual Machine so that it can be executed(运行)</p></blockquote><p>连接一般分为3部分：验证Verification 、准备Preparation 、解析Resolution 。</p><blockquote><p>Linking a class or interface involves(包括) verifying and preparing(验证和准备) that class or interface, its direct(直接) superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.</p></blockquote><h3 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a><strong>Verification</strong></h3><p><strong>验证</strong>，保证class文件中的字节流信息符合虚拟机的要求。</p><blockquote><p>Verification(<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.10" target="_blank" rel="noopener">§4.10</a>) ensures that the binary representation(二进制格式) of a class or interface is structurally correct(结构正确) (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.9" target="_blank" rel="noopener">§4.9</a>). Verification may cause additional classes and interfaces to be loaded (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.3" target="_blank" rel="noopener">§5.3</a>) but need not cause them to be verified or prepared.</p></blockquote><p>验证内容包括：</p><ol><li>文件格式验证，验证字节流符合class文件格式规范；</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation "></a><strong>Preparation </strong></h3><p><strong>准备</strong>，在方法区对类变量分配内存，<strong>初始化为默认值</strong></p><p>比如：<code>static int i = 5；</code>在这一步只会进行到<code>i = 0</code> ，而<code>i = 5</code>要在初始化那一步才进行。</p><blockquote><p><em>Preparation</em> involves creating the static fields for a class or interface and initializing such fields to their default values (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.3" target="_blank" rel="noopener">§2.3</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.4" target="_blank" rel="noopener">§2.4</a>). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">§5.5</a>), not preparation.</p></blockquote><p>准备工作可能在创建之后的任何时候发生，但是必须在初始化之前完成。</p><h3 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a><strong>Resolution</strong></h3><p><strong>解析</strong>，是在运行时常量池中动态确定符号引用的具体值的过程。</p><p>每个栈帧frame都有一个<code>当前方法</code>到<code>运行时常量池</code> 的引用，用来支持方法代码(method code)的<strong>动态链接（dynamic linking）</strong>。</p><p>method code：要被执行的方法以及通过符号引用的变量。</p><blockquote><p>Each frame (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">§2.6</a>) contains a reference to the run-time constant pool (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.5" target="_blank" rel="noopener">§2.5.5</a>) for the type of the current method to support <em>dynamic linking</em> of the method code.</p></blockquote><p>动态链接将符号引用（symbolic references）转化为具体方法的调用（concrete method references），根据需要加载类来解析未定义的符号，将变量访问转化为运行时内存（runtime location）。</p><blockquote><p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.</p><p><em>方法和变量的这种后期绑定,使得方法使用的其他类的更改不太可能破坏这个代码。</em></p></blockquote><p>解析分为：</p><ol><li>类，接口解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><hr><h2 id="III-Initialization"><a href="#III-Initialization" class="headerlink" title="III.Initialization"></a><strong>III.Initialization</strong></h2><p><strong>初始化</strong> ，<em>Initialization</em> of a class or interface consists of executing its class or interface initialization method（执行类，接口的构造方法<code>clinit()</code>）</p><p>类或接口在被初始化之前，必须先被连接linked（ verified, prepared, and optionally（可选） resolved.）。</p><p><code>clinit()</code> ,有<strong>类变量赋值，静态语句块</strong>会由编译器合并为<code>clinit()</code>方法,分为两种：</p><ol><li>类 父类的<code>clinit()</code>方法会先于子类执行</li><li>接口  接口<code>clinit()</code>方法无需调用父类接口的<code>clinit()</code>方法；接口的实现类也无需执行接口的<code>clinit()</code>方法</li></ol><p><code>clinit()</code>和<code>init()</code>不同如下：</p><blockquote><p><strong>init</strong>是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法<u>（是在<strong>new对象</strong>的时候<strong>初始化非静态变量</strong>）</u>；</p><p>而clinit是类构造器方法，也就是在jvm进行类<strong>加载—–验证—-解析—–初始化</strong>，中的初始化阶段jvm会调用clinit方法<u>（是在<strong>JVM初始化类</strong>的时候<strong>初始化静态变量</strong>）</u>。</p><p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener">http://blog.csdn.net/u013309870/article/details/72975536</a></p></blockquote><p><code>clinit()</code>先于<code>init()</code>执行。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener">Java Virtual Machine Specification Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.2" target="_blank" rel="noopener">Chapter 2. The Structure of the Java Virtual Machine</a></p><p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">【深入Java虚拟机】之四：类加载机制</a></p><p><a href="http://blog.csdn.net/zhangliangzi/article/details/51319033" target="_blank" rel="noopener">JVM类加载机制详解（一）JVM类加载过程</a></p><p><a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener">Jvm系列3—类的加载 - Gityuan博客 | 袁辉辉博客  </a></p><p><a href="http://wiki.jikexueyuan.com/project/java-vm/class-loading-mechanism.html" target="_blank" rel="noopener">类加载机制 - 深入理解 Java 虚拟机 - 极客学院Wiki </a></p><p><a href="http://blog.csdn.net/javazejian/article/details/70768369" target="_blank" rel="noopener">深入理解Java类型信息(Class对象)与反射机制 - CSDN博客</a></p><p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener">深入理解jvm–Java中init和clinit区别完全解析 - CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM内存知识整理</title>
      <link href="/blog/posts/f31c11c5/"/>
      <url>/blog/posts/f31c11c5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于《深入理解Java虚拟机：JVM高级特性与最佳实践》及部分在线博客整理。</p></blockquote><p>JVM：java virtual machine，一个java程序（进程）拥有一个jvm实例</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>JVM区域总体分两类，heap区和非heap区:</p><p><strong>heap区</strong>：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。<br><strong>非heap区</strong>：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(Java虚拟机栈)、Local Method Statck(本地方 法栈)。</p><h1 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h1><h2 id="1-head"><a href="#1-head" class="headerlink" title="1.head"></a>1.head</h2><p>堆，所有线程共享，存放所有对象实例、数组，GC主要场所，会OOM</p><p>分类</p><p><strong>1.新生代</strong></p><ul><li>eden  刚刚创建的对象优先</li></ul><ul><li>s1  经历几次GC</li></ul><ul><li>s2  经历几次GC</li></ul><p><strong>2.老年代</strong></p><ul><li>存活时间长的老年对象</li></ul><ul><li>大对象，如数组，大String…</li></ul><h2 id="2-stack"><a href="#2-stack" class="headerlink" title="2.stack"></a>2.stack</h2><p>栈，线程私有，存放基本数据和对象的引用，LIFO，会OOM，StackOverflow</p><h3 id="java-virtual-machine-stack"><a href="#java-virtual-machine-stack" class="headerlink" title="java virtual machine stack"></a>java virtual machine stack</h3><p>线程请求的栈深度大于JVM允许的深度会导致Stack Overflow<br>如果虚拟机栈可以动态扩展，但是当拓展时无法申请到足够内存时会导致OutOfMemory</p><p><strong>stack  frame</strong></p><p>stack frame：栈帧，每执行一个方法就会产生一个栈帧并压入栈中</p><ul><li><p>局部变量表</p><ul><li>基本数据类型</li><li>对象引用</li><li>returnAddress 类型,指向了一条字节码指令的位置</li></ul></li><li><p>操作栈</p></li><li>动态链接</li><li>方法出口等…</li></ul><h3 id="native-method-stack"><a href="#native-method-stack" class="headerlink" title="native method stack"></a>native method stack</h3><p>与java虚拟机栈作用类似，不过native method stack是为native方法服务。<br>jvm可以自由实现它，甚至在sun HotSpot VM中将他与虚拟机栈合并<br>会OOM，stackOverflow</p><h2 id="3-method-area"><a href="#3-method-area" class="headerlink" title="3.method area"></a>3.method area</h2><p>方法区，线程共享，存放类信息，常量，静态变量，即时编译器编译后的代码，会OOM</p><p><strong>运行时常量池</strong></p><p>类加载后，编译器生成的各种字面量和符号引用会放到方法区的运行时常量池中<br>String.intern()，有该string对象则返回，无则创建并返回<br>会OOM</p><h2 id="4-program-count"><a href="#4-program-count" class="headerlink" title="4.program count"></a>4.program count</h2><p><strong>程序计数器</strong>，线程私有，占用内存小，当做当前线程执行字节码的行号指示器。</p><p>若执行java方法，计数器记录的是正在执行的虚拟机字节码指令的位置</p><p>若执行的是native方法，则计数器为空undefined。</p><p>此内存区域是唯一一个在java虚拟机规范字没有规定任何OOMError的区域</p><h1 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h1><blockquote><p>以Sun HotSpot VM 为例</p></blockquote><h2 id="1-java堆溢出"><a href="#1-java堆溢出" class="headerlink" title="1.java堆溢出"></a>1.java堆溢出</h2><p>对象过多导致head内存溢出</p><ol><li>是内存泄漏memory leak，定位泄露对象</li><li>是内存溢出memory overflow，检查虚拟机堆参数是否可以调大；去除非必须的生命周期长的对象</li></ol><h2 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.虚拟机栈和本地方法栈溢出"></a>2.虚拟机栈和本地方法栈溢出</h2><ol><li><p>单线程，Stack Overflow</p><p>单线程下，栈帧过大或者虚拟机栈容量太小，当内存无法分配时都会导致Stack Overflow异常</p></li><li><p>多线程，</p><p>多线程时，每个线程栈分配的内存越大，越容易尝试内存溢出OOM</p><p>原因：虚拟机最大内存一定的情况下，去掉共享的Head和MethodArea占的内存，剩下的内存/单个线程最大栈内存=最大线程数量，当单个线程最大栈内存增加时，可以产生的线程数就会越少</p></li></ol><h2 id="3-运行时常量池溢出"><a href="#3-运行时常量池溢出" class="headerlink" title="3.运行时常量池溢出"></a>3.运行时常量池溢出</h2><p>运行时常量池属于方法区，当常量过多时会导致OOM，可以用String.intern()方法尝试</p><h2 id="4-方法区溢出"><a href="#4-方法区溢出" class="headerlink" title="4.方法区溢出"></a>4.方法区溢出</h2><p>经常动态生成大量Class的应用，如Spring等框架，需要注意OOM</p><h2 id="5-本地直接内存溢出"><a href="#5-本地直接内存溢出" class="headerlink" title="5.本地直接内存溢出"></a>5.本地直接内存溢出</h2><p>原生方法直接操作物理内存时导致物理内存不够，产生OOM</p><h1 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h1><p>JVM中GC会根据不同情况采取以下一系列算法组合进行内存回收</p><h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1.复制算法"></a>1.复制算法</h3><p><strong>原理</strong>：内存一分为二，只使用一半；GC时将存活对象复制到另一半内存，剩下的则清空</p><p><strong>优缺点</strong>：1.无STW，但不适合对象过多的情况；2.内存利用效率低</p><h3 id="2-标记清除法"><a href="#2-标记清除法" class="headerlink" title="2.标记清除法"></a>2.标记清除法</h3><p><strong>原理</strong>：从GC Roots开始遍历，可达标记存活，不可达则未标记</p><p>java中，GC Roots可以是以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul><p><strong>优缺点</strong>：1.要StopTheWorld防止标记的时候新new的对象未被标记而出错；</p><p>2.清除对象后内存不连续，会有一定的浪费</p><h3 id="3-标记压缩法"><a href="#3-标记压缩法" class="headerlink" title="3.标记压缩法"></a>3.标记压缩法</h3><p><strong>原理</strong>：类似【标记清除法】，但会对标记进行压缩，如a-&gt;b-&gt;c，会被压缩为a-&gt;c，具体试讲所有存活的对象都向一端移动，直接清理掉端边界外的内存</p><p><strong>优缺点</strong>：1.也要StopTheWorld</p><h3 id="4-引用计数算法"><a href="#4-引用计数算法" class="headerlink" title="4.引用计数算法"></a>4.引用计数算法</h3><p><strong>原理</strong>：引用+1，不引用-1，为0则删除，但是会有相互循环引用的问题，java未使用</p><p><strong>优缺点</strong>：相互循环使用：<br>a = b<br>b = a<br>除此之外再没有用到a，b的地方，但是由于a，b的引用不为0所以无法被回收，导致内存浪费</p><h2 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h2><p>一个不可达对象在“死缓”到“执行死刑”前至少经历两个标记过程</p><ol><li><p>第一次标记，筛选：是否有必要执行finalize()方法，若是则放到F-Queue队列中【触发】该方法，但不保证执行完该方法。</p><p>可以在finlize()方法中<strong>自救一次</strong>：在该方法中将<em>自身this</em>赋值给其他变量，这样在第二次标记时会被移出<em>即将回收</em>集合；但是由于finlize()方法只会被调用一次，所以只能自救一次。并<em>不推荐该方法</em>，该方法所有可以做的工作，可以用<strong>try…finally</strong>或者其他方法更好的实现</p></li><li><p>第二次标记，若finalize()方法以及调用过，或者为重写该方法，则“没必要执行”，可以回收</p></li></ol><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><h3 id="强引用StrongReference"><a href="#强引用StrongReference" class="headerlink" title="强引用StrongReference"></a>强引用StrongReference</h3><p>People p = new People();哪怕抛出OOM也不会被GC回收的对象</p><h3 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h3><p>SoftReference sf = new SoftReference(p);只要有足够内存就不会被GC回收，若内存不够则会被GC回收，常用作服务器缓存</p><h3 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a>弱引用WeakReference</h3><p>在下次GC回收之前都存在，用作android等内存紧张的设备中的缓存</p><h3 id="虚引用PhantomReference"><a href="#虚引用PhantomReference" class="headerlink" title="虚引用PhantomReference"></a>虚引用PhantomReference</h3><p>无法影响其生存时间，也无法通过虚引用获取其实例，设置虚引用只是为了在对象被GC回收时获取系统通知</p><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/JVMMemory.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android系统架构简介</title>
      <link href="/blog/posts/e3bb9a54/"/>
      <url>/blog/posts/e3bb9a54/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说明：本文基于<a href="http://gityuan.com/android/" target="_blank" rel="noopener">Android系统开篇 - Gityuan博客 | 袁辉辉博客 </a> 的学习笔记整理</p></blockquote><p>Android系统大体分为4个模块，从底层开始依次是1.linux内核、2.系统库+Android运行时、3.框架层、4.应用层。</p><p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/AndroidSystemArchitecture.png" alt=""></p><p>下图描述了Android系统从开机到Apk运行的整个流程。</p><p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/androidBoot.jpg" alt="系统启动框架图，来自gityuan.com"></p><p>流程如下：<code>Loader</code> -&gt; <code>Kernel</code> -&gt; <code>Native</code>-&gt; <code>Framework</code> -&gt; <code>App</code></p><p><strong>Loader层</strong></p><ol><li>Boot ROM ：开机时，引导芯片从ROM读取读取初始化代码，加载引导程序到RAM中。</li><li>Boot Loader：是启动Android系统之前的引导程序，检查RAM、初始化硬件参数等。</li></ol><p><strong>Kernel层</strong>（即Android内核层，进入Android系统）</p><ol><li>swapper进程（pid=0）：Boot Loader启动swapper（idle）进程，是由内核创建的第一个进程，用来初始化进程管理、内存管理、驱动等等。</li><li>kthreadd进程（pid=2）：是Linux系统的内核进程，<strong>是所有内核进程的鼻祖</strong>。</li></ol><hr><p><strong>Syscall</strong>，在Native和Kernel之间的系统调用层。</p><hr><p><strong>Native层</strong></p><ol><li>init进程（pid=1）：由swapper进程创建，<strong>是所有用户进程鼻祖</strong></li><li>init进程孵化出用户守护进程、启动ServiceManager管理系统服务，启动开机动画Bootnaim。</li></ol><hr><p><strong>JNI</strong>，Java层和Native（C/C++）层之间。</p><hr><p><strong>Framework层</strong></p><ol><li>Zygote进程：由init进程fork生成，是<strong>Android系统第一个java进程，是所有java进程的父进程</strong></li><li>SystemServer进程：由Zygote进程fork而来，<strong>是Zygote孵化的第一个进程</strong>，负责启动和管理整个<strong>java framework</strong>，如ActivityManager、PowerManager…</li><li>MediaServer进程：由init进程fork而来，负责启动和管理整个<strong>C++ framework</strong></li></ol><p><strong>APP层</strong></p><ol><li>Launcher：<strong>Zygote进程孵化的第一个App进程</strong>，桌面App。</li><li>其他由Zygote进程孵化的系统进程（Browser、Phone…）和非系统app进程。</li></ol><p>扼要内容如图：</p><p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/AndroidBootImg.png" alt="系统启动示意图"></p><p>Android常用的通信方式</p><ol><li>Binder</li><li>Socket</li><li>Handler</li></ol><p><strong>Binder/Socket用于进程间（都具有独立的地址空间）通信，而Handler消息机制用于同进程的线程间（共享内存空间）通信</strong></p><p>在Android系统中：</p><ul><li>Zygote进程  –&gt;  Socket机制</li><li>SystemServer、MediaServer、App之间  –&gt;  Binder IPC</li><li>同一进程不同线程间 –&gt;  Handler</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android阅读笔记</title>
      <link href="/blog/posts/aacd75ab/"/>
      <url>/blog/posts/aacd75ab/</url>
      
        <content type="html"><![CDATA[<h2 id="layout-weight"><a href="#layout-weight" class="headerlink" title="layout_weight"></a>layout_weight</h2><p>layout_weight 重要性，默认的是0,0等级最高，要显示，数字越大重要性越低。</p><p>例：a，b的宽度为0，layout_weight分别为1、2，则a，b宽度分别为父容器的2/3、1/3。</p><h2 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h2><p>PendingIntent是封装后的intent，有intent执行所需的context，所以即使要执行intent的activity已经消失或者还没生成，其他activity依然可以通过PendingIntent执行intent。</p><blockquote><p>PendingIntent is a description of an Intent and target action to perform with it. Instances of this class are created with <code>getActivity(Context, int, Intent, int)</code>, <code>getActivities(Context, int, Intent[], int)</code>, <code>getBroadcast(Context, int, Intent, int)</code>, and <code>getService(Context, int, Intent, int)</code>; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.</p></blockquote><p>也就是把自己要执行的intent和执行所需的context封装后给别人，请别人在适当的时候执行。</p><h2 id="android模拟器访问电脑localhost"><a href="#android模拟器访问电脑localhost" class="headerlink" title="android模拟器访问电脑localhost"></a>android模拟器访问电脑localhost</h2><p>电脑<code>localhost</code>或者<code>127.0.0.1</code>访问本地网址。</p><p>模拟器访问<code>localhost</code>会默认访问手机的本地网址，要访问电脑的本地网址则需要访问<code>10.0.2.2:8080</code>，记得加上对应的端口。</p><h2 id="获取屏幕画面"><a href="#获取屏幕画面" class="headerlink" title="获取屏幕画面"></a>获取屏幕画面</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">View decor = MainActivity.<span class="keyword">this</span>.getWindow().getDecorView();</span><br><span class="line">decor.setDrawingCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">imageView.setImageBitmap(decor.getDrawingCache());</span><br></pre></td></tr></table></figure><h2 id="获取网络信息，请求网络"><a href="#获取网络信息，请求网络" class="headerlink" title="获取网络信息，请求网络"></a>获取网络信息，请求网络</h2><p>需要请求权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">chackNetWork</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isNetAvailable = <span class="keyword">false</span>;</span><br><span class="line">    ConnectivityManager manager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (manager.getActiveNetworkInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        isNetAvailable = manager.getActiveNetworkInfo().isAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isNetAvailable) &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"open network"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setAction(Settings.ACTION_NETWORK_OPERATOR_SETTINGS);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android实现可折叠toolbar</title>
      <link href="/blog/posts/b4832cd1/"/>
      <url>/blog/posts/b4832cd1/</url>
      
        <content type="html"><![CDATA[<p>使用到的类有：</p><ul><li>android.support.design.widget.CoordinatorLayout</li><li>android.support.design.widget.AppBarLayout</li><li>android.support.design.widget.CollapsingToolbarLayout</li><li>android.support.v7.widget.Toolbar</li></ul><h1 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h1><p>如图：</p><p><img src="http://jixiaoyong.github.io/blog/images/default/2018-02-22/coordinatorlayout.gif" alt=""></p><h1 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h1><p>CoordinatorLayout类，协调者布局，通过Behavior将一个子view（<code>child</code>）的行为和另一个子view（<code>dependency</code>）的活动联结起来，从而实现子view之间的联动。</p><p>AppBarLayout类，是一个实现了材料设计的默认垂直布局的ViewGroup，当其是CoordinatorLayout类的直接子view时,另外一个CoordinatorLayout的子view指定了behavior为AppBarLayout.ScrollingViewBehavior的实例（<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>）,且该子view需要是NestedScrollingChild的实现类。</p><p>CollapsingToolbarLayout类，提供一个可以折叠的toolbar布局，可以在这个布局里面，设置toolbar以及和toolbar一起联动的子view，本案例中是一张图片。</p><p>Toolbar类，实现toolbar的效果。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>源码：<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-02-22" target="_blank" rel="noopener">github</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">              <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">app:layout_collapseMode</span>=<span class="string">"parallax"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">app:layout_collapseMode</span>=<span class="string">"pin"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>CoordinatorLayout在最外层，注意其直接子view必须就是要实现联动的view，否则联动失效。</li><li>CollapsingToolbarLayout必须设置layout_scrollFlags，其余属性可选。</li></ol><blockquote><p>layout_scrollFlags说明如下：</p><p><strong>scroll</strong>：所有想滚动出屏幕的view都需要设置这个flag， 没有设置这个flag的view将被固定在屏幕顶部。</p><p><strong>enterAlways</strong>：这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。</p><p><strong>enterAlwaysCollapsed</strong>：假设你定义了一个最小高度（minHeight）同时enterAlways也定义了，那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。</p><p><strong>exitUntilCollapsed</strong>：当你定义了一个minHeight，此布局将在滚动到达这个最小高度的时候折叠。</p><p><strong>snap</strong>：当一个滚动事件结束，如果视图是部分可见的，那么它将被滚动到收缩或展开。例如，如果视图只有底部25%显示，它将折叠。相反，如果它的底部75%可见，那么它将完全展开。</p><p>作者：尹star</p><p>链接：<a href="https://www.jianshu.com/p/5287d090e777" target="_blank" rel="noopener">https://www.jianshu.com/p/5287d090e777</a></p></blockquote><ol><li>CollapsingToolbarLayout的子view需要指定layout_collapseMode，还有一点需注意：<strong>和toolbar联动的子view高度需大于toolbar高度，否则无效果。</strong></li><li>ViewPager就是本案例中触发子view联动效果的<code>dependency</code>，需要指定其behavior：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_behavior="@string/appbar_scrolling_view_behavior"</span><br></pre></td></tr></table></figure><p>其实际对应于android.support.design.widget.AppBarLayout$ScrollingViewBehavior ，这个是系统实现的一个behavior，用于和嵌套滑动事件绑定，<strong>指定该behavior的子view需要是NestedScrollingChild的实现类</strong>（系统提供了4个实现类：NavigationMenuView、NestedScrollView、RecyclerView、SwipleRefreshLayout），所以viewPager中页面有上述4个类或其子类时，才能实现绑定效果。</p><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p><strong>自定义Behavior</strong></p><p>自定义Behavior有两个目的：</p><ol><li>将两个或多个子view绑定；</li><li>将一个子view与另一个子view的滑动事件绑定在一起</li></ol><p>两者的差异在于在实现<code>CoordinatorLayout.Behavior&lt;T&gt;</code> 类时候具体重写的方法不一样。</p><p><strong>目的1</strong>：需要重写的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, T child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果dependency是要依赖的子view（此处是TempView类）的实例，说明它就是我们所需要的Dependency</span></span><br><span class="line">    <span class="keyword">return</span> dependency <span class="keyword">instanceof</span> TempView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次dependency位置发生变化，都会执行onDependentViewChanged方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, T child, View dependency)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据dependency的位置，设置child的位置,对child进行想要实现的变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//返回true表示改变了child 的尺寸和位置参数，否则返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>目的2</strong>：需要重写的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否要开始根据dependency子view的行为改变child的状态</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(@NonNull CoordinatorLayout coordinatorLayout, @NonNull ImageView child,@NonNull View directTargetChild, @NonNull View target, <span class="keyword">int</span> axes, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child <span class="keyword">instanceof</span> ImageView &amp;&amp; axes == View.SCROLL_AXIS_VERTICAL;<span class="comment">//子view是ImageView，并且滑动的方向是垂直的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当dependency子view滑动时，对child进行相应处理</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(@NonNull CoordinatorLayout coordinatorLayout, @NonNull ImageView child, @NonNull View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @NonNull <span class="keyword">int</span>[] consumed, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="自定义-Behavior-的总结"><a href="#自定义-Behavior-的总结" class="headerlink" title="自定义 Behavior 的总结"></a>自定义 Behavior 的总结</h1><ol><li>确定 CoordinatorLayout 中 View 与 View 之间的依赖关系，通过 layoutDependsOn() 方法，返回值为 true 则依赖，否则不依赖。</li><li>当一个被依赖项 dependency 尺寸或者位置发生变化时，依赖方会通过 Byhavior 获取到，然后在 onDependentViewChanged 中处理。如果在这个方法中 child 尺寸或者位置发生了变化，则需要 return true。</li><li>当 Behavior 中的 View 准备响应嵌套滑动时，它不需要通过 layoutDependsOn() 来进行依赖绑定。只需要在 onStartNestedScroll() 方法中通过返回值告知 ViewParent，它是否对嵌套滑动感兴趣。返回值为 true 时，后续的滑动事件才能被响应。</li><li>嵌套滑动包括滑动(scroll) 和 快速滑动(fling) 两种情况。开发者根据实际情况运用就好了。</li><li>Behavior 通过 3 种方式绑定：1. xml 布局文件。2. 代码设置 layoutparam。3. 自定义 View 的注解。</li></ol><p>来源 ：<a href="http://blog.csdn.net/briblue/article/details/73076458" target="_blank" rel="noopener">针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN博客</a></p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://blog.csdn.net/briblue/article/details/73076458" target="_blank" rel="noopener">针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN博客</a>  </li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0824/6565.html" target="_blank" rel="noopener">CoordinatorLayout 自定义Behavior并不难，由简到难手把手带你撸三款！ - 泡在网上的日子</a></li><li><a href="https://www.jianshu.com/p/8c92d0a1e591" target="_blank" rel="noopener">一步一步深入理解CoordinatorLayout - 简书</a></li><li><a href="https://www.jianshu.com/p/5287d090e777" target="_blank" rel="noopener">使用CoordinatorLayout打造一个炫酷的详情页 - 简书</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android自定义view的一些知识点</title>
      <link href="/blog/posts/e41787ec/"/>
      <url>/blog/posts/e41787ec/</url>
      
        <content type="html"><![CDATA[<h1 id="绘制两个图形重叠部分"><a href="#绘制两个图形重叠部分" class="headerlink" title="绘制两个图形重叠部分"></a>绘制两个图形重叠部分</h1><p>android自定义view时两个图形重叠部分的绘制方式,一定要调用<code>canvas.saveLayer()</code> ，否则不生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个步骤十分重要，将当前画布保存为新的一层</span></span><br><span class="line"><span class="keyword">int</span> save = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,mWidth,mHeight,<span class="keyword">null</span>,Canvas.ALL_SAVE_FLAG);</span><br><span class="line"></span><br><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">paint.setColor(mBackgroundColor);</span><br><span class="line"></span><br><span class="line">RectF backgroundRectF = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight);</span><br><span class="line">canvas.drawRoundRect(backgroundRectF, mRadius, mRadius, paint);</span><br><span class="line"></span><br><span class="line">paint.setColor(mForwardColor);</span><br><span class="line"><span class="comment">//设置二者重叠部分的绘制方式</span></span><br><span class="line">paint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</span><br><span class="line">RectF progressRectF = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, mWidth * mProgress, mHeight);</span><br><span class="line">canvas.drawRect(progressRectF,paint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//restore to canvas</span></span><br><span class="line">canvas.restoreToCount(save);</span><br></pre></td></tr></table></figure><p><code>paint.setXfermode()</code>可以设置的值参考下图：</p><p><img src="http://jixiaoyong.github.io/blog/images/default/2018-02-19/PorterDuffMode.png" alt=""></p><p>参考自<a href="https://www.cnblogs.com/DarkMaster/p/4618872.html" target="_blank" rel="noopener">【原】使用Xfermode正确的绘制出遮罩效果 - sky0014 - 博客园  </a></p><h1 id="适配自定义view宽高，设置默认值"><a href="#适配自定义view宽高，设置默认值" class="headerlink" title="适配自定义view宽高，设置默认值"></a>适配自定义view宽高，设置默认值</h1><p>以其宽度为例，在<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">    mWidth = widthSize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mWidth = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        mWidth = Math.min(mWidth, widthSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java创建线程安全的单例Singleton</title>
      <link href="/blog/posts/36721083/"/>
      <url>/blog/posts/36721083/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在编码中常常会用到单例，来确保类有一个唯一的对象，一般情况下将构造方法私有化既可以实现，但当考虑到多线程时事情会变得有些复杂，本文讨论的正是几种多线程的情况下实现单例的方法。</p><h1 id="1-普通单例"><a href="#1-普通单例" class="headerlink" title="1.普通单例"></a>1.普通单例</h1><p>私有化构造方法，对外提供一个公有、静态的方法，在其内部判断类对象是否已经存在，否的话生成类对象再返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASingleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ASingleton as;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ASinleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"ASingleton init!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(as == <span class="keyword">null</span>) &#123;              <span class="comment">//tag1</span></span><br><span class="line">as = <span class="keyword">new</span> ASingleton();    <span class="comment">//tag2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在考虑多线程时，由于java代码是一行行进行的，假设有两个线程t1、t2，当as为null的时候t1执行到tag1位置，判断为true，于是准备执行tag2，就在此时，cup调度t2开始执行tag1，此时t1尚未执行tag2，所以在t2中tag1判断为true,t2也开始执行tag2生成一个新对象,这样当t1再次执行tag2时就会再生成一个新对象，这样就同时存在多个类的对象。</p><h1 id="2-同步锁"><a href="#2-同步锁" class="headerlink" title="2.同步锁"></a>2.同步锁</h1><p>对上面的代码稍作优化,可以看到使用了synchronized，对判断是否需要初始化进行了同步锁，这样当线程t1访问时，语句被锁定，t2运行到这里时，只能等t1运行完这段语句并释放之后，才能继续访问，此时as已经被赋予了对象，所以不会再继续新建，这样就保证了单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ASingleton as;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ASinleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"ASingleton init!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ASingleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (as == <span class="keyword">null</span>) &#123;</span><br><span class="line">as = <span class="keyword">new</span> ASingleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样也存在一个问题，每个线程每次获取单例都要进入同步锁，这样累计下来必然影响效率。</p><h1 id="3-双重检查锁定"><a href="#3-双重检查锁定" class="headerlink" title="3.双重检查锁定"></a>3.双重检查锁定</h1><p>那么在判断as为null后，对as的初始化进行同步锁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (as == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ASingleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (as == <span class="keyword">null</span>) &#123;           <span class="comment">//tag1</span></span><br><span class="line">as = <span class="keyword">new</span> ASingleton();  <span class="comment">//tag2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，当判断as为null时，才会进行初始化，同时由于初始化过程加锁，所以t1和t2无法同时访问初始化语句tag2，也保证了只能创建一个单例。</p><p>看起来很完美，但是由于java语言的特性，在该段代码编译为汇编语言时，上述方法会被编译为类似下面的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>判断as是否为null</span><br><span class="line"><span class="number">2.</span>令as = ASingleton() <span class="comment">//注意此时只是为as分配了内存，并未执行ASingleton的构造方法</span></span><br><span class="line"><span class="number">3.</span>开始执行ASingleton构造方法，as有了初始化的值</span><br><span class="line"><span class="number">4.</span>返回as</span><br></pre></td></tr></table></figure><p>那么，当t1执行到语句2，而t2开始执行语句1时，此时由于as已经分配了内存不为null，所以t2直接执行语句4，此时t2获取到的是一个没有执行构造方法的ASingleton对象，显然这样十分危险。在线程复杂的情况下很容易出现问题。</p><p>下面提供了两个结局思路，为简便起见，将其简单分为“饿汉模式”和“懒汉模式”（其实上述方法也可分为这两个模式，but，who cares…）。</p><h1 id="4-饿汉模式实现单例"><a href="#4-饿汉模式实现单例" class="headerlink" title="4.饿汉模式实现单例"></a>4.饿汉模式实现单例</h1><p>饿汉模式，即在声明的时候就将对象初始化。</p><p>这样实现单例的原理是类的静态变量全局唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ASingleton as = <span class="keyword">new</span> ASingleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ASinleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"ASingleton init!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样仍然有个问题，可能在用到ASingleton类的时候，并不需要立即获取到其单例，在这种情况下，饿汉模式仍然有浪费资源的嫌疑。</p><h1 id="5-懒汉模式实现单例"><a href="#5-懒汉模式实现单例" class="headerlink" title="5.懒汉模式实现单例"></a>5.懒汉模式实现单例</h1><p>懒汉模式，只有要用到该实例时，才获取该单例。</p><p>这次我们用到的时静态内部类，静态内部类与类的静态变量不同，只有明确调用静态内部类的时候才会初始化静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASingletonFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ASingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton as = <span class="keyword">new</span> ASingleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ASinleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"ASingleton init!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ASingleton.as;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，至此已经完成了java实现单例的绝大部分方法，但其实还有一张更加简洁的方法，那就是用enmu实现。</p><h1 id="6-enmu实现单例"><a href="#6-enmu实现单例" class="headerlink" title="6.enmu实现单例"></a>6.enmu实现单例</h1><p>由于枚举类型的对象是唯一的，所以是实现单例的较优选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> SingletonEnum&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，android开发者要注意，枚举占用的内存是普通单例的两倍多，所以，并不推荐在android中使用。</p><p>关于枚举的更详细资料，参阅(深入理解Java枚举类型(enum))[<a href="http://blog.csdn.net/javazejian/article/details/71333103#t7]" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/71333103#t7]</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin学习笔记2</title>
      <link href="/blog/posts/8a52763a/"/>
      <url>/blog/posts/8a52763a/</url>
      
        <content type="html"><![CDATA[<ul><li><p>尾递归优化</p><p>把递归通过编译器转化为迭代，从而避免Stack Overflow</p><p>“以时间换取空间”</p><p>普通递归：</p><p>调用函数之后，还需要使用其返回值供自己使用，即自身返回值依赖于下一级函数，一般是调用自身的代码后面，还有其他的代码要执行。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(n: <span class="type">Int</span>)</span></span>: BigInteger &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> BigInteger.valueOf(<span class="number">1L</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n.toBigInteger().times(fun1(n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    尾递归：</p><p>​    调用自身之后，无需再返回当前函数,将处理结果以其他形式返回。</p><p>​    普通递归和尾递归都存在栈溢出风险（未优化前，例子中的函数计算10000到100000的阶乘时会溢出），kotlin提供了一种尾递归优化的方法——<code>tailrec</code>，使得编译器在编译时将递归转化为迭代，从而避免栈溢出。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>(<span class="keyword">var</span> value: BigInteger = BigInteger.valueOf(<span class="number">1L</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾递归，tailrec为kotlin中优化关键字</span></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">(n: <span class="type">Int</span>, m: <span class="type">Result</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        m.value = m.value.times(BigInteger.valueOf(<span class="number">1L</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m.value = m.value.times(n.toBigInteger())</span><br><span class="line">        fun2(n-<span class="number">1</span>,m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    本例中传入<code>fun2()</code>的<code>Result</code>实例保存了计算结果</p><ul><li><p>sealed class 密封类</p><p>密封类的所有子类必须在一个文件(xx.kt)中，他的子类是有限的，所以当<code>when()</code>的时候不需要<code>else</code>。</p><p>某种意义上他们像是一种<code>enum class</code>，只不过他的子类可以有多个实例。</p><blockquote><p>Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.</p></blockquote></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sealed class</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Play</span></span>(<span class="keyword">var</span> arg:String) : Player()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> Stop : Player()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">p2</span></span>():Player()</span><br></pre></td></tr></table></figure><ul><li>kotlin抛出异常</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getBookList</span><span class="params">()</span></span>:List&lt;Book&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin学习笔记1</title>
      <link href="/blog/posts/135b2780/"/>
      <url>/blog/posts/135b2780/</url>
      
        <content type="html"><![CDATA[<p>这是我在学习Bennyhuo（ <a href="https://github.com/enbandari/Kotlin-Tutorials" target="_blank" rel="noopener">github</a> ）的kotlin入门视频时的一些笔记，比较偏基础，用于查缺补漏。</p><ul><li><p>xx.map() &amp; xx.flatMap()</p><p>xx.flatMap()用于返回<strong>可迭代</strong>的数组，而xx.map()则是任何<strong>可迭代</strong>数据都有的用来遍历的方法。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = arrayListOf&lt;String&gt;(<span class="string">"a c v de  fb s e  gf d"</span>)</span><br><span class="line">arr.flatMap &#123;</span><br><span class="line">    it.split(<span class="string">" "</span>)</span><br><span class="line">&#125;.map&#123; </span><br><span class="line">    print(<span class="string">"<span class="subst">$&#123;it.toUpperCase()&#125;</span>"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>enum class 枚举类型</p><p>分为有参和无参，枚举变量以<code>,</code>分隔，如果enum还有方法或者伴生对象，则最后一个变量后为<code>;</code>，否则可为<code>,</code>、<code>;</code>或者没有。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    UK,USA,EU;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下为非必须代码，仅表示可以有这些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(s:<span class="type">String</span>)</span></span>:City&#123;</span><br><span class="line">            <span class="keyword">return</span> valueOf(s.toUpperCase())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        有参的情况如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span></span>(<span class="keyword">val</span> aName:String)&#123;</span><br><span class="line">    CHINA(<span class="string">"中国"</span>),</span><br><span class="line">    JAPAN(<span class="string">"日本"</span>),</span><br><span class="line">    USA(<span class="string">"美国"</span>),</span><br><span class="line">    UK(<span class="string">"英国"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        使用：通过enum的valueOf()方法获取枚举对象实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;uk&quot;</span><br><span class="line">var city = City.valueOf(s.toUpperCase())</span><br><span class="line">//或者通过伴生对象：</span><br><span class="line">var city = City.fun1(s)</span><br></pre></td></tr></table></figure><ul><li><p>companion object伴生对象</p><p>在类的定义，可以直接用<code>类名.方法名()</code>调用，相当于java中的静态方法</p><p>一个类中只能有一个伴生对象</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxx</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">(x: <span class="type">String</span>)</span></span>: Country &#123;</span><br><span class="line">            <span class="keyword">return</span> valueOf(x.toUpperCase())</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>object修饰的类</p><p>等同于只有一个实例的类，相当于java中的静态类，所有方法可以直接用类名调用</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ClassName&#123;</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>fun ClassName.funName()为类添加新的方法</p><p>对于不能直接修改的类，有需要对其增加一个方法，可以自定义一个<code>ClassName.funName()</code>的方法来达到这个目的。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Country.<span class="title">sayNum</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this引用的是country对象</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        CHINA -&gt; <span class="number">1</span></span><br><span class="line">        JAPAN -&gt; <span class="number">2</span></span><br><span class="line">        USA -&gt; <span class="number">3</span></span><br><span class="line">        UK -&gt; <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在使用时可以通过<code>Country</code>的对象调用<code>syaNum()</code>方法</p><ul><li><p>data class 数据类</p><p>可以有方法，方便复制。</p><p>必须至少有一个参数，并且参数都需要用var/val修饰</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">dataClass</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">val</span> age :<span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><ul><li>文件读取<ul><li>resource目录下的文件读取</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = File(ClassLoader.getSystemResource(<span class="string">"input"</span>).path).readText()</span><br></pre></td></tr></table></figure><ul><li><p>与RxJava结合</p><p>统计文本中字母个数，基于RxJava 1.2.1</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(input.toCharArray().asIterable())</span><br><span class="line">        .filter &#123; !it.isWhitespace() &#125;</span><br><span class="line">        .groupBy &#123; it &#125;</span><br><span class="line">        .map&#123;</span><br><span class="line">            o -&gt;o.count().subscribe&#123;</span><br><span class="line">                print(<span class="string">"<span class="subst">$&#123;o.key&#125;</span>-&gt; <span class="variable">$it</span>  ,"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>lambda表达式在kotlin中的应用</title>
      <link href="/blog/posts/53875104/"/>
      <url>/blog/posts/53875104/</url>
      
        <content type="html"><![CDATA[<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p><strong>普通写法</strong>：</p><ol><li>定义一个接口OnClickListener</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义方法SetOnClickListener</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnCLickListener</span><span class="params">(listener: <span class="type">ClickListener</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的方法和Java中写法类似，在使用该方法时也类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testInterface = TestInterface()</span><br><span class="line"></span><br><span class="line">testInterface.setOnCLickListener(<span class="keyword">object</span> : TestInterface.ClickListener&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">            TODO(<span class="string">"not implemented"</span>) <span class="comment">//To change body of created functions use File | Settings | File Templates.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><strong>lambda写法</strong>：</p><p>定义只需要一步：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在初始化的时初始化listener</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span></span>(<span class="keyword">var</span> listener : (uri:String) -&gt; <span class="built_in">Unit</span>)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者直接定义这个变量</span></span><br><span class="line">listener:((uri : String)-&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在需要用到方法时，listener的方法，比如onClickListener()&#123;&#125;</span></span><br><span class="line">listener.invoke(agrs)</span><br></pre></td></tr></table></figure><p>使用起来也更加简洁：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = TestInterface&#123; uri: String -&gt; print(uri) &#125;<span class="comment">//获取对象的同时初始化listener</span></span><br></pre></td></tr></table></figure><blockquote><p>方法最后一个参数是lambda表达式时，lambda表达式的方法<code>{}</code>可以放到<code>()</code>的后面，如果只有这一个参数时，<code>()</code>也可以省略</p></blockquote><p>当方法只有一个参数时，可以省略参数，还用<code>it</code>代替：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testInterface.setNewOnClickListener &#123; print(it) &#125;</span><br></pre></td></tr></table></figure><p>甚至更加简洁，如果要执行的方法和listener定义的方法返回值类型相同，可以直接引用该方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testInterface.setNewOnClickListener(::print)</span><br></pre></td></tr></table></figure><h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><p>lambda在Java8中引进，可以很好的替代匿名内部类，使代码更加简洁。</p><p>lambda表达式形式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br></pre></td></tr></table></figure><blockquote><p>lambda 表达式总是被大括号括着， 完整语法形式的参数声明放在大括号内，并有可选的类型标注， 函数体跟在一个 <code>-&gt;</code> 符号之后。如果推断出的该 lambda 的返回类型不是 <code>Unit</code>，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。</p><p>kotlincn.net <a href="http://www.kotlincn.net/docs/reference/lambdas.html#高阶函数和-lambda-表达式" target="_blank" rel="noopener">高阶函数和lambda表达式</a></p></blockquote><p>使用lambda的形式如下<code>() -&gt; {}</code>,<code>()</code>内是参数，<code>{}</code>是函数具体的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java 8方式：</span></span><br><span class="line"><span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">"In Java8, Lambda expression rocks !!"</span>) ).start();</span><br></pre></td></tr></table></figure><p>这个例子来自importNew.com,<a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">Java8 lambda表达式10个示例</a></p><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><ul><li>xx.map()</li></ul><p>凡是<strong>可迭代</strong>的数据都可以使用<code>map()</code>函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args: Array&lt;String&gt; = arrayOf()</span><br><span class="line">args.map &#123;</span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以更简洁：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args.map(::print)</span><br><span class="line"><span class="comment">//::print表示引用该方法</span></span><br></pre></td></tr></table></figure><ul><li>xx.flatMap()</li></ul><p>返回<strong>可迭代</strong>的数组，可以和<code>xx.map()</code>一起使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">args.flatMap &#123;</span><br><span class="line">    it.split(<span class="string">" "</span>) <span class="comment">//把字符串按照" "切割</span></span><br><span class="line">&#125;.map&#123; </span><br><span class="line">    print(<span class="string">"<span class="subst">$&#123;it.toUpperCase()&#125;</span>"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android中WebView使用的一些问题</title>
      <link href="/blog/posts/b35fe0f7/"/>
      <url>/blog/posts/b35fe0f7/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述：WebView在fragment中不显示"><a href="#问题描述：WebView在fragment中不显示" class="headerlink" title="问题描述：WebView在fragment中不显示"></a>问题描述：WebView在fragment中不显示</h1><p>解决代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin 代码</span></span><br><span class="line">webView.webViewClient = <span class="keyword">object</span> : WebViewClient() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(view: <span class="type">WebView</span>?, url: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">                view!!.loadUrl(url)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此代码同样强制在webview中打开对应的网页</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python自动创建发布hexo文章并同步github</title>
      <link href="/blog/posts/d9a2e1ba/"/>
      <url>/blog/posts/d9a2e1ba/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>环境 linux(deepin)</p><p>python 2.7</p></blockquote><p>这是一个Python脚本，用于实现hexo文章创建、生成网页并预览、发布到对应xxx.github.io博客的全过程。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="使用时需要根据自己的项目更新main-py的一下变量："><a href="#使用时需要根据自己的项目更新main-py的一下变量：" class="headerlink" title="使用时需要根据自己的项目更新main.py的一下变量："></a>使用时需要根据自己的项目更新main.py的一下变量：</h2><ul><li><p>hexo_url = ‘your_path/hexo/blog’</p><p>【必需】本地hexo博客路径</p></li><li><p>hexo_public_dir = ‘your_path/hexo/blog/public’</p><p>【必需】本地hexo博客输出路径</p></li><li><p>hexo_post_dir = ‘your_path/hexo/blog/source/_posts’</p><p>【可选】本地hexo博客文章源文件路径</p></li><li><p>git_dir = ‘your_path/xxx.github.io’</p><p>【必需】博客要同步的git工程路径</p></li><li><p>git_backup_dir = ‘your_path/xxx.github.io/blog/backup/sources/_posts’</p><p>【可选】本路径用于备份post源文件到github</p></li><li><p>hexo.py 中的<code>post()</code>方法中<code>webbrowser.open(&#39;http://jixiaoyong.github.io/blog/&#39;)</code>中的博客地址，发布完后默认打开该网页。（后期也可以改为<code>post()</code>参数传入，这样只需要更改<code>main.py</code>就行）</p></li></ul><h2 id="运行main-py文件"><a href="#运行main-py文件" class="headerlink" title="运行main.py文件"></a>运行<code>main.py</code>文件</h2><ul><li>在Linux命令行输入如下命令，并回车，根据提示操作即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><p>​    Windows下可以运行<code>start.cmd</code>脚本（待实现）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//start.cmd脚本内容</span><br><span class="line">python main.py</span><br><span class="line">cmd</span><br></pre></td></tr></table></figure><ul><li><p>操作过程提示及说明如下：（渣英语请忽略…）</p><ul><li><p>input yout file name 输入要发布的文章名称xxx（当前版本暂不支持中文）</p><p>输入回车会自动创建xxx.md文件并打开（需要系统支持该格式）</p></li><li><p>are you finish your post 输入y或n，选择是否用hexo编译文章</p><p>y:编译文章  n:不编译文章，退出命令行</p></li><li><p>post or not  输入y或n，选择是否发布文章到网站,可以在打开的页面预览后做决定</p><p>y:发布文章  n:不发布文章，退出命令行</p></li><li><p>update post  《xxx》 提示开始发布文章，自动打开网页，并保存源文件</p></li></ul></li></ul><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>源代码已经上传<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-31/python%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%96%87%E7%AB%A0" target="_blank" rel="noopener">github</a></p><h1 id="后期计划"><a href="#后期计划" class="headerlink" title="后期计划"></a>后期计划</h1><ul><li>增加文件名中文支持</li><li><del>增加图片自动上传、替换为github链接</del>(2018/2/2已实现)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python自动化部署文章</title>
      <link href="/blog/posts/af2aa19e/"/>
      <url>/blog/posts/af2aa19e/</url>
      
        <content type="html"><![CDATA[<p>python脚本实现一键自动新建文章，编译，预览，发布github.</p><p>just test</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[update]Python爬取gityuan所有文章列表</title>
      <link href="/blog/posts/6e070881/"/>
      <url>/blog/posts/6e070881/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>更新内容：</p><ul><li>爬取gityuan.com网站所有文章列表并输出json</li><li>汇总信息输出config.json为后面的客户端做准备</li></ul><p>更新文件：</p><ul><li>spider_main.py</li><li>html_output.py</li><li><strong>gityuan_urls.py</strong></li><li><strong>html_downloader.py</strong></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li><strong>spider_main.py</strong></li></ul><p>作为入口类，主要增加了初始化所有URL，以及便利这些URL的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp = SpiderMain()</span><br><span class="line"></span><br><span class="line">gityuan = gityuan_urls.GitYuanUrls()</span><br><span class="line"></span><br><span class="line">gityuan_urls = gityuan.get_urls(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">'gityuan_page_'</span></span><br><span class="line"></span><br><span class="line">sp.craw(gityuan_urls,file_name)</span><br></pre></td></tr></table></figure><p>其<code>craw()</code>方法修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">craw</span><span class="params">(self, root_urls, file_name)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#将所有有效链接全部加入</span></span><br><span class="line">        self.urls.add_new_urls(root_urls)</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#循环遍历这些链接</span></span><br><span class="line">        <span class="keyword">while</span> self.urls.has_next():</span><br><span class="line"></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            new_url = self.urls.get_new_url()</span><br><span class="line"></span><br><span class="line">            html_cont = self.downloader.download(new_url)</span><br><span class="line"></span><br><span class="line">            new_url, new_data = self.parser.parse(new_url, html_cont)</span><br><span class="line"></span><br><span class="line">            self.output.collect_data(new_data)</span><br><span class="line"></span><br><span class="line">            new_file_name = file_name + (<span class="string">'%d.json'</span>%i)</span><br><span class="line"></span><br><span class="line">            self.output.output_html(new_file_name)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#等待3s，防止太频繁访问被识别</span></span><br><span class="line">            sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#结束遍历，输出汇总信息</span></span><br><span class="line">        self.output.end(file_name,root_urls[<span class="number">0</span>],i)</span><br></pre></td></tr></table></figure><ul><li><strong>html_output.py</strong></li></ul><p>主要改动如下：</p><ol><li><code>output_html(self,file_name)</code>方法增加一个<code>file_name</code>的参数，并在内部调用<code>self.mkdir()</code>方法生成output目录，方便同时输出多个文档</li><li><code>mkdir()</code>方法，创建文件</li><li><code>end(self,file_name_start, url, num)</code>方法，输出汇总文档，代码如下</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">end</span><span class="params">(self,file_name_start, url, num)</span>:</span></span><br><span class="line"></span><br><span class="line">    self.mkdir()</span><br><span class="line"></span><br><span class="line">    file_name = self.output_dir + <span class="string">'config.json'</span></span><br><span class="line"></span><br><span class="line">    file_out = open(file_name,<span class="string">'w'</span>)</span><br><span class="line">    </span><br><span class="line">    current_time = time.time()</span><br><span class="line"></span><br><span class="line">    config_str = (<span class="string">'&#123;"url":"%s","total":"%d","update_time":"%d","file_name":"%s"&#125;'</span> % (url,num,current_time,file_name_start))</span><br><span class="line"></span><br><span class="line">    file_out.write(config_str)</span><br></pre></td></tr></table></figure><ul><li><strong>gityuan_urls.py</strong></li></ul><p>主要代码如下，通过循环遍历获取所有文章列表信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitYuanUrls</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="string">"""docstring for GitYuanUrls"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_urls</span><span class="params">(self, num)</span>:</span></span><br><span class="line"></span><br><span class="line">urls = []</span><br><span class="line"></span><br><span class="line">urls.append(<span class="string">'http://www.gityuan.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>,num):</span><br><span class="line">url_ = (<span class="string">'http://www.gityuan.com/page%d/'</span>%x)</span><br><span class="line">urls.append(url_)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> urls</span><br></pre></td></tr></table></figure><ul><li><strong>html_downloader.py</strong></li></ul><p>就在本文编辑的过程中，爬虫被识别，并且限制访问文件数量，所以对下载功能做了简单的伪装、增加超时处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download2</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="comment">#升级版</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#伪装为浏览器</span></span><br><span class="line">        req_header = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            request = urllib2.Request(url,<span class="keyword">None</span>,req_header)</span><br><span class="line"></span><br><span class="line">            response = urllib2.urlopen(request,<span class="keyword">None</span>,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response.read()</span><br><span class="line">        <span class="keyword">except</span> socket.timeout <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment">#超时处理</span></span><br><span class="line">            print(type(e))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当前爬虫主体功能以及实现，可以爬取gityuan.com所有有效文章列表，可以满足客户端需求。但仍然存在以下问题：</p><ol><li>没有伪装，爬虫<strong>很容易</strong>被识别并被拒绝服务（<del>就在刚刚写下这句话的时候，就发生了被限制访问，真*乌鸦嘴</del>）。</li><li>由于原网站特性，其置顶文章每页都有，会导致部分数据重复。</li><li>未爬取具体文章内容。</li></ol><blockquote><p><strong>说明</strong></p><p>本文只为学术研究，其中涉及到的第三方网站及其所有资源均属原主所有。向gityuan大神致敬，欢迎访问其<a href="http://gityuan.com/" target="_blank" rel="noopener">blog</a>。</p></blockquote><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/gityuan_spider" target="_blank" rel="noopener">github链接</a></p><p><code>tag</code>为<code>gityuan_spider1.5</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python爬虫爬取gityuan.com数据并输出json</title>
      <link href="/blog/posts/9c0ccf0d/"/>
      <url>/blog/posts/9c0ccf0d/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>本文基于Python2.7</p></blockquote><p>这篇文章基于我在<a href="www.imooc.com">慕课网</a>上面学习Python简单爬虫写的内容，教程内容是爬取1000条百度百科的数据，但是教程中爬虫截止2018-01-27已经失效，刚好看到大神gityuan.com的内容，于是用Python实现爬取其网页内容并生成json数据。</p><p>本文即上述过程整理。</p><p>本文涉及源代码已上传github（<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/gityuan_spider" target="_blank" rel="noopener">点这里查看</a>）。</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>爬虫主要活动是：</p><ol><li>爬取目标网页内容</li><li>对获取到的内容进行分析，获取有用数据</li><li>将处理好的数据按格式输出</li></ol><p>此外还需要有一个专门管理爬虫活动的主类，故而文件结构如下：</p><ol><li>spider_main.py             入口类</li><li>url_manager.py             管理要下载的链接</li><li>html_downloader.py    下载网页内容</li><li>html_paeser.py              对获取到的数据进行解析、加工</li><li>html_out.py                     输出格式化的数据</li></ol><p>目前只实现了爬取gityuan.com第一页内容并输出json，所以暂时不需要实现url_manager.py</p><h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><p><strong>spider_main.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入用到的各个类</span></span><br><span class="line"><span class="keyword">import</span> html_downloader</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义入口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderMain</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#初始化各个变量downloader、parser、output...</span></span><br><span class="line">    self.downloader = html_downloader.HtmlDownloader()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#略</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">craw</span><span class="params">(self,root_url)</span>:</span></span><br><span class="line">    </span><br><span class="line">    html_cont = self.downloader.download(root_url)</span><br><span class="line">    </span><br><span class="line">    new_data = self.parser.parse(html_cont)</span><br><span class="line">    </span><br><span class="line">    self.output.collect_data(new_data)</span><br><span class="line">    </span><br><span class="line">    self.output.output_json()</span><br><span class="line">    </span><br><span class="line">root_url = <span class="string">'http://www.gityuan.com/'</span></span><br><span class="line">sp = SpiderMain()</span><br><span class="line">sp.craw(root_url)</span><br></pre></td></tr></table></figure><ul><li>在<code>__init__()</code> 方法初始化各个变量；</li><li>在<code>craw()</code>中分别实现下载、解析网页内容、输出加工数据</li></ul><p><strong>html_download.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlDownLoader</span><span class="params">(object)</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self,url)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    respone = urllib2.urlopen(url,timeout=<span class="number">300</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> respone.getcode() != <span class="number">200</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> respone.read()</span><br></pre></td></tr></table></figure><p>下载并返回网页内容，比较简单</p><p><strong>html_parser.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="comment">#第三方包，需要单独下载</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlParser</span><span class="params">(object)</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self,html_cont)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> html_cont <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#用BeautifulSoup解析文档内容</span></span><br><span class="line">    soup = BeautifulSoup(html_cont,<span class="string">'html.parser'</span>)</span><br><span class="line">    </span><br><span class="line">    res_data = [] <span class="comment">#数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取所有的文章节点nodes</span></span><br><span class="line">    post_div_nodes = soup.find_all(<span class="string">'div'</span>,class_=<span class="string">'post-preview'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#遍历nodes，读取每一项内容并保存</span></span><br><span class="line">    <span class="keyword">for</span> post_div_node <span class="keyword">in</span> post_div_nodes:</span><br><span class="line">      post_div_soup = BeautifulSoup(str(post_div_node))</span><br><span class="line">      </span><br><span class="line">      post_info = &#123;&#125; <span class="comment">#字典dict</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">#判断URL是否是完整</span></span><br><span class="line">      url_ = post_div_soup.a[<span class="string">'href'</span>]</span><br><span class="line">      <span class="keyword">if</span> <span class="string">'http://'</span> <span class="keyword">not</span> <span class="keyword">in</span> url_:</span><br><span class="line">        url_ = <span class="string">"http://gityuan.com"</span> + url_</span><br><span class="line">       </span><br><span class="line">      <span class="comment">#保存数据</span></span><br><span class="line">      post_info[<span class="string">'url'</span>] = url_</span><br><span class="line">      post_info[<span class="string">'title'</span>] = post_div_soup.find(<span class="string">'h2'</span>).get_text()</span><br><span class="line">      post_info[<span class="string">'summary'</span>] = post_div_soup.find(<span class="string">'div'</span>,class_=<span class="string">'post-content-preview'</span>).get_text()</span><br><span class="line">       </span><br><span class="line">      res_data.append(post_info)</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">return</span> res_data</span><br></pre></td></tr></table></figure><p>这是爬虫功能的重点之一：对网页数据进行解析，由此数据才变为可用数据</p><p>主要是通过第三方插件<code>BeautifulSoup</code>解析数据，并保存到数组<code>res_data</code>中，具体见代码中实现</p><p><strong>html_output.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#下面两行代码解决编码问题，强制使用utf-8，而非默认的unicode编码</span></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonOutput</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.datas = []</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">collect_data</span><span class="params">(self,new_data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> new_data <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">      self.datas.append(new_data)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output_json</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment">#打开文件，并以json格式输出</span></span><br><span class="line">    fout = open(<span class="string">'output.json'</span>,<span class="string">'w'</span>)</span><br><span class="line">    </span><br><span class="line">    fout.write(<span class="string">'&#123;'</span>)</span><br><span class="line">    fout.write(<span class="string">r'"data":['</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> self.datas:</span><br><span class="line">      <span class="keyword">for</span> post_info <span class="keyword">in</span> data:</span><br><span class="line">        </span><br><span class="line">        fout.write(<span class="string">'&#123;'</span>)</span><br><span class="line">        fout.write(<span class="string">'"url":"%",'</span> % post_info[<span class="string">'url'</span>])</span><br><span class="line">        fout.write(<span class="string">'"title":"%",'</span> % post_info[<span class="string">'title'</span>])</span><br><span class="line">        fout.write(<span class="string">'"summary":"%",'</span> % post_info[<span class="string">'summary'</span>])</span><br><span class="line">        fout.write(<span class="string">'&#125;,'</span>)</span><br><span class="line">    <span class="comment">#为了符合json规范，最后一个输入空数据，无末尾逗号</span></span><br><span class="line">    fout.write(<span class="string">r'&#123;&#125;'</span>)</span><br><span class="line">    </span><br><span class="line">    fout.write(<span class="string">']&#125;'</span>)</span><br></pre></td></tr></table></figure><p>本类也很重要，主要是数据存取，以及将解析好的数据格式化输出</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文中代码经二次处理，不一定与源代码一致，但思路如此，以供参考。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android自定义透明背景的Dialog</title>
      <link href="/blog/posts/f20627c9/"/>
      <url>/blog/posts/f20627c9/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>通过自定义Dialog类，使用Style、AnimationDrawable等实现一个透明背景的、带进度更新的弹窗。</p><p>主要涉及Style自定义以及AnimationDrawable的使用。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li><strong>布局文件</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/dialog_bg"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/image"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"250dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"250dp"</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>资源文件</strong></li></ul><p>1）下载对应进度条的图片资源，放到drawable目录下</p><p>2）在drawable下新建dialog_progress.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/progress_1"</span> //资源文件</span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"300"</span> /&gt;</span> //持续时间ms</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/progress_2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）dialog圆角背景（非必须）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#6fb6d4"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"500dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4）自定义dialog的style</p><p><code>windowBackground</code>使背景透明</p><p><code>backgroundDimEnabled</code>则可以去除半透明遮罩效果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"diyDialogStyle"</span> <span class="attr">parent</span>=<span class="string">"@android:style/Theme.Dialog"</span> &gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span><span class="comment">&lt;!--背景透明--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:backgroundDimEnabled"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span><span class="comment">&lt;!--半透明，模糊--&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>DIYDialog.java</strong></li></ul><p>继承自<code>Dialog.java</code> ，并用构造函数调用<code>initView()</code>方法初始化dialog样式，有其他需求可以再自己实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化view、控件</span></span><br><span class="line">View view = View.inflate(context, R.layout.layout_dialog, <span class="keyword">null</span>);</span><br><span class="line">ImageView imageView = view.findViewById(R.id.image);</span><br><span class="line">imageView.setBackgroundResource(R.drawable.dialog_progress);</span><br><span class="line"><span class="comment">//填充布局</span></span><br><span class="line">setContentView(view);</span><br><span class="line"><span class="comment">//实现动画</span></span><br><span class="line">AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getBackground();</span><br><span class="line">animationDrawable.run();</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/DIY_Dialog" target="_blank" rel="noopener">github源码路径</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java实现AES加密解密应用</title>
      <link href="/blog/posts/375fcf66/"/>
      <url>/blog/posts/375fcf66/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近手机中涉及到用户账户密码保存的问题，选用AES加密算法进行加密后，再通过SharedPreferences保存在手机端。</p><p>本文主要介绍AES的加密、解密用法。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>初始化秘钥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AES = <span class="string">"AES"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWPRD = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKeySpec <span class="title">initKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SecretKeySpec key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        KeyGenerator kg = KeyGenerator.getInstance(AES);</span><br><span class="line">        kg.init(<span class="number">128</span>,<span class="keyword">new</span> SecureRandom(PASSWPRD.getBytes()));<span class="comment">//通过这种算法，每次生成的key都是一样的</span></span><br><span class="line">      <span class="comment">//也可以kg.init(128),这样每次生成的key都不一样</span></span><br><span class="line">        SecretKey securityKey = kg.generateKey();</span><br><span class="line">        <span class="keyword">byte</span>[] encodedKey = securityKey.getEncoded();</span><br><span class="line">        key = <span class="keyword">new</span> SecretKeySpec(encodedKey, AES);<span class="comment">//AES也可以替换为"AES/CBC/PKCS5PADDING"</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line"><span class="comment">//source是要加密的内容</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(AES);<span class="comment">//创建密码器</span></span><br><span class="line"><span class="keyword">byte</span>[] byteContent = source.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);<span class="comment">//创建密码器</span></span><br><span class="line"><span class="keyword">byte</span>[] result = cipher.doFinal(byteContent);<span class="comment">//加密</span></span><br></pre></td></tr></table></figure><p>解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(AES);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] result = cipher.doFinal(source);</span><br></pre></td></tr></table></figure><p>加密和解密的结果都是二进制的，无法直接转化为字符串，所以还需要将二进制与十六进制互转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseByte2HexStr</span><span class="params">(<span class="keyword">byte</span> buf[])</span> </span>&#123;</span><br><span class="line">    StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class="line">        String hex = Integer.toHexString(buf[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            hex = <span class="string">'0'</span> + hex;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuffer.append(hex.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] parseHexStr2Byte(String hexStr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (hexStr.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[hexStr.length() / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hexStr.length() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> high = Integer.parseInt(hexStr.substring(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">1</span>), <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> low = Integer.parseInt(hexStr.substring(i * <span class="number">2</span> + <span class="number">1</span>, i * <span class="number">2</span> + <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">        result[i] = (<span class="keyword">byte</span>) (high * <span class="number">16</span> + low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在初始化一个key后，对文本进行加密和解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化key</span></span><br><span class="line">SecretKeySpec key = initKey();</span><br><span class="line"><span class="comment">//加密文本并转化为16进制，方便保存</span></span><br><span class="line">String eStr = parseByte2HexStr(encrypt(resource,key));</span><br><span class="line"><span class="comment">//将加密16进制文本转为二进制，进行解密</span></span><br><span class="line">String dStr = decrypt(parseHexStr2Byte(estr));</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://blog.csdn.net/hbcui1984/article/details/5201247" target="_blank" rel="noopener">JAVA实现AES加密 - CSDN博客</a></p><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-22/encryption" target="_blank" rel="noopener">源码github链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java注解</title>
      <link href="/blog/posts/3f6454bb/"/>
      <url>/blog/posts/3f6454bb/</url>
      
        <content type="html"><![CDATA[<p>注解，<em>是描述Java代码的代码，它能够被编译器解析，向编译器、虚拟机说明一些事情，就像java中给程序员看的注释一样</em>。</p><p>Android应用开发这方面比较火的是<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">Butter Knife</a> ,本文讲述如何自定义注解替换findViewById()。</p><p>实现<strong>注解（annotation）</strong>的思路：通过<strong>反射</strong>获取到类中使用注解的变量，方法，再调用不同的方法对这些变量，方法进行处理以达到目的。</p><p>主要涉及三方面：</p><ul><li>定义一个注解类</li><li>定义一个注解帮助类</li><li>使用注解</li></ul><h1 id="java元注解"><a href="#java元注解" class="headerlink" title="java元注解"></a>java元注解</h1><p>java语言有四个预留的注解，用来生成其他自定义的注解：</p><ul><li>@Target</li></ul><p>说明注解所能修饰的范围。其值一般为ElementType.xxx，主要有：</p><ol><li>CONSTRUCTOR 描述构造器</li><li>FIELD 描述域</li><li>LOCAL_VARIABLE 描述局部变量</li><li>METHOD 描述方法</li><li>PACKAGE 描述包</li><li>PARAMETER 描述参数</li><li>TYPE 描述类，接口，enum声明</li></ol><ul><li>@Retention</li></ul><p>说明注解存活的生命周期,其值一般为RetentionPolicy.xxx，主要有</p><ol><li>SOURCE 仅源文件有效，被编译器丢弃</li><li>CLASS 在class文件中有效，可能被虚拟机忽略</li><li>RUNTIME 在运行时有效，在class被装载时被获取</li></ol><ul><li>@Documented</li></ul><blockquote><p>用于描述其它类型的annotation应该被作为被标注的程序成员的公共API</p></blockquote><p>表示是否将注解信息添加在java文档中。有该注解则会被Javadoc工具文档化</p><p>是一个标记注解，没有值</p><ul><li>@Inherited</li></ul><p>表示该标记会被标记的class的子类继承，在查找该注解时，如果当前类没有，会自动向上到其父类中查找，直到<em>该注解类型被找到或是查找完了Object类还未找到</em></p><p>是一个标记注解，没有值</p><p><strong>注解不能继承其他注解或接口</strong></p><h1 id="内建注解"><a href="#内建注解" class="headerlink" title="内建注解"></a>内建注解</h1><p>java中常见的内建注解：</p><ul><li><code>@Override</code> 重写父类方法</li><li><code>@Deprecated</code> 不赞成使用的api</li><li><code>@SuppressWarnings()</code> 忽略指定警告</li></ul><p>参数如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>deprecation</td><td>使用了过时的类或方法时的警告</td></tr><tr><td>unchecked</td><td>执行了未检查的转换时的警告</td></tr><tr><td>fallthrough</td><td>当Switch程序块进入进入下一个case而没有Break时的警告</td></tr><tr><td>path</td><td>在类路径、源文件路径等有不存在路径时的警告</td></tr><tr><td>serial</td><td>当可序列化的类缺少serialVersionUID定义时的警告</td></tr><tr><td>finally</td><td>任意finally子句不能正常完成时的警告</td></tr><tr><td>all</td><td>以上所有情况的警告</td></tr></tbody></table><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><h2 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">    <span class="comment">//注解参数只可以为public或者默认</span></span><br><span class="line">    <span class="comment">//如果注解中的值不是value，那么在进行注解的时候，需要给出对应的值的名字</span></span><br><span class="line">    <span class="comment">//如@ViewInject(id = R.id.buy)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//注解元素必须有明确的值，要不在定义注解时指定默认值，要不在使用注解时指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;<span class="comment">//指定默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注解参数支持数据类型如下：</p><p>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)<br>2.String类型<br>3.Class类型<br>4.enum类型<br>5.Annotation类型<br>6.以上所有类型的数组</p></blockquote><h2 id="注解帮助类"><a href="#注解帮助类" class="headerlink" title="注解帮助类"></a>注解帮助类</h2><p>主要提供使用注解的方法，代码中的注解替换为真正要实现的逻辑，为注解和使用注解的类搭建一个桥梁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心方法如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bindViews</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取到使用注解的类</span></span><br><span class="line">        Class&lt;? extends Activity&gt; clazz = activity.getClass();</span><br><span class="line">  <span class="comment">//获取该类中的所有域变量</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">  <span class="comment">//通过遍历，将使用到注解的变量初始化</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">          <span class="comment">//获取注解对象</span></span><br><span class="line">            BindView bindView = field.getAnnotation(BindView.class);</span><br><span class="line">            <span class="keyword">if</span> (bindView != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//获取注解的值</span></span><br><span class="line">                <span class="keyword">int</span> viewId = bindView.value();</span><br><span class="line">                <span class="keyword">if</span> (viewId != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">//注解要实现的逻辑，此处为替代clazz中的findViewById()方法，注意getMethod()是获取该类及其实现的接口中所有的public方法</span></span><br><span class="line">                        Method findViewById = clazz.getMethod(<span class="string">"findViewById"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">                        findViewById.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        Object o = findViewById.invoke(activity, viewId);</span><br><span class="line">                      <span class="comment">//修改要注解的类，到此注解目的达到</span></span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        field.set(activity,o);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>在类中通过<code>@xxx()</code> 使用注解，并通过帮助类真正实现注解逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记注解</span></span><br><span class="line"><span class="meta">@BindView</span>(R.id.text)</span><br><span class="line"><span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用帮助类方法</span></span><br><span class="line">AnnotationUtils.bindViews(ASampleActivity.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用初始化之后的变量</span></span><br><span class="line">textView.setText(<span class="string">"hello annotation"</span>);</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="http://www.importnew.com/23816.html" target="_blank" rel="noopener">Java核心技术点之注解 - ImportNew</a></li><li><a href="http://gityuan.com/2016/01/23/java-annotation/" target="_blank" rel="noopener">java注解–gityuan</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python入门知识</title>
      <link href="/blog/posts/a8f97c56/"/>
      <url>/blog/posts/a8f97c56/</url>
      
        <content type="html"><![CDATA[<p>基于Python3.x</p><p>Python文件默认格式<code>.py</code></p><p>首行默认以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li><p><strong>数字</strong></p><p>整数int  1，2，3</p><p>长整数long  1112L</p><p>浮点数float （小数）1.23，3.14</p><p>复数complex  3.14j</p></li><li><p><strong>字符串</strong></p><p> ‘abc’，”abc”，’’’abc‘’‘</p><p>‘x’和”x” 区别不大</p><p>‘’’abc‘’‘ 文本可以跨行</p><p>字符串前面加r或者R表示字符串内部不需要转义，否则要用<code>\</code> 转义</p><p>支持<code>a[0]</code>取值</p></li><li><p><strong>布尔值</strong></p><p> <code>True</code> 和<code>False</code></p><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算</p></li><li><p><strong>空值</strong></p><p> <code>None</code></p></li><li><p><strong>变量</strong> </p><p>命名规则：开头<code>aA_</code>，其后可以包含<code>aA_1</code></p></li><li><p><strong>常量</strong></p><p> 不能变的变量</p></li></ul><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul><li><p><strong>列表list</strong></p><p> [1,2,3,3]</p><p>插入list.insert(1,’vaule’)</p><p>删除list.pop() / list.pop(1)</p></li><li><p><strong>元组tuple </strong></p><p>(1,2,3,3)</p><p>与列表类似，但是一旦初始化就不能再修改</p><hr></li><li><p><strong>字典dict</strong></p><p> {‘a’:1,’b’:’vaule’}</p><p>键值对，读取快，相当于java的map</p></li><li><p><strong>set</strong></p><p> set([1,2,3])</p><p>键的集合，不能有重复的，相当于java的set</p></li></ul><h1 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h1><ul><li>if … : … elif … : … else : …</li><li>for x in xs : …</li><li>while x : …</li></ul><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">n</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>return</strong></li></ul><p>可以没有return，默认返回None</p><p>可以return 多个值，实际上返回的是一个tuple</p><ul><li><p><strong>pass</strong></p><p>不想执行任何语句，但是为了符合语法规范，可以用pass当做占位符</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>抛出异常</strong> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> TypeError(<span class="string">'an error'</span>)</span><br></pre></td></tr></table></figure><p>其中TypeError需要继承自<code>error</code>或者<code>Exception</code></p><ul><li><strong>参数</strong></li></ul><p>位置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg)</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p>默认参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg0,arg1 = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p><strong>注意</strong> 默认参数必须是参数中后面的几位；默认值必须不可变，如int，string等</p><p>可变参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg,*args)</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p><code>*args</code> 表示参数个数可变，可以输入list/tuple等，或者依次输入多个参数，用逗号分隔</p><p>关键词参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg,**keywords)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> '<span class="title">city</span>' <span class="title">in</span> <span class="title">kw</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>**keywords</code> 表示接受关键词作为参数传入，可以传入dict，或者依次输入多个关键词参数</p><p>命名关键词参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun0</span><span class="params">(args,*，name,age)</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">fun1</span><span class="params">(arg.*args,name,age)</span>#如果命名关键词前面有可变参数，则不用*分隔</span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p>限制输入的关键字，限制只有name和age作为关键词参数</p><h1 id="使用其他文件的函数"><a href="#使用其他文件的函数" class="headerlink" title="使用其他文件的函数"></a>使用其他文件的函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用时 sys.fun()</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#使用时直接fun()</span></span><br><span class="line"><span class="keyword">from</span> xxFile <span class="keyword">import</span> fun</span><br><span class="line">form sys <span class="keyword">import</span> *</span><br><span class="line">form sys <span class="keyword">import</span> fun</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul><li><strong>定义类</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="string">'''doc for AClass</span></span><br><span class="line"><span class="string">you can use this by</span></span><br><span class="line"><span class="string">AClass.__doc__'''</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment">#默认的初始化方法</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">aFun</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#创建类对象</span></span><br><span class="line">a = AClass()</span><br><span class="line"><span class="comment">#调用方法</span></span><br><span class="line">a.aFun()</span><br></pre></td></tr></table></figure><p>所有的类方法必须至少有一个参数，推荐命名为self，系统会自动传入类对象，无需手动传入。</p><ul><li><strong>继承</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"father"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"i am f"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Father)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment">#子类方法不会自己调用父类方法，需要手动调用</span></span><br><span class="line">    super(Child,self).__init__()</span><br><span class="line">    <span class="comment">#调用父类方法2：</span></span><br><span class="line">    <span class="comment">#Father.__init__(self)</span></span><br><span class="line">    print(<span class="string">"child"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'i am c'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(self,where)</span>:</span></span><br><span class="line">    print(<span class="string">'go to %s'</span>%where)</span><br><span class="line"></span><br><span class="line">c = Child() <span class="comment">#father child</span></span><br><span class="line">c.say() <span class="comment">#i am c</span></span><br><span class="line">c.go(<span class="string">'home'</span>) <span class="comment">#go ro home</span></span><br></pre></td></tr></table></figure><p>子类继承父类，则需要在子类定义时传入父类</p><p>子类如果有与父类同名方法，则优先调用子类方法，除非子类特别调用父类的方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射简单应用</title>
      <link href="/blog/posts/3e9e8cb1/"/>
      <url>/blog/posts/3e9e8cb1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>反射，用来在运行时获取给定类的构造函数，变量，方法，并对其作以修改，而不必在编译时获取该类。</p><blockquote><p>Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</p><p>–<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html</a></p></blockquote><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>定义一个待反射的类ATestClass.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cf.android666.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATestClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ATestClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">" age: "</span> + age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在TestReflect.java中反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//注意这里需要是完整的类名，包括包名</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"cf.android666.reflect.ATestClass"</span>);</span><br><span class="line">ATestClass aTestClsObj=(ATestClass) clazz.newInstance();</span><br><span class="line">  </span><br><span class="line"><span class="comment">//反射获取变量</span></span><br><span class="line">Field mName = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">mName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">mName.set(aTestClsObj, <span class="string">"aReflect"</span>);</span><br><span class="line">System.out.println(aTestClsObj.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射获取方法</span></span><br><span class="line">Method mInit= clazz.getDeclaredMethod(<span class="string">"init"</span>, String.class,<span class="keyword">int</span>.class);</span><br><span class="line">mInit.setAccessible(<span class="keyword">true</span>);<span class="comment">//解除私有限定，让我们在用反射时访问私有变量</span></span><br><span class="line">mInit.invoke(aTestClsObj, <span class="string">"aInitName"</span>,<span class="number">66</span>);</span><br><span class="line">System.out.println(aTestClsObj.name + aTestClsObj.getAge());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>反射的用法较为简单</p><ul><li>通过<code>Class.froName()</code> 获取Class对象<code>clazz</code> ，获取要反射的Class对象<code>aTestClsObj</code> </li><li>通过<code>clazz</code> 获取要反射Class的变量、方法</li><li>通过<code>aTestClsObj</code> 操作这些变量，方法</li></ul><p>其中需要注意的有</p><ul><li><code>f.setAccessible(true);</code> 方法可以解除<code>private</code> 限制，进而可以操作类的私有变量，方法</li><li><code>clazz.getXXX()</code> 方法获取<strong>全部公有</strong>变量、方法 ，<strong>包括父类或接口</strong>的xx，<code>clazz.getDeclaredXXX()</code> 方法获取<strong>全部</strong> 变量、方法，包括私有的，实现接口的方法，<strong>但是不包括父类的</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android通过Hook启动未注册Activity</title>
      <link href="/blog/posts/26eab50a/"/>
      <url>/blog/posts/26eab50a/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hook是钩子的意思，hook的过程是通过反射、代理等改变系统原有的行为以达到自己的目的。</p><p>本文主要是通过hook android 中的ActivityManagerService和Handler.CallBack，欺骗系统调起activity的过程，在调用startActivity时将targetIntent通过proxy伪装为proxyIntent，等到通过系统验证，正式启动activity时，再讲proxyIntent恢复为targetIntent，从而实现调用未在AndroidManifest.xml中注册的activity。</p><blockquote><p>需要注意，本方法只在Api&lt;26下有效。具体原因见后面。</p></blockquote><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="1-新建Activity等"><a href="#1-新建Activity等" class="headerlink" title="1.新建Activity等"></a>1.新建Activity等</h2><p><code>IndexActivity.java</code>用于启动<code>targetIntent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((Button)findViewById(R.id.btn1)).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">               <span class="comment">//启动未在AndroidManifest.xml注册的activity</span></span><br><span class="line">               mContext.startActivity(<span class="keyword">new</span> Intent(mContext,TargetActivity.class));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><code>TargetActivity.java</code> 和<code>ProxyActivity.java</code> 分别设置对应页面布局<code>setContentView(R.layout.activity_xxx);</code></p><p><code>HookApplication.java</code> 用于调用hook方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Utils.hookAms(<span class="keyword">this</span>);</span><br><span class="line">        Utils.hookHandle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AndroidManifest.xml</code>中注册<code>IndexActivity</code>和<code>ProxyActivity</code>，Application使用<code>HookApplication</code>。</p><h2 id="2-Utils-java实现hook具体逻辑"><a href="#2-Utils-java实现hook具体逻辑" class="headerlink" title="2.Utils.java实现hook具体逻辑"></a>2.Utils.java实现hook具体逻辑</h2><p><code>Utils.hookAms()</code> 实现拦截targetIntent并发起proxyIntent，欺骗系统对activity是否已注册的验证，其中proxyIntent通过<code>proxyIntent.putExtra(TARGET_KEY, targetIntent);</code> 方法携带targetIntent。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hookAms()核心代码</span></span><br><span class="line">Class hookActivityManagerNative = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line">            <span class="comment">//在api&gt;26时无此变量：gDefault，该方法失效</span></span><br><span class="line">            Field gDefault = hookActivityManagerNative.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">            gDefault.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object object = gDefault.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Class hookSingleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">            Field mInstance = hookSingleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">            mInstance.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Object oldAms = mInstance.get(object);</span><br><span class="line"></span><br><span class="line">            Class hookIActivityManagerService = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                    <span class="keyword">new</span> Class&lt;?&gt;[]&#123;hookIActivityManagerService&#125;,</span><br><span class="line">                    <span class="keyword">new</span> MAmsInvocationHandler(context,oldAms));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将原有的ActivityManagerService替换为我们自定义的</span></span><br><span class="line">            mInstance.set(object,proxy);</span><br></pre></td></tr></table></figure><p>在<code>MAmsInvocationHandler</code> 里面实现targetIntent和proxy的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MAmsInvocationHandler核心代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MAmsInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TARGET_KEY = <span class="string">"targetIntent"</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            Intent targetIntent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    targetIntent = (Intent) args[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Intent proxyIntent = <span class="keyword">new</span> Intent(mContext, ProxyActivity.class);</span><br><span class="line">                proxyIntent.putExtra(TARGET_KEY, targetIntent);</span><br><span class="line">                args[index] = proxyIntent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mOldAms,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，已经对activity.startActivity做了拦截，所有的targetIntent都会被拦截，存储在proxyIntent中，以通过系统的检查。</p><p>接下来，通过系统检查后，<code>hookHandle()</code>通过重写Handler.CallBack，对启动proxyIntent事件做拦截，使之启动targetIntent对应的Activity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hookHandle()核心代码</span></span><br><span class="line">Class activityThreadCls = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThread = activityThreadCls.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThread.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object activityThread = currentActivityThread.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Field mH = activityThreadCls.getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mH.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Handler handler = (Handler) mH.get(activityThread);</span><br><span class="line">Field callBack = Handler.class.getDeclaredField(<span class="string">"mCallback"</span>);</span><br><span class="line">callBack.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">callBack.set(handler, <span class="keyword">new</span> ActivityThreadHandlerCallBack(handler));</span><br></pre></td></tr></table></figure><p>其中<code>ActivityThreadHandlerCallBack</code> 将返回我们自定义的CallBack以替换系统的，实现启动targetIntent而非proxyIntent。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThreadHandlerCallBack核心代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThreadHandlerCallBack</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.what == <span class="number">100</span>) &#123;</span><br><span class="line">            handleLaunchActivity(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.handleMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//主要代码，在这里将proxyIntent转化为targetIntent</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        Object object = msg.obj;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field intent = object.getClass().getDeclaredField(<span class="string">"intent"</span>);</span><br><span class="line">            intent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Intent proxyIntent = (Intent) intent.get(object);</span><br><span class="line">            Intent targetIntent = proxyIntent.getParcelableExtra(MAmsInvocationHandler.TARGET_KEY);</span><br><span class="line">            <span class="keyword">if</span> (targetIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyIntent.setComponent(targetIntent.getComponent());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，就实现了启动通过已经注册了的ProxyActivity启动未注册TargetActivity的全过程。</p><p>主要思想是找到系统实现该过程的逻辑，在对应地方通过反射获取到对应变量，插入自己的逻辑，从而达到目的。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>上面涉及到的代码路径：</p><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/AndroidHook/20180116" target="_blank" rel="noopener">github源代码路径</a></p><p>参考了几篇文章，其中较为完整的一篇如下：</p><p><a href="https://www.jianshu.com/p/69bfbda302df" target="_blank" rel="noopener">Android插件化系列第（一）篇—Hook技术之Activity的启动过程拦截</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android hook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AndroidService详解</title>
      <link href="/blog/posts/ad4c562c/"/>
      <url>/blog/posts/ad4c562c/</url>
      
        <content type="html"><![CDATA[<h2 id="启动一个Service"><a href="#启动一个Service" class="headerlink" title="启动一个Service"></a>启动一个Service</h2><ul><li><p>MyServices.java</p><p>必须继承自Service，或者如IntentService本身就是等其子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServices</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"TAG"</span>,<span class="string">"onBind"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Log.d(<span class="string">"TAG"</span>,<span class="string">"onCreate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.d(<span class="string">"TAG"</span>, <span class="string">"onDestroy: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>AndroidManifest.xml</p><p>注册MyServices</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyServices"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"cf.android666.myservices"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>MainActivity.java</p><p>在java中调用Service，需要<code>ServiceConnection</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onServiceConnected: 服务绑定"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onServiceDisconnected: 服务解绑"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, MyServices.class);</span><br><span class="line">bindService(intent, mConnection, Service.BIND_AUTO_CREATE);<span class="comment">//绑定Service</span></span><br><span class="line"><span class="comment">//startService(intent); 启动service</span></span><br><span class="line">unbindService(mConnection);<span class="comment">//解绑Service</span></span><br></pre></td></tr></table></figure><p><code>bindService()</code>和<code>startService()</code>的区别在于：</p><p>** <code>bindService()</code>将service和当前的activity绑定在一起，activity销毁时，service也会被销毁；</p><p>** <code>startService()</code>则只是“启动”service，在此后service的活动和activity无关，并一直存活。</p></li></ul><h1 id="Service具体分析"><a href="#Service具体分析" class="headerlink" title="Service具体分析"></a>Service具体分析</h1><p>Service在AndroidManifest.xml中的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android:name=<span class="string">".MyService"</span><span class="comment">//必须被指定</span></span><br><span class="line">android:exported=<span class="keyword">true</span>/<span class="keyword">false</span> <span class="comment">//是否能被其他应用隐式调用</span></span><br><span class="line"><span class="comment">//有intent-filter则默认为true，否则默认false；若手动指定为false则即使有intent-filter也无法隐式调用</span></span><br><span class="line">android:process=<span class="string">"remote"</span>/<span class="string">":remote"</span><span class="comment">//前者在共有的进程中进行，后者在名字为&#123;packageName&#125;:remote 的私有进程中进行，其他进行不可访问；如果不设置该属性，则service在应用自己的进程里面运行</span></span><br></pre></td></tr></table></figure><p>Service默认运行在创建他的线程中，要是进行耗时操作，最好在service中单独创建一个线程，这样子可以在子线程工作，在主线程中更新工作进度。</p><p>Service中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在初次创建服务时调用，并且直至服务死亡，只会被调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//在绑定服务是才会被调用，必须实现该方法</span></span></span><br><span class="line"><span class="function">IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//每一次通过startService()方法启动Service的时候都会被调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></span></span><br><span class="line"><span class="function">  <span class="comment">//1.intent 启动时，启动组件传递过来的Intent</span></span></span><br><span class="line"><span class="function">  <span class="comment">//2.flags 表示启动请求时是否有额外数据，可以是：</span></span></span><br><span class="line"><span class="function">  <span class="comment">//  0：无</span></span></span><br><span class="line"><span class="function">  <span class="comment">//  START_FLAG_REDELIVERY：表示该方法返回值为START_REDELIVER_INTENT，在上个服务被杀死之前调用stopSelf()停止服务</span></span></span><br><span class="line"><span class="function">  <span class="comment">//  START_FLAG_RETRY：在onStartCommand()被调用后一直无返回值时，会尝试重新调用onStartCommand()</span></span></span><br><span class="line"><span class="function">  <span class="comment">//3.当前服务id</span></span></span><br></pre></td></tr></table></figure><p>其中<code>onStartCommand()</code>方法的返回值意义如下：</p><p><code>START_STICKY</code>:service在内存不足被杀死后，内存空闲时系统会重新创建service，一旦成功创建会回调<code>onStartCommand()</code>方法，此时intent是null，除非是挂起的intent如pendingintent，无限期运行</p><p><code>START_NOT_STICKY</code>：service因内存不足被杀死，内存再次空闲系统也不会再重新创建服务，最安全</p><p><code>START_REDELIVER_INTENT</code>：service因内存不足被杀死，会重建服务并传递给最后一个intent（最后一次调用<code>startService()</code> 时的intent），用于连续作业，如下载等</p><h2 id="Service绑定服务的三种方式"><a href="#Service绑定服务的三种方式" class="headerlink" title="Service绑定服务的三种方式"></a>Service绑定服务的三种方式</h2><h3 id="1-拓展Binder类"><a href="#1-拓展Binder类" class="headerlink" title="1.拓展Binder类"></a>1.拓展Binder类</h3><p><strong>要求客户端和服务在同一应用的同一进程内</strong>。客户端通过其访问service中的公共方法。</p><p>步骤如下：</p><ol><li>创建BindService服务端，在类中创建一个实现了IBinder接口的实力对象并提供公共方法给客户端使用</li><li>在onBind()回调方法返回此Binder实例</li><li>在客户端的onServiceConnected()方法接收Binder，使用提供的方法绑定服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//service服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">  LocalService mService;</span><br><span class="line">  <span class="keyword">private</span> LocalBinder binder = <span class="keyword">new</span> LocalBinder();</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binder;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//服务中公共方法，可以被客户端通过IBInder获取实例调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</span><br><span class="line">    <span class="function">LocalService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ServiceConnection conn = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">      <span class="comment">//绑定服务时被调用，实现客户端和服务端交互（IBinder）</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span></span>&#123;</span><br><span class="line">        LocalService.LocalBinder binder = (LocalService.LocalBinder)service;<span class="comment">//获取服务端IBinder</span></span><br><span class="line">        mService = binder.getService();<span class="comment">//获取服务实例，以调用服务的公共方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//取消绑定时回调，多数时候是service被意外销毁，如内存不足</span></span><br><span class="line">      <span class="comment">//当客户端取消绑定时，系统“绝对不会”调用该方法。</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span></span>&#123;</span><br><span class="line">        mService = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//创建绑定对象</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,LocalService.class);</span><br><span class="line">    <span class="comment">//绑定服务</span></span><br><span class="line">    <span class="comment">//参数3 flags则是指定绑定时是否自动创建Service。0代表不自动创建、BIND_AUTO_CREATE则代表自动创建</span></span><br><span class="line">    bindService(intent,conn,Service.BIND_AUTO_CREATE);</span><br><span class="line">    <span class="comment">//调用服务中的方法，最好先判断是否为null</span></span><br><span class="line">    mService.doSomeThing();</span><br><span class="line">    <span class="comment">//解除绑定</span></span><br><span class="line">    unbindService(conn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Message"><a href="#2-Message" class="headerlink" title="2.Message"></a>2.Message</h3><p><strong>service与不同进程通信（IPC）</strong> 。</p><p>步骤如下：</p><ol><li>Service实现一个Handler，接收客户端每个调用的回调</li><li>用Handler创建Messenger对象</li><li>用Messenger创建IBinder对象，并通过onBind()返回客户端</li><li>客户端使用IBinder实例化Messenger，用其将Message对象发送给Service</li><li>Service在Handler接收并处理Message</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MSG_WHAT = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//创建Handler接收、处理客户端msg</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">IncomingHanler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">      <span class="comment">//do sth with msg...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Messenger messenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> IncomingHanlder());</span><br><span class="line">  <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> messenger.getBinder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="comment">//onCreate()方法中：</span></span><br><span class="line">mConnection = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span></span>&#123;</span><br><span class="line">    Messenger mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//给服务发消息</span></span><br><span class="line">Message msg = Message.obtain(<span class="keyword">null</span>,MessengerService.MSG_WHAT,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">mService.send(msg);</span><br></pre></td></tr></table></figure><p>注意service要在不同的进程中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AndroidMinafast.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".messenger.MessengerService"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">":remote"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务与客户端双向通信</strong></p><p>服务端，修改IncomingHandler，回复客户端消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncomingHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//回复消息</span></span><br><span class="line">    Messenger client = msg.replyTo;</span><br><span class="line">    Message replyMsg = Message.obtain(<span class="keyword">null</span>,MessengerService.MSG_WHAT);</span><br><span class="line">    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">    bundle.putString(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line">    replyMsg.setData(bundle);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      client.send(replyMsg);</span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端，增加Messenger和Handler处理服务端回复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerReplyMsgHandler</span> <span class="keyword">extends</span> <span class="title">Hanlder</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收服务端返回的msg</span></span><br><span class="line">  <span class="comment">//do sth ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Messenger mRecevierReplyMsg = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> RecyclerReplyMsgHandler());</span><br></pre></td></tr></table></figure><p>此外，在发送消息是需要将接收服务端回复的Messenger通过Message的replyTo传递给服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create msg...</span></span><br><span class="line">msg.replyTo = mRecevierReplyMsg;</span><br><span class="line"><span class="comment">//send msg...</span></span><br></pre></td></tr></table></figure><h3 id="3-AIDL"><a href="#3-AIDL" class="headerlink" title="3.AIDL"></a>3.AIDL</h3><p>一般不会使用</p><h1 id="绑定服务时的注意事项"><a href="#绑定服务时的注意事项" class="headerlink" title="绑定服务时的注意事项"></a>绑定服务时的注意事项</h1><ul><li>多个客户端可连接一个服务端，只有第一个客户端绑定时才会调用服务<code>onBind()</code>方法来检索IBinder，此后无需调用就可将同一个IBinder传递给其他客户端</li><li><code>bindService()</code> 绑定服务是异步进行的</li><li>一般在activity可见生命周期内绑定-取消服务，不要在<code>onResume()</code>、<code>onPause()</code>期间执行绑定/解绑</li></ul><h1 id="Service绑定和启动转换"><a href="#Service绑定和启动转换" class="headerlink" title="Service绑定和启动转换"></a>Service绑定和启动转换</h1><table><thead><tr><th>顺序</th><th>结果</th></tr></thead><tbody><tr><td>先绑定后启动service</td><td>启动service</td></tr><tr><td>先启动后绑定service</td><td>会绑定宿主，但是宿主死后仍按照启动service方式存活</td></tr></tbody></table><h1 id="前台服务和通知"><a href="#前台服务和通知" class="headerlink" title="前台服务和通知"></a>前台服务和通知</h1><blockquote><ul><li><strong>startForeground(int id, Notification notification)</strong><br>该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。</li><li><strong>stopForeground(boolean removeNotification)</strong><br>该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true为删除。 注意该方法并不会停止服务。 但是，如果在服务正在前台运行时将其停止，则通知也会被删除。</li></ul></blockquote><p>文章参考：</p><p><a href="http://blog.csdn.net/javazejian/article/details/52709857#t3" target="_blank" rel="noopener">关于Android Service真正的完全详解，你需要知道的一切 - CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>之前发布的几个App</title>
      <link href="/blog/posts/1a589649/"/>
      <url>/blog/posts/1a589649/</url>
      
        <content type="html"><![CDATA[<p>在之前学习android的过程中，跟着教程做了几个app，虽然随着使用的api的失效，大多数应用如今已经不能正常使用了，但是作为初入编程的一点点小纪念，还是为他们写一个索引文章，至少能够晚一些消寂于这广阔的数据海洋中。</p><h1 id="NiceNews"><a href="#NiceNews" class="headerlink" title="NiceNews"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/05/NiceNews/">NiceNews</a></h1><p>Posted on 2016-05-30</p><p>NieceNews我制作的第二款APP，一个实时新闻软件。</p><p><img src="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/05/NiceNews/images/icon.png" alt="NiceNews"></p><h1 id="IWeather"><a href="#IWeather" class="headerlink" title="IWeather"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/IWeather/">IWeather</a></h1><p>Posted on 2016-07-16</p><p>IWeather，我的第三个Android应用，一个天气预报APP。</p><p><img src="http://jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/IWeather/images/1.png" alt="IWeather"></p><h1 id="2048"><a href="#2048" class="headerlink" title="2048"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/2048/">2048</a></h1><p>Posted on 2016-07-21</p><p>2048，我的第四个Android应用，同时也是我的第一款游戏APP。</p><p><img src="http://jixiaoyong.github.io/blogbackup/blog_2016To2017/2016/07/2048/images/1.png" alt="2048"></p><h1 id="I看知乎"><a href="#I看知乎" class="headerlink" title="I看知乎"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/I%E7%9C%8B%E7%9F%A5%E4%B9%8E/">I看知乎</a></h1><p>Posted on 2016-07-24   | </p><p>i看知乎，我的第五个Android应用。</p><p><img src="http://jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/I%E7%9C%8B%E7%9F%A5%E4%B9%8E/images/1.png" alt="logo"></p><p>学习的过程需要不断的重复，更需要有条理的总结，我会把平时学习的心得体会，经验，以及无聊时瞎琢磨得出来的稀奇古怪的想法放到这里，主要是为了自己能够在学习的过程中有计划的总结学习到的知识，同时也方便之后查阅。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android常用知识</title>
      <link href="/blog/posts/9dc94196/"/>
      <url>/blog/posts/9dc94196/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义view"><a href="#自定义view" class="headerlink" title="自定义view"></a>自定义view</h1><ul><li><p>画矩形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawRect(left, top, right, bottom, paint);</span><br></pre></td></tr></table></figure><p>其中：<code>left/top</code> 是该view的左上顶点到父容器左边和顶端的距离<code>right/bottom</code> 是该view的右下顶点到父容器左边和顶端的距离</p></li><li><p>写字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rects bounds = <span class="keyword">new</span> Rects();</span><br><span class="line">mPaint.setColor(mColorText);</span><br><span class="line">mPaint.setTextSize(mSizeText);</span><br><span class="line">mPaint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">mPaint.getTextBounds(text, <span class="number">0</span>, text.length(), bounds);</span><br><span class="line"><span class="keyword">float</span> x =  width / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">float</span> y = -bounds.centerY() + childHeight / <span class="number">2</span> + i * childHeight;</span><br><span class="line">canvas.drawText(text, x, y, mPaint);</span><br></pre></td></tr></table></figure><p>​</p><p>当text为居中对齐时，<code>centerX</code>和<code>centerY</code>是该字的正中心，以text的左下角为原点，故而<code>centerY</code>为<code>-sizeOfText/2</code>。</p></li></ul><ul><li><p>自定义属性</p><p><strong>attrs.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"LetterIndex"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"color_text"</span> <span class="attr">format</span>=<span class="string">"color"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"color_index_bg"</span> <span class="attr">format</span>=<span class="string">"color"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>**MyView.java**</code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AttributeSet attrs = ***;</span><br><span class="line">TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.LetterIndex);</span><br><span class="line">mColorText = arr.getColor(R.styleable.LetterIndex_color_text, <span class="number">0x52000000</span>);</span><br></pre></td></tr></table></figure><p>注意默认值可以为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">​**main_act.xml**</span><br><span class="line">```xml</span><br><span class="line">&lt;com.text.MyView</span><br><span class="line">***</span><br><span class="line">app:color_text = &quot;#003903&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><ul><li>对外预留onClick监听接口<br><strong>MyView.java</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">    <span class="keyword">private</span> onIndexClickListener mClickListener;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">onIndexClickListener</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onIndexClick</span><span class="params">(<span class="keyword">int</span> chooseId)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnIndexClickListener</span><span class="params">(onIndexClickListener listener)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mOnIndexClick = listener;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用，在需要监听的动作发生时调用该方法</span></span><br><span class="line">    mClickListener.onIndexClick(mChooseId);</span><br></pre></td></tr></table></figure></li></ul><p>​    <strong>MainAct.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mView.setOnIndexClickListener(<span class="keyword">new</span> LetterIndex.onIndexClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onIndexClick</span><span class="params">(<span class="keyword">int</span> chooseId)</span> </span>&#123;</span><br><span class="line">               Log.d(<span class="string">"TAG"</span>, <span class="string">"onIndexClick: chooseid is"</span> + chooseId);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p><ul><li>RecyclerView滑动事件<br><code>manager.scrollToPositionWithOffset(n, 0);</code><br><code>n</code>为要滑到顶端的<code>position</code></li></ul><h1 id="创建菜单"><a href="#创建菜单" class="headerlink" title="创建菜单"></a>创建菜单</h1><ul><li><p>创建对应资源</p><p>menu/menu_main.xml</p></li><li><p>对应activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override fun <span class="title">onCreateOptionsMenu</span><span class="params">(menu: Menu?)</span>: Boolean </span>&#123;</span><br><span class="line">    menuInflater.inflate(R.menu.menu_main,menu)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateOptionsMenu(menu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">override fun <span class="title">onOptionsItemSelected</span><span class="params">(item: MenuItem?)</span>: Boolean </span>&#123;</span><br><span class="line"></span><br><span class="line">    when(item!!.itemId) &#123;</span><br><span class="line">        <span class="comment">//do sth...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android控件组</title>
      <link href="/blog/posts/3b69424a/"/>
      <url>/blog/posts/3b69424a/</url>
      
        <content type="html"><![CDATA[<p>这几天的工作中用到了控件组来实现复杂布局，效果不错，记录下来备用。</p><h1 id="1-定义控件组布局xxx-layout-xml"><a href="#1-定义控件组布局xxx-layout-xml" class="headerlink" title="1. 定义控件组布局xxx_layout.xml"></a>1. 定义控件组布局xxx_layout.xml</h1><p>在这里定义要使用的控件组布局，这里的布局决定了布局显示的样子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">"10dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-新建自定义属性文件attr-xml（可选）"><a href="#2-新建自定义属性文件attr-xml（可选）" class="headerlink" title="2.新建自定义属性文件attr.xml（可选）"></a>2.新建自定义属性文件attr.xml（可选）</h1><ul><li><p>在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- MSearchBar表明是给该控件使用的自定义属性 --&gt;</span><br><span class="line">    &lt;declare-styleable name=&quot;MSearchBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 以下为示例，可以根据需求增减 --&gt;</span><br><span class="line">        &lt;attr name=&quot;textColor&quot; format=&quot;color&quot; /&gt;</span><br><span class="line">        &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p></li><li><p>在该自定义控件的类xxx.java中，通过如下语句获取从用户使用时赋给这些属性的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar);</span><br><span class="line"><span class="keyword">float</span> textSize = array.getDimension(R.styleable.MSearchBar_textSize, <span class="number">13</span>);</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>用户动态给这些属性赋值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:textColor</span>=<span class="string">"@color/colorPrimaryDark"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，这里写的是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ​</span><br><span class="line"></span><br><span class="line"># 3. 新建组合控件的类XXX.java</span><br><span class="line"></span><br><span class="line">* 新建XXX.java，继承自布局文件的父布局LinearLayout</span><br><span class="line"></span><br><span class="line">* 更改参数少的构造方法的```super(a1,a2,a3)```为```this(a1,a2,a3)```，其中```this()```中的参数个数为参数最多的构造方法的参数数。</span><br><span class="line"></span><br><span class="line">  **注意** ：一定要做这一步，否则在使用该自定义控件组时，新建该类的对象会提示出错</span><br><span class="line"></span><br><span class="line">* 在最终会被调用的构造方法里面将xml里面定义的布局加载进来：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  //注意三个参数：布局文件：R.layout.weight_group_layout, root：this,是否依附到root：true</span><br><span class="line">  //必须有前两个参数，否则控件的宽高等会有异常</span><br><span class="line">  View view = LayoutInflater.from(context).inflate(R.layout.weight_group_layout, this,true);</span><br></pre></td></tr></table></figure></p></li><li><p>使用自定义属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MSearchBar</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//do sth</span></span><br><span class="line">  </span><br><span class="line">        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar);</span><br><span class="line">        <span class="keyword">float</span> textSize = array.getDimension(R.styleable.MSearchBar_textSize, <span class="number">13</span>);</span><br><span class="line">        editText.setTextSize(textSize);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>给控件组内部控件添加点击事件监听：</p><ul><li><p>xxx.java 要实现点击事件监听接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSearchBar</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义接口，供使用xxx.java类时实现对监听事件的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImgLeftOnClickListener</span><span class="params">(OnImgClickListener listener)</span></span>&#123;</span><br><span class="line">    listenerL = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnImgClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> OnImgClickListener listenerL;</span><br></pre></td></tr></table></figure></li><li><p>对要监听点击事件的控件设置监听，并调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">//在构造方法等地方设置监听事件</span><br><span class="line">imageViewLeft.setOnClickListener(this);</span><br><span class="line"></span><br><span class="line">//在xxx.java中重写onClick()方法</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        switch (view.getId()) &#123;</span><br><span class="line">            //ImageLeft</span><br><span class="line">            case R.id.imageView:</span><br><span class="line">                if (listenerL != null) &#123;</span><br><span class="line">                    listenerL.onClick();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            //imageRight</span><br><span class="line">            case R.id.imageView2:</span><br><span class="line">                if (listenerR != null) &#123;</span><br><span class="line">                    listenerR.onClick();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></li></ul></li></ul><h1 id="4-使用自定义控件组xxx-java"><a href="#4-使用自定义控件组xxx-java" class="headerlink" title="4. 使用自定义控件组xxx.java"></a>4. 使用自定义控件组xxx.java</h1><ul><li><p>在布局文件main_activity.xml中添加该控件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/search_bar"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:textColor</span>=<span class="string">"@color/colorPrimaryDark"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>在java中使用该控件，设置监听事件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MSearchBar searchBar = (MSearchBar) findViewById(R.id.search_bar);</span><br><span class="line">searchBar.setImgLeftOnClickListener(<span class="keyword">new</span> MSearchBar.OnImgClickListener() &#123;</span><br><span class="line">        <span class="meta">@SuppressLint</span>(<span class="string">"WrongConstant"</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Click on Left"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="5-效果预览"><a href="#5-效果预览" class="headerlink" title="5.效果预览"></a>5.效果预览</h1><p><img src="http://upload-images.jianshu.io/upload_images/120748-48d0cbbf03ded7f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果预览"></p><h1 id="6-源码"><a href="#6-源码" class="headerlink" title="6.源码"></a>6.源码</h1><p>demo的github链接:<a href="https://github.com/jixiaoyong/my_application_on_deepin/tree/master/weightgroup" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android自定义View实现联系人列表</title>
      <link href="/blog/posts/a2c96aac/"/>
      <url>/blog/posts/a2c96aac/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义的view"><a href="#自定义的view" class="headerlink" title="自定义的view"></a>自定义的view</h1><ul><li>LetterIndex.java extends View</li><li>ContactsListView.java extends RecyclerView<br>#分析</li><li>联系人列表有两个要点<ul><li>字母导航栏<br>通过自定义View画出26个字母，设置滑动监听事件，根据上下滑动的距离判断当前选中的字母，并相应更新界面。</li><li>列表中的字母标题<br>针对item中的联系人姓名首字母对应的tag作比较，若与前一个相同则不显示title，否则显示。</li></ul></li><li>事件联动<ul><li>当滑动字母导航栏时，除了处理本身的变化外，还要留出接口，以便其他控件获取当前选中的字母。</li><li>联系人列表滑动时，除了处理本身变化外，同样要留出接口以便获取当前置顶的item对应的字母</li><li>字母导航栏要留出方法，以便其他控件指定选中的字母，并更新界面<br>#具体代码<br><strong>ContactsListView.java</strong><br>重写该类主要是为了实现ItemDecoration根据不同的item变化，同时可以从xml布局文件中获取ItemDecoration的自定义属性。<br>主要代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ContactsListView(Context context) &#123;</span><br><span class="line">    this(context, null, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ContactsListView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ContactsListView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">    super(context, attrs, defStyle);</span><br><span class="line">    mTypeArray = context.obtainStyledAttributes(attrs, R.styleable.MyRecyclerDecoration);</span><br><span class="line">    mContext = context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>故而在其内部自定义了一个继承自ItemDecoratio得静态内部类Decorationn类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public Decoration(List&lt;String&gt; data)&#123;</span><br><span class="line">//获取要显示的联系人数据对应的英文tag集合</span><br><span class="line">//初始化各种自定义属性</span><br><span class="line">//例如颜色：mColorLetterText = mTypeArray.getColor(R.styleable.MyRecyclerDecoration_color_letter_text, 0xff152648);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">        public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state)&#123;</span><br><span class="line">//画出各个导航title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">        public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">//画出置顶的导航title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State</span><br><span class="line">                state) &#123;</span><br><span class="line">//判断是否画出导航title</span><br><span class="line"> super.getItemOffsets(outRect, view, parent, state);</span><br><span class="line">            int position = ((RecyclerView.LayoutParams) (view.getLayoutParams())).getViewAdapterPosition();</span><br><span class="line"></span><br><span class="line">            if (position != -1) &#123;</span><br><span class="line">                String text = mDatas.get(position).substring(0, 1).toUpperCase();</span><br><span class="line">                if (position == 0) &#123;</span><br><span class="line">                    outRect.set(0, mTitleHeight, 0, 0);</span><br><span class="line">                &#125; else if (text != null &amp;&amp; !text.equals(mDatas.get(position - 1).substring(0, 1).toUpperCase())) &#123;</span><br><span class="line">                    outRect.set(0, mTitleHeight, 0, 0);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    outRect.set(0, 0, 0, 0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawText(Canvas canvas, float left, float right, View child, String text) &#123;</span><br><span class="line">//画出文字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>LetterIndex.java</strong><br>该类用来画出字母导航栏，并且提供方法获取/设置当前选中的字母<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface onIndexClickListener &#123;</span><br><span class="line">       void onIndexClick(int chooseId);</span><br><span class="line">       void onActionUp();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setOnIndexClickListener(onIndexClickListener listener) &#123;</span><br><span class="line">       this.mClickListener = listener;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setChooseId(int chooseId) &#123;</span><br><span class="line">       if (chooseId &gt;= 0 &amp;&amp; chooseId &lt; mIndexTexts.length) &#123;</span><br><span class="line">           mChooseId = chooseId;</span><br><span class="line">           invalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>然后重写<figure class="highlight plain"><figcaption><span>event)```方法，在ACTION_DOWN、ACTION_MOVE、ACTION_UP时调用对应的方法即可。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">重写onDraw()方法，画出对应的界面</span><br></pre></td></tr></table></figure></p><p>   @Override<br>    protected void onDraw(Canvas canvas) {<br>        super.onDraw(canvas);<br>        int height = getHeight() - getPaddingTop() - getPaddingBottom();<br>        float width = getWidth();<br>        //childHeight 是每一个字母所在单元的高度<br>        float childHeight = (float) height / mIndexTexts.length;</p><pre><code>    //如果被点击了，就画出背景    if (isClick) {        mPaint.setColor(mColorIndexBg);        canvas.drawRect(0, 0, width, height, mPaint);    }    Rect bounds = new Rect();    mPaint.setTextSize(mSizeText);    mPaint.setTextAlign(Paint.Align.CENTER);    for (int i = 0; i &lt; mIndexTexts.length; i++) {        String text = mIndexTexts[i];        mPaint.setColor(mColorText);        //在被选中的字后面画一个圆，并改变字的颜色        if (i == mChooseId) {            mPaint.setColor(mColorChooseTextBg);            canvas.drawCircle(width / 2, childHeight / 2 + i * childHeight,                    mSizeText / 2 + 2, mPaint);            mPaint.setColor(mColorChooseText);        }        mPaint.getTextBounds(text, 0, text.length(), bounds);        //bounds里面保存着要画的字的一些属性，如x，y，centerX，centerY等，        //要注意 canvas.drawText（text,x,y,mpaint）中y并不是text的最低端，而是baseline。        float x = width / 2;        float y = -bounds.centerY() + childHeight / 2 + i * childHeight;        canvas.drawText(text, x, y, mPaint);    }}</code></pre><p><code>`</code></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源代码在我的Github，<a href="https://github.com/jixiaoyong/my_application_on_deepin/tree/master/contactsdemo/src/main" target="_blank" rel="noopener">点这里</a>可以找到。</p><h1 id="预览如下"><a href="#预览如下" class="headerlink" title="预览如下"></a>预览如下</h1><p><img src="http://upload-images.jianshu.io/upload_images/120748-183eea3cad2b42ac.gif?imageMogr2/auto-orient/strip" alt="预览.gif"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android开发常用设置</title>
      <link href="/blog/posts/1c56d6b9/"/>
      <url>/blog/posts/1c56d6b9/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h1><ul><li>国内较快的仓库：</li></ul><pre><code>maven {url&apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;}</code></pre><ul><li>RecyclerView添加依赖<br>注意RecyclerView的版本号要和当前工程中其他android.support包版本保持一致，否则虽然导入了对应的包，但是仍然无法正常使用。</li></ul><pre><code>compile &apos;com.android.support:recyclerview-v7:26+&apos;</code></pre><ul><li>设置：<br>自动添加依赖：insert imports on paste: None<br>自动删除无用依赖：Optimize imports on the fly</li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul><li>设置ndk环境变量 /etc/profile</li></ul><pre><code>#set ndk envNDKROOT=/home/jixiaoyong/AndroidDev/Sdk/ndk-bundleexport PATH=$NDKROOT:$PATH</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java中三种常用的排序方法</title>
      <link href="/blog/posts/1fd30f6e/"/>
      <url>/blog/posts/1fd30f6e/</url>
      
        <content type="html"><![CDATA[<p>今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。<br>以下示例皆为从小到大的排序</p><h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h1><p>每一次比较都可能要交换元素。<br>冒泡排序的思想是：<br>每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为m）放到后面，并将m与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。<br>在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。<br>依次类推，总共遍历n-1轮，即可完成排序。<br>具体代码如下：</p><pre><code> void bubble(int[] arr){    int temp;    for (int i = 0; i &lt; arr.length - 1; i++) {        for (int j = 0; j &lt; arr.length - i - 1; j++) {            if (arr[j] &gt; arr[j + 1]) {                temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            }        }    }    System.out.println(&quot;\n--bubble :&quot;);    for (int i = 0; i &lt; arr.length; i++) {        System.out.print(arr[i] + &quot; &quot;);    }}</code></pre><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h1><p>每次比较的时候不交换<br>选择排序的思想：<br>每次比较的时候找到的两个数中的较大值并记下其位置，等到当前一轮的遍历完成之后，将最后一个未排序元素与这一轮遍历找到的最大值交换<br>最多交换n-1次<br>代码如下：</p><pre><code>   void select(int[] arr){    for (int i = 0; i &lt; arr.length; i++) {        int maxIndex = 0;        int temp = 0;        for (int j = 1; j &lt; arr.length - i; j++) {            if (arr[maxIndex] &lt; arr[j]) {                maxIndex = j;            }        }        temp = arr[maxIndex];        arr[maxIndex] = arr[arr.length - i - 1];        arr[arr.length - i - 1] = temp;    }    System.out.println(&quot;\n--select :&quot;);    for (int i = 0; i &lt; arr.length; i++) {        System.out.print(arr[i] + &quot; &quot;);    }}</code></pre><h1 id="3-插入排序法"><a href="#3-插入排序法" class="headerlink" title="3.插入排序法"></a>3.插入排序法</h1><p>插入排序法思想：<br>将待排序的元素分为有序和无序两种，刚开始排序的时候假设只有第一个元素是有序的，其余n-1个元素都是无序的；<br>排序开始的时，将无序部分的一个元素（a）与有序部分的最后一个元素（b）进行比较，如果a&lt;b，则将a与b交换，再将a与下一个有序元素进行比较；否则，将a加到b后面，作为有序部分的最后一个元素。<br>接着再从无序部分取出一个元素与有序部分的元素依次比较，直达所有元素都为有序元素。<br>遍历n-1次<br>代码如下：</p><pre><code>    void insertSort(int[] arr){    for (int i = 1; i &lt; arr.length; i++) {        int instertValue = arr[i];        for (int j = i - 1; j &gt;= 0; j--) {            if (instertValue &lt; arr[j]) {                arr[j+1] = arr[j];                arr[j] = instertValue;            }else {                break;            }        }    }    /* 第二种表示形式    for (int i = 1; i &lt; arr.length; i++) {        int instertVal = arr[i];        int index = i - 1;        while (index &gt;= 0 &amp;&amp; instertVal &lt; arr[index]) {            arr[index + 1] = arr[index];            index--;        }        arr[index + 1] = instertVal;    }            */    System.out.println(&quot;\n--insertSort :&quot;);    for (int i = 0; i &lt; arr.length; i++) {        System.out.print(arr[i] + &quot; &quot;);    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Linux下配置Git，使用AndroidStudio同步工程到Github</title>
      <link href="/blog/posts/25db0a11/"/>
      <url>/blog/posts/25db0a11/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍了如何在 linux 环境下安装和配置 git 与 github ，并且使用 Android Studio 将本地的项目同步到 github 上面。</p><h1 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-gat install git</span><br></pre></td></tr></table></figure><h1 id="配置-git-和-github"><a href="#配置-git-和-github" class="headerlink" title="配置 git 和 github"></a>配置 git 和 github</h1><ul><li><p>创建 Github 账号</p></li><li><p>生成 ssh key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@youremail.com</span><br></pre></td></tr></table></figure></li><li><p>在 github 上面添加 ssh key</p></li></ul><p>进入 Account Settings –&gt; SSH Keys –&gt; Add SSH Key 添加 SSH Keys ：<br>名字起一个容易识别的名字，key 是生成的 <code>/home/username/.ssh/id_rsa.pub.</code> 中的内容，直接粘贴到指定位置就行</p><ul><li><p>测试 ssh key 是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul><p>提示如<code>You’ve successfully authenticated, but GitHub does not provide shell access</code>则说明成功连接 github</p><ul><li><p>配置 Github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot; //配置用户名</span><br><span class="line">git config --global user.email &quot;your email&quot; //配置email</span><br></pre></td></tr></table></figure></li></ul><h1 id="用-Android-Studio-同步工程到-Github"><a href="#用-Android-Studio-同步工程到-Github" class="headerlink" title="用 Android Studio 同步工程到 Github"></a>用 Android Studio 同步工程到 Github</h1><ul><li><p>启动android studio</p><p>进入<code>android studio/bin</code>，终端输入<code>./studio.sh</code></p></li><li><p>选择 <code>VCS ---&gt; Import into Version Control --&gt; Share Project on Github</code></p></li></ul><p>第一次进入会要求输入 github 的账号和密码 按照要求输入即可<br>此后还会要求你输入一个本地密码，当下次同步的时候需要输入<br>之后就进入到选择同步的仓库，新建一个仓库，开始同步就可以了</p><p><strong>到这里就顺利的在 Android Studio 上面将工程同步到 Github 上面了</strong></p><hr><p><strong>以下为原文提到的其他方法，摘录如下，以备后用：</strong></p><h1 id="利用Git从本地上传到GitHub"><a href="#利用Git从本地上传到GitHub" class="headerlink" title="利用Git从本地上传到GitHub"></a>利用Git从本地上传到GitHub</h1><p>第一步： 进入要所要上传文件的目录</p><p>输入命令 <code>git init</code></p><p>第二步： 创建一个本地仓库 origin</p><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:yourName/yourRepo.git</span><br></pre></td></tr></table></figure><p><code>youname</code>是你的GitHub的用户名，<code>yourRepo</code>是你要上传到GitHub的仓库</p><p>第三步： 比如你要添加一个文件xxx到本地仓库，使用命令 <code>git add xxx</code>，可以使用 <code>git add .</code> 自动判断添加哪些文件</p><p>然后把这个添加提交到本地的仓库，使用命令 <code>git commit -m</code>说明这次的提交</p><p>最后把本地仓库origin提交到远程的GitHub仓库，使用命令 <code>git push origin master</code></p><h1 id="从GitHub克隆项目到本地"><a href="#从GitHub克隆项目到本地" class="headerlink" title="从GitHub克隆项目到本地"></a>从GitHub克隆项目到本地</h1><p>第一步： 到GitHub的某个仓库，然后复制右边的有个<code>HTTPS clone url</code></p><p>第二步： 回到要存放的目录下，使用命令 <code>git clone https://github.com/chenguolin/scrapy.git</code>，这里的url只是一个例子</p><p>第三步： 如果本地的版本不是最新的，可以使用命令 <code>git fetch origin</code>，origin是本地仓库</p><p>第四步： 把更新的内容合并到本地分支，可以使用命令 <code>git merge origin/master</code></p><p>如果你不想手动去合并，那么你可以使用：<br><code>git pull &lt;本地仓库&gt; master</code> // 这个命令可以拉去最新版本并自动合并</p><h1 id="GitHub的分支管理"><a href="#GitHub的分支管理" class="headerlink" title="GitHub的分支管理"></a>GitHub的分支管理</h1><ul><li>创建</li></ul><p>1 创建一个本地分支： <code>git branch &lt;新分支名字&gt;</code></p><p>2 将本地分支同步到GitHub上面： <code>git push &lt;本地仓库名&gt; &lt;新分支名&gt;</code></p><p>3 切换到新建立的分支： <code>git checkout &lt;新分支名&gt;</code></p><p>4 为你的分支加入一个新的远程端： <code>git remote add &lt;远程端名字&gt; &lt;地址&gt;</code></p><p>5 查看当前仓库有几个分支: <code>git branch</code></p><ul><li>删除</li></ul><p>1 从本地删除一个分支： <code>git branch -d &lt;分支名称&gt;</code></p><p>2 同步到GitHub上面删除这个分支： <code>git push &lt;本地仓库名&gt; :&lt;GitHub端分支&gt;</code></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这篇文章是我今天在 linux 下安装 git ，上传工程到 github 上面时的步骤的总结，大部分内容都参考/摘录自下面这篇文章，感谢原作者的分享，原文信息及链接如下：</p><blockquote><p>Linux下Git和GitHub使用方法总结<br>[日期：2014-03-07] 来源：Linux社区 作者：chenguolin<br><a href="http://www.linuxidc.com/Linux/2014-03/97821.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-03/97821.htm</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>linux下配置JDK和AndroidStudio开发环境</title>
      <link href="/blog/posts/ca532ade/"/>
      <url>/blog/posts/ca532ade/</url>
      
        <content type="html"><![CDATA[<h1 id="下载-JDK-并解压"><a href="#下载-JDK-并解压" class="headerlink" title="下载 JDK 并解压"></a>下载 JDK 并解压</h1><ul><li>到官网下载 jdk</li><li>下载到的 JDK 文件解压</li></ul><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>管理员权限进入 etc/environment 写入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=&quot;JDK主目录的绝对路径&quot;</span><br></pre></td></tr></table></figure><h1 id="配置-alternatives"><a href="#配置-alternatives" class="headerlink" title="配置 alternatives"></a>配置 alternatives</h1><p>打开终端执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install  /usr/bin/java java  JDK主目录的绝对路径/bin/java 300</span><br><span class="line"></span><br><span class="line">sudo update-alternatives --install  /usr/bin/javac javac  JDK主目录的绝对路径/bin/javac 300</span><br></pre></td></tr></table></figure><p>到这里 JDK 的环境就配置好了</p><h1 id="运行-Android-Studio"><a href="#运行-Android-Studio" class="headerlink" title="运行 Android Studio"></a>运行 Android Studio</h1><p>进入 android studio/bin 目录下，打开终端，</p><p>输入 <code>./studio.sh</code></p><p>到这里，就可以正常运行 android studio 了</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>AppWidget的使用之PendingIntent</title>
      <link href="/blog/posts/fcfc830b/"/>
      <url>/blog/posts/fcfc830b/</url>
      
        <content type="html"><![CDATA[<p>这几天学习 AppWidget ，很简单的组件却花费了不少功夫，今天对 PendingIntent 的用法做了一些简单的整理。</p><p><strong>PendingIntent</strong></p><blockquote><p>PandingIntent 就像是一个设计好的处理预案，当达到某个特定条件时，便会调用该 Intent 所指定动作（打开服务，Activity或者发送广播）。</p><p>这里使用该方法在 AppWidget 里面为按钮添加监听事件，当按钮被点击的时候触发相应的动作</p></blockquote><p>AppWidget 和应用程序不再同一个进程当中，而是在 HomeScreen 上面执行,所以不能直接为 AppWidget 中的 Button 添加监听事件，需要用 <code>remoteViews.setPendingIntent(R.id.widget_button,pendingIntent);</code>意思是当按下按钮的时候 pendingIntent 中的 Intent 就会执行</p><p>PendingIntent 当某个事件出现之后才会执行</p><p>RemoteViews对象 代表了一系列的 View 对象，和主程序不在同一个进程为 AppWidget 控件绑定处理器</p><p><strong>流程概述：</strong></p><ul><li><p>添加 appwidget_provider_info.xml 在 res/xml 下新建 appwidget_provider_info.xml</p><ul><li>描述 AppWidget 的基本信息如最小高度、宽度等，还有就是该挂件的布局文件</li></ul></li><li><p>在 res/layout 下面为该挂件设置具体的布局样式</p><ul><li>向 AppWidget 的布局文件中添加一个 Button</li><li>向 AppWidget 的布局文件中添加一个 TextView</li></ul></li><li><p>新建 MyAppWidget.java 继承自 AppWidgetProvider</p><p>在该类的 onUpdate() 方法中为 Button 设置、添加监听事件</p><ul><li>建立一个 Intent 对象</li><li>用该 Intent 对象创建一个 PendingIntent 对象</li><li>创建一个 RemoteViews 对象</li><li>用该 RemoveViews 对象为 按钮绑定事件处理器</li><li>更新按钮</li></ul></li><li><p>注册事件</p></li><li><p>备注：要是为 AppWidget 中的 Button 设置的事件是打开一个 TargetActivity ，还需要添加一个 TargetActivity 类和对应的布局文件</p></li></ul><p><strong>以下是代码</strong></p><ul><li>appwidget_provider_info.xml</li></ul><p>这个布局文件是 AppWidget 的信息</p><p>描述了 AppWidget 的最小高，最小宽以及它的布局文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;appwidget-provider</span><br><span class="line">    android:minHeight=&quot;200dp&quot;</span><br><span class="line">    android:minWidth=&quot;300dp&quot;</span><br><span class="line">    android:initialLayout=&quot;@layout/app_widget&quot;</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">&lt;/appwidget-provider&gt;</span><br></pre></td></tr></table></figure><ul><li>app_widget.xml</li></ul><p>这个布局文件是 Widget 在桌面上显示的样式</p><p>定义了 AppWidget 中各个组件及其样式</p><p>其中 Button 用来响应点击事件，加入 TargetActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;200dp&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;hello,world!&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=&quot;@+id/app_widget_btn&quot;</span><br><span class="line">        android:layout_width=&quot;200dp&quot;</span><br><span class="line">        android:layout_height=&quot;150dp&quot;</span><br><span class="line">        android:background=&quot;#ff00ff&quot;</span><br><span class="line">        android:text=&quot;this is my app widget button&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><ul><li>target_activity.xml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;50sp&quot;</span><br><span class="line">        android:background=&quot;#00ff00&quot;</span><br><span class="line">        android:text=&quot;\n hello,welcome to target activity!&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><ul><li>MyAppWidget.java</li></ul><p>主要是修改了 update() 方法：</p><p>定义了一个预先设定的动作—- Intent 对象；</p><p>利用该 Intent 读写，创建一个 PendingIntent 对象；</p><p>创建一个 RemoteView 对象，并为按钮绑定监听事件</p><p>刷新 AppWidget。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class MyAppWidget extends AppWidgetProvider &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onReceive(context, intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onUpdate(Context context, AppWidgetManager appWidgetManager,</span><br><span class="line">                         int[] appWidgetIds) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class="line"></span><br><span class="line">        //appWidgetIds 每一次向屏幕添加 AppWidget 的时候都会增加一个唯一的 appWidget 的 Id</span><br><span class="line">        for(int i = 0; i &lt; appWidgetIds.length;i++)&#123;</span><br><span class="line">          //创建一个 Intent 对象</span><br><span class="line">            Intent intent = new Intent(context,TargetActivity.class);</span><br><span class="line">            //创建一个 PendingIntent 对象</span><br><span class="line">            PendingIntent pendingIntent = PendingIntent.getActivity(context,0,intent,0);</span><br><span class="line">            // remoteViews 代表 AppWidget 上所有的控件</span><br><span class="line">            RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget);</span><br><span class="line">            //为按钮绑定事件处理器</span><br><span class="line">            /*</span><br><span class="line">            * 参1，指定被绑定处理器的控件id</span><br><span class="line">            * 参2，指定事件发生时会被执行的 PendingIntent</span><br><span class="line">             */</span><br><span class="line">            remoteViews.setOnClickPendingIntent(R.id.app_widget_btn,pendingIntent);</span><br><span class="line">            //更新 AppWidget ，参1是用于指定被更新 appWidget 的ID</span><br><span class="line">            appWidgetManager.updateAppWidget(appWidgetIds[i],remoteViews);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDeleted(Context context, int[] appWidgetIds) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onDeleted(context, appWidgetIds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onEnabled(Context context) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onEnabled(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDisabled(Context context) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onDisabled(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TargetActivity.java</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TargetActivity extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.target_activity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AndroidManifest.xml</li></ul><p>在 AndroidManifest.xml 中注册 TargetActivity 和 MyAppWidget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;application&gt;</span><br><span class="line">...</span><br><span class="line">    &lt;activity android:name=&quot;.TargetActivity&quot;&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 注意这里注册了一个 MyAppWidget 接收数据--&gt;</span><br><span class="line">    &lt;receiver android:name=&quot;.MyAppWidget&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">        &lt;meta-data</span><br><span class="line">            android:name=&quot;android.appwidget.provider&quot;</span><br><span class="line">            android:resource=&quot;@xml/appwidget_provider_info&quot;/&gt;</span><br><span class="line">    &lt;/receiver&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>hexo+github=blog</title>
      <link href="/blog/posts/f7965978/"/>
      <url>/blog/posts/f7965978/</url>
      
        <content type="html"><![CDATA[<p><code>Hello World！</code></p><p>一直以来，为了有一个合适的在线写字的地方，我尝试过许多种工具，从最初的 QQ 空间开始，到各种门户网站的博客，再到自己开始尝试搭建博客，一路奔忙，门户网站的限制太多，自己搭建的博客又时常由于空间提供商的各种问题而无法访问。许多时候一个平台只能使用一段时间，这样子颠颠撞撞大概也有五六年的时间了。</p><p>一直听说 github 这个平台的各种优点，尤其是可以作为稳定而免费的空间托管博客最令我心动，但是之前多次尝试不得其道，终以失败告终。最近在学习 Android 语言的时候，又再次用起了 github ，不过这次是用它来存储代码。不得不承认，使用 github 来控制程序版本真是一件令人愉悦的事件。</p><p>机缘巧合，因为需要将学习过程中的一些笔记，心得总结找个地方整理，显然单纯的使用 github 并不是一个好办法，而其他的平台的博客限制又太多，于是又尝试用 github 搭建一个博客，虽然对这些知识并不是很熟悉，但误打误撞竟然也成功的搭建好了博客。下面就把整个建站的过程大概梳理一下，以便以后查看。</p><h1 id="准备软件"><a href="#准备软件" class="headerlink" title="准备软件"></a>准备软件</h1><ul><li>下载软件：</li><li>node 客户端</li><li>git</li><li>github windows 客户端</li></ul><h1 id="装-git-和-github-windows-客户端"><a href="#装-git-和-github-windows-客户端" class="headerlink" title="装 git 和 github windows 客户端"></a>装 git 和 github windows 客户端</h1><ul><li>安装 git:<br>git 安装时按照默认的配置，一路点击确定就可以。</li><li>安装 github<br>github 安装分为两种：<br>一种是直接用官网的安装包，在安装的时候需要从网上下载资料，受网速限制，这种方法很慢，而且容易出错；<br>另一种直接找一份github离线安装包解压到本地即可使用，我就是使用后一种方法。</li></ul><h1 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h1><ul><li>安装 node 客户端<br>下载并安装 node ,我使用的版本是 node-v5.7.1-x64。</li></ul><p>在安装完 git, node 之后</p><ul><li>win 键 + R 输入cmd 打开 windows 自带命令行，<br>输入git /npm<br>之后，如果显示出帮助信息而非不是内部或外部命令，也不是可运行的程序或批处理文件这样的提示，就说明 git 和 node 已经配置好了环境变量，否则就需要手动配置。</li></ul><h1 id="配置环境变量方法："><a href="#配置环境变量方法：" class="headerlink" title="配置环境变量方法："></a>配置环境变量方法：</h1><ul><li>此电脑 –&gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量</li><li>找到用户环境变量 –&gt; path ，如下图<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/BaiduShurufa_2016-4-23_17-41-1.png"><img src="http://upload-images.jianshu.io/upload_images/120748-8aae916f0dfa3dd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改用户环境变量前"></a></li></ul><p>如下图修改<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/BaiduShurufa_2016-4-23_17-41-44.png"><img src="http://upload-images.jianshu.io/upload_images/120748-aa40a7e6049eeecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改系统环境变量后"></a></p><p>这样子 node 应该就可以正常使用了。</p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>打开命令行，全局安装 Hexo ,加 -g 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>查看 hexo 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blockquotehexo-cli: 1.0.1os: Windows_NT 10.0.14316 win32 x64http_parser: 2.6.2node: 5.7.1v8: 4.6.85.31uv: 1.8.0zlib: 1.2.8ares: 1.10.1-DEVicu: 56.1modules: 47openssl: 1.0.2g</span><br></pre></td></tr></table></figure><p>到这里 hexo 就在电脑上面安装好了。</p><h1 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h1><ul><li>进入存放 hexo 文件的目录下，创建一个文件夹blog存储 hexo 的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>然后进入这个文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure><p>启动 hexo 服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop</span><br></pre></td></tr></table></figure><p>打开本地地址：<a href="http://localhost:4000/，就可以看到本地搭建好的" target="_blank" rel="noopener">http://localhost:4000/，就可以看到本地搭建好的</a> hexo 博客了<br>这样子一个 hexo 博客就在本地搭建好了</p><h1 id="目录的解释："><a href="#目录的解释：" class="headerlink" title="目录的解释："></a>目录的解释：</h1><p>scaffolds 脚手架，也就是一个工具模板 scripts 写文件的js，扩展hexo的功能<br>source 存放博客正文内容<br>source/_drafts 草稿箱<br>source/_posts 文件箱<br>themes 存放皮肤的目录<br>themes/landscape默认的皮肤<br>_config.yml 全局的配置文件<br>db.json 静态常量</p><h1 id="一些-hexo-语句解释"><a href="#一些-hexo-语句解释" class="headerlink" title="一些 hexo 语句解释"></a>一些 hexo 语句解释</h1><p>help 查看帮助信息<br>init 创建一个hexo项目<br>migrate 从其他系统向hexo迁移<br>version 查看hexo的版本<br>–config参数，指定配置文件，代替默认的_config.yml<br>–debug参数，调试模式，输出所有日志信息<br>–safe参数，安全模式，禁用所有的插件和脚本<br>–silent参数，无日志输出模式</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p>命名为“新的文章”，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 新的文章</span><br></pre></td></tr></table></figure><p>hexo 默认生成 md 文件，新生成的文章在目录：.\blog\source_posts\新的文章.md ，对其进行相应的编辑即可<br>文章格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: 新的文章date: 2014-05-07 18:44:12updated : 2014-05-10 18:44:12permalink: abctags:- 开始- 我- 日记categories:- 日志- 第一天---</span><br></pre></td></tr></table></figure><h1 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h1><ul><li>注册并登录 github<br>进入 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> ，注册新账户，并且登录</li><li>新建 respositoy<br>在主页点击 New respositoy 新建一个名字为yourname.github.io<br> 的 respositoy；<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/1461473623662.jpg"><img src="http://upload-images.jianshu.io/upload_images/120748-fbb8934ceb25f0d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建 respositoy"></a></li><li>设置新建一个 github pages<br>进入仓库主页，选择settings –&gt; github pages –&gt; Launch automatic page generator ,按照默认的主题配置选择一个就好<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/BaiduShurufa_2016-4-24_12-59-58.png"><img src="http://upload-images.jianshu.io/upload_images/120748-c6e9742ee6120d8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Launch automatic page generator"></a></li><li>上传网站<br>对于 hexo 的相关配置：<br>打开_config.yml，修改以下部分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sitetitle: 季小勇的博客</span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">author: 季小勇</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone:# URL</span><br><span class="line">#If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; </span><br><span class="line">and root as &apos;/child/&apos;</span><br><span class="line">url: http://yoursite.github.io/</span><br><span class="line">root: http://yoursite.github.io/blog/</span><br></pre></td></tr></table></figure><p>此处由于我是将网站放在二级目录 ./blog/ 下面，所以 root 目录设置如此，使用的是绝对路径，否则在网页上显示的时候，css 等由于路径不对，加载可能会有问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy: type: git repo:https://github.com/yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure><p>这行语句是使用 hexo 自动 deploy 到 github 时的设置，如果正常的话，当用 hexo 对网站静态化处理后，再执行 hexo deploy 就可以自动部署到 github 上面了，但是我的电脑 git 或者 node 由于是不同时间装的期间还重装了几次系统，可能导致某些设置有误，所以在执行 hexo deploy 的时候一直提示有问题，故而采用另一种办法手动同步网站，这句话也可以不修改。</p><ul><li><p>用 hexo 对文章进行静态化处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li></ul><p>在blog\public目录下生成的 public 包含所有的静态化文件,此时，这个文件夹内所有的内容就是处理好的网站，将其发布到合适的空间就可以正常显示。<br>由于之前的 git 或者 node 配置有误，所以这时候采用手动同步网站:</p><ul><li>将上次在 github 上建立的项目yourname.github.io<br>同步到本地。<br>同步的方法很多，这里我选择的是使用 github 的 windows 客户端，比较方便：</li></ul><p>打开 github 客户端，找到项目，选择clone到本地即可。<br><img src="http://upload-images.jianshu.io/upload_images/120748-9100b83bb7ebf3b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步项目到本地"></p><p>之后打开同步的项目，确认当前的branch是master，否则同步之后网站不会显示。<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/1461461275758.jpg"><img src="http://upload-images.jianshu.io/upload_images/120748-620f9db488c0c384.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确认是 master"></a></p><p>在 github 同步的目录下找到上次建好的项目yourname.github.io ,进入之后，将上文获得到的public内容放入目标文件夹，我选择的是将博客放在子目录，所以这里新建了一个blog文件夹用于放置博客，所以就是将public<br>全部内容 放入./yourname.github.io/blog/目录下，这样子在网站上显示的时候，博客的网址就是<a href="http://yourname.github.io/blog/" target="_blank" rel="noopener">http://yourname.github.io/blog/</a></p><p>这样一个简单的利用 github 托管的 hexo 博客就搭建好了。<br>注：本文内容是根据我建立博客时的做法整理而成，其中有部分内容是参考网上的教程，文中引用的文字全部来自<a href="http://blog.fens.me/hexo-bootstarp-github/" target="_blank" rel="noopener">http://blog.fens.me/hexo-bootstarp-github/</a> ，此文对我帮助很大，感谢作者张丹(Conan)的分享。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/posts/4a17b156/"/>
      <url>/blog/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
