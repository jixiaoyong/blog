<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[之前发布的几个App]]></title>
    <url>%2Fblog%2F2018%2F01%2F%E4%B9%8B%E5%89%8D%E5%8F%91%E5%B8%83%E7%9A%84%E5%87%A0%E4%B8%AAApp%2F</url>
    <content type="text"><![CDATA[在之前学习android的过程中，跟着教程做了几个app，虽然随着使用的api的失效，大多数应用如今已经不能正常使用了，但是作为初入编程的一点点小纪念，还是为他们写一个索引文章，至少能够晚一些消寂于这广阔的数据海洋中。 NiceNewsPosted on 2016-05-30 NieceNews我制作的第二款APP，一个实时新闻软件。 IWeatherPosted on 2016-07-16 IWeather，我的第三个Android应用，一个天气预报APP。 2048Posted on 2016-07-21 2048，我的第四个Android应用，同时也是我的第一款游戏APP。 I看知乎Posted on 2016-07-24 | i看知乎，我的第五个Android应用。 学习的过程需要不断的重复，更需要有条理的总结，我会把平时学习的心得体会，经验，以及无聊时瞎琢磨得出来的稀奇古怪的想法放到这里，主要是为了自己能够在学习的过程中有计划的总结学习到的知识，同时也方便之后查阅。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android控件组]]></title>
    <url>%2Fblog%2F2017%2F09%2FAndroid%E6%8E%A7%E4%BB%B6%E7%BB%84%2F</url>
    <content type="text"><![CDATA[这几天的工作中用到了控件组来实现复杂布局，效果不错，记录下来备用。 1. 定义控件组布局xxx_layout.xml在这里定义要使用的控件组布局，这里的布局决定了布局显示的样子。 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="wrap_content" android:padding="10dp"&gt; &lt;ImageView ... /&gt; &lt;EditText .../&gt; &lt;ImageView ... /&gt; &lt;/LinearLayout&gt; 2.新建自定义属性文件attr.xml（可选） 在123456789101112131415```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;!-- MSearchBar表明是给该控件使用的自定义属性 --&gt; &lt;declare-styleable name=&quot;MSearchBar&quot;&gt; &lt;!-- 以下为示例，可以根据需求增减 --&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在该自定义控件的类xxx.java中，通过如下语句获取从用户使用时赋给这些属性的值： 12TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar);float textSize = array.getDimension(R.styleable.MSearchBar_textSize, 13); ​ 用户动态给这些属性赋值： 12345 &lt;cf.android666.jixiaoyong.weightgroup.weight.MSearchBar ... app:textColor="@color/colorPrimaryDark"&gt;&lt;/cf.android666.jixiaoyong.weightgroup.weight.MSearchBar&gt; 注意，这里写的是1234567891011121314151617 ​# 3. 新建组合控件的类XXX.java* 新建XXX.java，继承自布局文件的父布局LinearLayout* 更改参数少的构造方法的```super(a1,a2,a3)```为```this(a1,a2,a3)```，其中```this()```中的参数个数为参数最多的构造方法的参数数。 **注意** ：一定要做这一步，否则在使用该自定义控件组时，新建该类的对象会提示出错* 在最终会被调用的构造方法里面将xml里面定义的布局加载进来： ```java //注意三个参数：布局文件：R.layout.weight_group_layout, root：this,是否依附到root：true //必须有前两个参数，否则控件的宽高等会有异常 View view = LayoutInflater.from(context).inflate(R.layout.weight_group_layout, this,true); 使用自定义属性： 12345678910public MSearchBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //do sth TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar); float textSize = array.getDimension(R.styleable.MSearchBar_textSize, 13); editText.setTextSize(textSize); &#125; 给控件组内部控件添加点击事件监听： xxx.java 要实现点击事件监听接口： 1public class MSearchBar extends LinearLayout implements View.OnClickListener&#123;&#125; 自定义接口，供使用xxx.java类时实现对监听事件的处理： 123456789public void setImgLeftOnClickListener(OnImgClickListener listener)&#123; listenerL = listener;&#125;public interface OnImgClickListener&#123; public void onClick();&#125;private OnImgClickListener listenerL; 对要监听点击事件的控件设置监听，并调用1234567891011121314151617181920212223```java //在构造方法等地方设置监听事件 imageViewLeft.setOnClickListener(this); //在xxx.java中重写onClick()方法 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; //ImageLeft case R.id.imageView: if (listenerL != null) &#123; listenerL.onClick(); &#125; break; //imageRight case R.id.imageView2: if (listenerR != null) &#123; listenerR.onClick(); &#125; break; &#125; &#125; 4. 使用自定义控件组xxx.java 在布局文件main_activity.xml中添加该控件 1234567&lt;cf.android666.jixiaoyong.weightgroup.weight.MSearchBar android:id="@+id/search_bar" android:layout_width="match_parent" android:layout_height="wrap_content" app:textColor="@color/colorPrimaryDark"&gt;&lt;/cf.android666.jixiaoyong.weightgroup.weight.MSearchBar&gt; ​ 在java中使用该控件，设置监听事件 12345678MSearchBar searchBar = (MSearchBar) findViewById(R.id.search_bar);searchBar.setImgLeftOnClickListener(new MSearchBar.OnImgClickListener() &#123; @SuppressLint("WrongConstant") @Override public void onClick() &#123; Toast.makeText(MainActivity.this, "Click on Left", Toast.LENGTH_SHORT).show(); &#125; &#125;); 5.效果预览 6.源码demo的github链接:github]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android常用知识]]></title>
    <url>%2Fblog%2F2017%2F09%2Fandroid%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[自定义view 画矩形 1canvas.drawRect(left, top, right, bottom, paint); 其中：left/top 是该view的左上顶点到父容器左边和顶端的距离right/bottom 是该view的右下顶点到父容器左边和顶端的距离 写字 12345678Rects bounds = new Rects();mPaint.setColor(mColorText);mPaint.setTextSize(mSizeText);mPaint.setTextAlign(Paint.Align.CENTER);mPaint.getTextBounds(text, 0, text.length(), bounds);float x = width / 2;float y = -bounds.centerY() + childHeight / 2 + i * childHeight;canvas.drawText(text, x, y, mPaint); ​ 当text为居中对齐时，centerX和centerY是该字的正中心，以text的左下角为原点，故而centerY为-sizeOfText/2。 自定义属性 attrs.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="LetterIndex"&gt; &lt;attr name="color_text" format="color" /&gt; &lt;attr name="color_index_bg" format="color" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; ​ MyView.java 123AttributeSet attrs = ***;TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.LetterIndex);mColorText = arr.getColor(R.styleable.LetterIndex_color_text, 0x52000000); 注意默认值可以为123456​ **main_act.xml**```xml&lt;com.text.MyView***app:color_text = &quot;#003903&quot;/&gt; 对外预留onClick监听接口MyView.java12345678910//定义 private onIndexClickListener mClickListener; public interface onIndexClickListener&#123; void onIndexClick(int chooseId); &#125; public void setOnIndexClickListener(onIndexClickListener listener)&#123; this.mOnIndexClick = listener; &#125;//使用，在需要监听的动作发生时调用该方法 mClickListener.onIndexClick(mChooseId); ​ MainAct.java123456mView.setOnIndexClickListener(new LetterIndex.onIndexClickListener() &#123; @Override public void onIndexClick(int chooseId) &#123; Log.d("TAG", "onIndexClick: chooseid is" + chooseId); &#125; &#125;); RecyclerView滑动事件manager.scrollToPositionWithOffset(n, 0);n为要滑到顶端的position]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View实现联系人列表]]></title>
    <url>%2Fblog%2F2017%2F09%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E7%8E%B0%E8%81%94%E7%B3%BB%E4%BA%BA%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[自定义的view LetterIndex.java extends View ContactsListView.java extends RecyclerView#分析 联系人列表有两个要点 字母导航栏通过自定义View画出26个字母，设置滑动监听事件，根据上下滑动的距离判断当前选中的字母，并相应更新界面。 列表中的字母标题针对item中的联系人姓名首字母对应的tag作比较，若与前一个相同则不显示title，否则显示。 事件联动 当滑动字母导航栏时，除了处理本身的变化外，还要留出接口，以便其他控件获取当前选中的字母。 联系人列表滑动时，除了处理本身变化外，同样要留出接口以便获取当前置顶的item对应的字母 字母导航栏要留出方法，以便其他控件指定选中的字母，并更新界面#具体代码ContactsListView.java重写该类主要是为了实现ItemDecoration根据不同的item变化，同时可以从xml布局文件中获取ItemDecoration的自定义属性。主要代码：12345678910111213public ContactsListView(Context context) &#123; this(context, null, 0);&#125;public ContactsListView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0);&#125;public ContactsListView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); mTypeArray = context.obtainStyledAttributes(attrs, R.styleable.MyRecyclerDecoration); mContext = context;&#125; 故而在其内部自定义了一个继承自ItemDecoratio得静态内部类Decorationn类：12345678910111213141516171819202122232425262728293031323334353637383940public Decoration(List&lt;String&gt; data)&#123;//获取要显示的联系人数据对应的英文tag集合//初始化各种自定义属性//例如颜色：mColorLetterText = mTypeArray.getColor(R.styleable.MyRecyclerDecoration_color_letter_text, 0xff152648);&#125;@Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state)&#123;//画出各个导航title&#125;@Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;//画出置顶的导航title&#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;//判断是否画出导航title super.getItemOffsets(outRect, view, parent, state); int position = ((RecyclerView.LayoutParams) (view.getLayoutParams())).getViewAdapterPosition(); if (position != -1) &#123; String text = mDatas.get(position).substring(0, 1).toUpperCase(); if (position == 0) &#123; outRect.set(0, mTitleHeight, 0, 0); &#125; else if (text != null &amp;&amp; !text.equals(mDatas.get(position - 1).substring(0, 1).toUpperCase())) &#123; outRect.set(0, mTitleHeight, 0, 0); &#125; else &#123; outRect.set(0, 0, 0, 0); &#125; &#125;&#125;private void drawText(Canvas canvas, float left, float right, View child, String text) &#123;//画出文字&#125; LetterIndex.java该类用来画出字母导航栏，并且提供方法获取/设置当前选中的字母123456789101112131415public interface onIndexClickListener &#123; void onIndexClick(int chooseId); void onActionUp(); &#125; public void setOnIndexClickListener(onIndexClickListener listener) &#123; this.mClickListener = listener; &#125; public void setChooseId(int chooseId) &#123; if (chooseId &gt;= 0 &amp;&amp; chooseId &lt; mIndexTexts.length) &#123; mChooseId = chooseId; invalidate(); &#125; &#125; 然后重写event)```方法，在ACTION_DOWN、ACTION_MOVE、ACTION_UP时调用对应的方法即可。12重写onDraw()方法，画出对应的界面 @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); int height = getHeight() - getPaddingTop() - getPaddingBottom(); float width = getWidth(); //childHeight 是每一个字母所在单元的高度 float childHeight = (float) height / mIndexTexts.length; //如果被点击了，就画出背景 if (isClick) { mPaint.setColor(mColorIndexBg); canvas.drawRect(0, 0, width, height, mPaint); } Rect bounds = new Rect(); mPaint.setTextSize(mSizeText); mPaint.setTextAlign(Paint.Align.CENTER); for (int i = 0; i &lt; mIndexTexts.length; i++) { String text = mIndexTexts[i]; mPaint.setColor(mColorText); //在被选中的字后面画一个圆，并改变字的颜色 if (i == mChooseId) { mPaint.setColor(mColorChooseTextBg); canvas.drawCircle(width / 2, childHeight / 2 + i * childHeight, mSizeText / 2 + 2, mPaint); mPaint.setColor(mColorChooseText); } mPaint.getTextBounds(text, 0, text.length(), bounds); //bounds里面保存着要画的字的一些属性，如x，y，centerX，centerY等， //要注意 canvas.drawText（text,x,y,mpaint）中y并不是text的最低端，而是baseline。 float x = width / 2; float y = -bounds.centerY() + childHeight / 2 + i * childHeight; canvas.drawText(text, x, y, mPaint); } } ``` 源码源代码在我的Github，点这里可以找到。 预览如下]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android开发常用设置]]></title>
    <url>%2Fblog%2F2017%2F08%2FAndroid-%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Android Studio 国内较快的仓库： maven {url&apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;} RecyclerView添加依赖注意RecyclerView的版本号要和当前工程中其他android.support包版本保持一致，否则虽然导入了对应的包，但是仍然无法正常使用。 compile &apos;com.android.support:recyclerview-v7:26+&apos; 设置：自动添加依赖：insert imports on paste: None自动删除无用依赖：Optimize imports on the fly Linux 设置ndk环境变量 /etc/profile #set ndk env NDKROOT=/home/jixiaoyong/AndroidDev/Sdk/ndk-bundle export PATH=$NDKROOT:$PATH]]></content>
  </entry>
  <entry>
    <title><![CDATA[java中三种常用的排序方法]]></title>
    <url>%2Fblog%2F2016%2F12%2FJava%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。以下示例皆为从小到大的排序 1.冒泡排序每一次比较都可能要交换元素。冒泡排序的思想是：每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为m）放到后面，并将m与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。依次类推，总共遍历n-1轮，即可完成排序。具体代码如下： void bubble(int[] arr){ int temp; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } System.out.println(&quot;\n--bubble :&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } } 2.选择排序每次比较的时候不交换选择排序的思想：每次比较的时候找到的两个数中的较大值并记下其位置，等到当前一轮的遍历完成之后，将最后一个未排序元素与这一轮遍历找到的最大值交换最多交换n-1次代码如下： void select(int[] arr){ for (int i = 0; i &lt; arr.length; i++) { int maxIndex = 0; int temp = 0; for (int j = 1; j &lt; arr.length - i; j++) { if (arr[maxIndex] &lt; arr[j]) { maxIndex = j; } } temp = arr[maxIndex]; arr[maxIndex] = arr[arr.length - i - 1]; arr[arr.length - i - 1] = temp; } System.out.println(&quot;\n--select :&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } } 3.插入排序法插入排序法思想：将待排序的元素分为有序和无序两种，刚开始排序的时候假设只有第一个元素是有序的，其余n-1个元素都是无序的；排序开始的时，将无序部分的一个元素（a）与有序部分的最后一个元素（b）进行比较，如果a&lt;b，则将a与b交换，再将a与下一个有序元素进行比较；否则，将a加到b后面，作为有序部分的最后一个元素。接着再从无序部分取出一个元素与有序部分的元素依次比较，直达所有元素都为有序元素。遍历n-1次代码如下： void insertSort(int[] arr){ for (int i = 1; i &lt; arr.length; i++) { int instertValue = arr[i]; for (int j = i - 1; j &gt;= 0; j--) { if (instertValue &lt; arr[j]) { arr[j+1] = arr[j]; arr[j] = instertValue; }else { break; } } } /* 第二种表示形式 for (int i = 1; i &lt; arr.length; i++) { int instertVal = arr[i]; int index = i - 1; while (index &gt;= 0 &amp;&amp; instertVal &lt; arr[index]) { arr[index + 1] = arr[index]; index--; } arr[index + 1] = instertVal; } */ System.out.println(&quot;\n--insertSort :&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux下配置Git，使用AndroidStudio同步工程到Github]]></title>
    <url>%2Fblog%2F2016%2F04%2FLinux%E4%B8%8B%E9%85%8D%E7%BD%AEGit%EF%BC%8C%E4%BD%BF%E7%94%A8AndroidStudio%E5%90%8C%E6%AD%A5%E5%B7%A5%E7%A8%8B%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[这篇文章介绍了如何在 linux 环境下安装和配置 git 与 github ，并且使用 Android Studio 将本地的项目同步到 github 上面。 安装 git1sudo apt-gat install git 配置 git 和 github 创建 Github 账号 生成 ssh key 1ssh-keygen -t rsa -C &quot;your_email@youremail.com 在 github 上面添加 ssh key 进入 Account Settings –&gt; SSH Keys –&gt; Add SSH Key 添加 SSH Keys ：名字起一个容易识别的名字，key 是生成的 /home/username/.ssh/id_rsa.pub. 中的内容，直接粘贴到指定位置就行 测试 ssh key 是否成功 1ssh -T git@github.com 提示如You’ve successfully authenticated, but GitHub does not provide shell access则说明成功连接 github 配置 Github 12git config --global user.name &quot;your name&quot; //配置用户名git config --global user.email &quot;your email&quot; //配置email 用 Android Studio 同步工程到 Github 启动android studio 进入android studio/bin，终端输入./studio.sh 选择 VCS ---&gt; Import into Version Control --&gt; Share Project on Github 第一次进入会要求输入 github 的账号和密码 按照要求输入即可此后还会要求你输入一个本地密码，当下次同步的时候需要输入之后就进入到选择同步的仓库，新建一个仓库，开始同步就可以了 到这里就顺利的在 Android Studio 上面将工程同步到 Github 上面了 以下为原文提到的其他方法，摘录如下，以备后用： 利用Git从本地上传到GitHub第一步： 进入要所要上传文件的目录 输入命令 git init 第二步： 创建一个本地仓库 origin 使用命令 1git remote add origin git@github.com:yourName/yourRepo.git youname是你的GitHub的用户名，yourRepo是你要上传到GitHub的仓库 第三步： 比如你要添加一个文件xxx到本地仓库，使用命令 git add xxx，可以使用 git add . 自动判断添加哪些文件 然后把这个添加提交到本地的仓库，使用命令 git commit -m说明这次的提交 最后把本地仓库origin提交到远程的GitHub仓库，使用命令 git push origin master 从GitHub克隆项目到本地第一步： 到GitHub的某个仓库，然后复制右边的有个HTTPS clone url 第二步： 回到要存放的目录下，使用命令 git clone https://github.com/chenguolin/scrapy.git，这里的url只是一个例子 第三步： 如果本地的版本不是最新的，可以使用命令 git fetch origin，origin是本地仓库 第四步： 把更新的内容合并到本地分支，可以使用命令 git merge origin/master 如果你不想手动去合并，那么你可以使用：git pull &lt;本地仓库&gt; master // 这个命令可以拉去最新版本并自动合并 GitHub的分支管理 创建 1 创建一个本地分支： git branch &lt;新分支名字&gt; 2 将本地分支同步到GitHub上面： git push &lt;本地仓库名&gt; &lt;新分支名&gt; 3 切换到新建立的分支： git checkout &lt;新分支名&gt; 4 为你的分支加入一个新的远程端： git remote add &lt;远程端名字&gt; &lt;地址&gt; 5 查看当前仓库有几个分支: git branch 删除 1 从本地删除一个分支： git branch -d &lt;分支名称&gt; 2 同步到GitHub上面删除这个分支： git push &lt;本地仓库名&gt; :&lt;GitHub端分支&gt; 说明这篇文章是我今天在 linux 下安装 git ，上传工程到 github 上面时的步骤的总结，大部分内容都参考/摘录自下面这篇文章，感谢原作者的分享，原文信息及链接如下： Linux下Git和GitHub使用方法总结[日期：2014-03-07] 来源：Linux社区 作者：chenguolinhttp://www.linuxidc.com/Linux/2014-03/97821.htm]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux下配置JDK和AndroidStudio开发环境]]></title>
    <url>%2Fblog%2F2016%2F04%2Flinux%E4%B8%8B%E9%85%8D%E7%BD%AEJDK%E5%92%8CAndroidStudio%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[下载 JDK 并解压 到官网下载 jdk 下载到的 JDK 文件解压 设置环境变量管理员权限进入 etc/environment 写入以下代码 1JAVA_HOME=&quot;JDK主目录的绝对路径&quot; 配置 alternatives打开终端执行以下命令： 123sudo update-alternatives --install /usr/bin/java java JDK主目录的绝对路径/bin/java 300sudo update-alternatives --install /usr/bin/javac javac JDK主目录的绝对路径/bin/javac 300 到这里 JDK 的环境就配置好了 运行 Android Studio进入 android studio/bin 目录下，打开终端， 输入 ./studio.sh 到这里，就可以正常运行 android studio 了]]></content>
  </entry>
  <entry>
    <title><![CDATA[AppWidget的使用之PendingIntent]]></title>
    <url>%2Fblog%2F2016%2F04%2F%E5%B0%8F%E7%99%BD%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这几天学习 AppWidget ，很简单的组件却花费了不少功夫，今天对 PendingIntent 的用法做了一些简单的整理。 PendingIntent PandingIntent 就像是一个设计好的处理预案，当达到某个特定条件时，便会调用该 Intent 所指定动作（打开服务，Activity或者发送广播）。 这里使用该方法在 AppWidget 里面为按钮添加监听事件，当按钮被点击的时候触发相应的动作 AppWidget 和应用程序不再同一个进程当中，而是在 HomeScreen 上面执行,所以不能直接为 AppWidget 中的 Button 添加监听事件，需要用 remoteViews.setPendingIntent(R.id.widget_button,pendingIntent);意思是当按下按钮的时候 pendingIntent 中的 Intent 就会执行 PendingIntent 当某个事件出现之后才会执行 RemoteViews对象 代表了一系列的 View 对象，和主程序不在同一个进程为 AppWidget 控件绑定处理器 流程概述： 添加 appwidget_provider_info.xml 在 res/xml 下新建 appwidget_provider_info.xml 描述 AppWidget 的基本信息如最小高度、宽度等，还有就是该挂件的布局文件 在 res/layout 下面为该挂件设置具体的布局样式 向 AppWidget 的布局文件中添加一个 Button 向 AppWidget 的布局文件中添加一个 TextView 新建 MyAppWidget.java 继承自 AppWidgetProvider 在该类的 onUpdate() 方法中为 Button 设置、添加监听事件 建立一个 Intent 对象 用该 Intent 对象创建一个 PendingIntent 对象 创建一个 RemoteViews 对象 用该 RemoveViews 对象为 按钮绑定事件处理器 更新按钮 注册事件 备注：要是为 AppWidget 中的 Button 设置的事件是打开一个 TargetActivity ，还需要添加一个 TargetActivity 类和对应的布局文件 以下是代码 appwidget_provider_info.xml 这个布局文件是 AppWidget 的信息 描述了 AppWidget 的最小高，最小宽以及它的布局文件 123456&lt;appwidget-provider android:minHeight=&quot;200dp&quot; android:minWidth=&quot;300dp&quot; android:initialLayout=&quot;@layout/app_widget&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;&lt;/appwidget-provider&gt; app_widget.xml 这个布局文件是 Widget 在桌面上显示的样式 定义了 AppWidget 中各个组件及其样式 其中 Button 用来响应点击事件，加入 TargetActivity 1234567891011121314151617&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:orientation=&quot;vertical&quot;&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;hello,world!&quot;/&gt;&lt;Button android:id=&quot;@+id/app_widget_btn&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;#ff00ff&quot; android:text=&quot;this is my app widget button&quot;/&gt;&lt;/LinearLayout&gt; target_activity.xml 123456789101112&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;50sp&quot; android:background=&quot;#00ff00&quot; android:text=&quot;\n hello,welcome to target activity!&quot;/&gt;&lt;/LinearLayout&gt; MyAppWidget.java 主要是修改了 update() 方法： 定义了一个预先设定的动作—- Intent 对象； 利用该 Intent 读写，创建一个 PendingIntent 对象； 创建一个 RemoteView 对象，并为按钮绑定监听事件 刷新 AppWidget。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyAppWidget extends AppWidgetProvider &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Auto-generated method stub super.onReceive(context, intent); &#125; @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; // TODO Auto-generated method stub super.onUpdate(context, appWidgetManager, appWidgetIds); //appWidgetIds 每一次向屏幕添加 AppWidget 的时候都会增加一个唯一的 appWidget 的 Id for(int i = 0; i &lt; appWidgetIds.length;i++)&#123; //创建一个 Intent 对象 Intent intent = new Intent(context,TargetActivity.class); //创建一个 PendingIntent 对象 PendingIntent pendingIntent = PendingIntent.getActivity(context,0,intent,0); // remoteViews 代表 AppWidget 上所有的控件 RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget); //为按钮绑定事件处理器 /* * 参1，指定被绑定处理器的控件id * 参2，指定事件发生时会被执行的 PendingIntent */ remoteViews.setOnClickPendingIntent(R.id.app_widget_btn,pendingIntent); //更新 AppWidget ，参1是用于指定被更新 appWidget 的ID appWidgetManager.updateAppWidget(appWidgetIds[i],remoteViews); &#125; &#125; @Override public void onDeleted(Context context, int[] appWidgetIds) &#123; // TODO Auto-generated method stub super.onDeleted(context, appWidgetIds); &#125; @Override public void onEnabled(Context context) &#123; // TODO Auto-generated method stub super.onEnabled(context); &#125; @Override public void onDisabled(Context context) &#123; // TODO Auto-generated method stub super.onDisabled(context); &#125;&#125; TargetActivity.java 1234567public class TargetActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.target_activity); &#125;&#125; AndroidManifest.xml 在 AndroidManifest.xml 中注册 TargetActivity 和 MyAppWidget 123456789101112131415&lt;application&gt;... &lt;activity android:name=&quot;.TargetActivity&quot;&gt; &lt;/activity&gt; &lt;!-- 注意这里注册了一个 MyAppWidget 接收数据--&gt; &lt;receiver android:name=&quot;.MyAppWidget&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@xml/appwidget_provider_info&quot;/&gt; &lt;/receiver&gt;&lt;/application&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AppWidget的使用之PendingIntent]]></title>
    <url>%2Fblog%2F2016%2F04%2FAppWidget%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8BPendingIntent%2F</url>
    <content type="text"><![CDATA[这几天学习 AppWidget ，很简单的组件却花费了不少功夫，今天对 PendingIntent 的用法做了一些简单的整理。 PendingIntent PandingIntent 就像是一个设计好的处理预案，当达到某个特定条件时，便会调用该 Intent 所指定动作（打开服务，Activity或者发送广播）。 这里使用该方法在 AppWidget 里面为按钮添加监听事件，当按钮被点击的时候触发相应的动作 AppWidget 和应用程序不再同一个进程当中，而是在 HomeScreen 上面执行,所以不能直接为 AppWidget 中的 Button 添加监听事件，需要用 remoteViews.setPendingIntent(R.id.widget_button,pendingIntent);意思是当按下按钮的时候 pendingIntent 中的 Intent 就会执行 PendingIntent 当某个事件出现之后才会执行 RemoteViews对象 代表了一系列的 View 对象，和主程序不在同一个进程为 AppWidget 控件绑定处理器 流程概述： 添加 appwidget_provider_info.xml 在 res/xml 下新建 appwidget_provider_info.xml 描述 AppWidget 的基本信息如最小高度、宽度等，还有就是该挂件的布局文件 在 res/layout 下面为该挂件设置具体的布局样式 向 AppWidget 的布局文件中添加一个 Button 向 AppWidget 的布局文件中添加一个 TextView 新建 MyAppWidget.java 继承自 AppWidgetProvider 在该类的 onUpdate() 方法中为 Button 设置、添加监听事件 建立一个 Intent 对象 用该 Intent 对象创建一个 PendingIntent 对象 创建一个 RemoteViews 对象 用该 RemoveViews 对象为 按钮绑定事件处理器 更新按钮 注册事件 备注：要是为 AppWidget 中的 Button 设置的事件是打开一个 TargetActivity ，还需要添加一个 TargetActivity 类和对应的布局文件 以下是代码 appwidget_provider_info.xml 这个布局文件是 AppWidget 的信息 描述了 AppWidget 的最小高，最小宽以及它的布局文件 123456&lt;appwidget-provider android:minHeight=&quot;200dp&quot; android:minWidth=&quot;300dp&quot; android:initialLayout=&quot;@layout/app_widget&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;&lt;/appwidget-provider&gt; app_widget.xml 这个布局文件是 Widget 在桌面上显示的样式 定义了 AppWidget 中各个组件及其样式 其中 Button 用来响应点击事件，加入 TargetActivity 1234567891011121314151617&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:orientation=&quot;vertical&quot;&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;hello,world!&quot;/&gt;&lt;Button android:id=&quot;@+id/app_widget_btn&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;#ff00ff&quot; android:text=&quot;this is my app widget button&quot;/&gt;&lt;/LinearLayout&gt; target_activity.xml 123456789101112&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;50sp&quot; android:background=&quot;#00ff00&quot; android:text=&quot;\n hello,welcome to target activity!&quot;/&gt;&lt;/LinearLayout&gt; MyAppWidget.java 主要是修改了 update() 方法： 定义了一个预先设定的动作—- Intent 对象； 利用该 Intent 读写，创建一个 PendingIntent 对象； 创建一个 RemoteView 对象，并为按钮绑定监听事件 刷新 AppWidget。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyAppWidget extends AppWidgetProvider &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Auto-generated method stub super.onReceive(context, intent); &#125; @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; // TODO Auto-generated method stub super.onUpdate(context, appWidgetManager, appWidgetIds); //appWidgetIds 每一次向屏幕添加 AppWidget 的时候都会增加一个唯一的 appWidget 的 Id for(int i = 0; i &lt; appWidgetIds.length;i++)&#123; //创建一个 Intent 对象 Intent intent = new Intent(context,TargetActivity.class); //创建一个 PendingIntent 对象 PendingIntent pendingIntent = PendingIntent.getActivity(context,0,intent,0); // remoteViews 代表 AppWidget 上所有的控件 RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget); //为按钮绑定事件处理器 /* * 参1，指定被绑定处理器的控件id * 参2，指定事件发生时会被执行的 PendingIntent */ remoteViews.setOnClickPendingIntent(R.id.app_widget_btn,pendingIntent); //更新 AppWidget ，参1是用于指定被更新 appWidget 的ID appWidgetManager.updateAppWidget(appWidgetIds[i],remoteViews); &#125; &#125; @Override public void onDeleted(Context context, int[] appWidgetIds) &#123; // TODO Auto-generated method stub super.onDeleted(context, appWidgetIds); &#125; @Override public void onEnabled(Context context) &#123; // TODO Auto-generated method stub super.onEnabled(context); &#125; @Override public void onDisabled(Context context) &#123; // TODO Auto-generated method stub super.onDisabled(context); &#125;&#125; TargetActivity.java 1234567public class TargetActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.target_activity); &#125;&#125; AndroidManifest.xml 在 AndroidManifest.xml 中注册 TargetActivity 和 MyAppWidget 123456789101112131415&lt;application&gt;... &lt;activity android:name=&quot;.TargetActivity&quot;&gt; &lt;/activity&gt; &lt;!-- 注意这里注册了一个 MyAppWidget 接收数据--&gt; &lt;receiver android:name=&quot;.MyAppWidget&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@xml/appwidget_provider_info&quot;/&gt; &lt;/receiver&gt;&lt;/application&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2016%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
