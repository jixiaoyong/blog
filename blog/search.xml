<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android 5.x以下加载MultiDex白屏的处理优化</title>
      <link href="/blog/posts/caa169b7/"/>
      <url>/blog/posts/caa169b7/</url>
      
        <content type="html"><![CDATA[<p>当APP的minSdkVersion低于Android 5时，在方法数大于65536时，需要将APP打包为多个DEX文件，此时需要添加MultiDex依赖。</p><p>官方方法如下：</p><p>1.<code>build.gradle</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        minSdkVersion <span class="number">15</span> </span><br><span class="line">        targetSdkVersion <span class="number">28</span></span><br><span class="line">        multiDexEnabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile <span class="string">'com.android.support:multidex:1.0.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<code>MyApplication</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方式❶：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">MultiDexApplication</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">方式❷：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">SomeOtherApplication</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">     MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，为了避免一些启动期间需要的任何类未在主 DEX 文件中提供而导致<code>java.lang.NoClassDefFoundError</code>，还需要告诉AS将这些类添加到主DEX文件中：</p><p>3.<code>build.gradle</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            ❶ multiDexKeepFile file(<span class="string">'multidex-config.txt'</span>)</span><br><span class="line">            ❷ multiDexKeepProguard(<span class="string">'multidex-config.pro'</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//multidex-config.txt</span></span><br><span class="line">com<span class="regexp">/example/</span>MyClass.<span class="keyword">class</span></span><br><span class="line">com<span class="regexp">/example/</span>MyOtherClass.<span class="keyword">class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//multidex-config.pro</span></span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">MyClass</span></span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">MyClassToo</span></span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">class</span> <span class="title">com</span>.<span class="title">example</span>.** &#123;</span> *; &#125; <span class="comment">// All classes in the com.example package</span></span><br></pre></td></tr></table></figure><p>但是在实际运行中，Android 4.x的系统会在APP安装后第一次启动时，在<code>MultiDex.install(this)</code>方法中进行DEX文件合并优化等耗时操作（主线程），往往会持续数十秒以上，从而导致APP第一次启动时长时间白屏，十分影响体验。</p><p>查阅相应的资料后大体有以下几种方案</p><ol><li><p>设置主Activity的背景为透明色</p><p>这样当用户点击APP图标启动APP时，在主Activity启动之前看到的一直是桌面的样子而非白屏，但这只是一种障眼法，用户可能会以为系统卡顿，体验并不好。</p></li><li><p>在Application中检测到是第一次启动的话，新开一个进程并在其中进行<code>MultiDex.install(this)</code></p><p>这种方法在主进程启动时，检测到尚未进行MultidexOpt，则阻塞当前进程，新开一个进程，在其中加载一个Activity，并在后台进程运行<code>MultiDex.install(this)</code>，当MultidexOpt完成后再关闭当前进程，返回主进程继续正常开启APP。</p><p>由于主进程被阻塞的同时成为了后台进程，所以也不会触发ANR，此外子进程中的过渡Activity也只用到了基本的类，所以基本不用担心会触发<code>java.lang.NoClassDefFoundError</code>，而且过渡Activity可以展示进度、提示等用户友好的页面，相对来说体验也好了很多。</p><p>但是这种方法从子进程返回主进程涉及到进程间通信，以及主进程的主Activity启动时生命周期会出现异常(<code>onCreate()</code> -&gt; <code>onStart()</code> -&gt; <code>onResume()</code> -&gt; <code>onPause()</code>-&gt;<code>onResume()</code>)，仍然不是很好的解决方法。</p></li></ol><p>结合上述的分析后，可以看到这种问题的优化思路主要在于如何在避免<code>java.lang.NoClassDefFoundError</code>的同时，在后台可靠的通过<code>MultiDex.install(this)</code>执行MultidexOpt操作。</p><p>通过以上方案1和2的结合，可以有一个比较完美的解决方案：</p><ol><li>方案2中在过渡Activity的后台线程进行MultidexOpt操作思路是正确的，但是不需要再单独开一个进程，我们完全可以将其当做主进程的第一个Activity，等待MultidexOpt操作完成后再跳转到主Activity并finish掉本Activity，这样主Activity的生命周期也不会受影响。</li><li>这种情况下在部分低端机上，过渡Activity到主Activity跳转时会出现短暂黑屏，我们可以在过渡页面将Activity切换动画设置为渐变效果，并将主Activity背景设置为透明，待主Activity完全加载好后再将背景切换为普通模式。</li></ol><p>综上处理，我们的Application无需改动，甚至主Activity也可以不做改动，只需要添加一个过渡页面为启动Activity，在其中后台进行MultidexOpt，等DEX文件处理完毕后再加载主Activity。对项目改动少并且逻辑较为简单。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://developer.android.google.cn/studio/build/multidex.html?hl=zh-CN" target="_blank" rel="noopener">配置方法数超过 64K 的应用</a></p><p><a href="https://www.jianshu.com/p/c2d7b76ff063" target="_blank" rel="noopener">Android MultiDex初次启动APP优化方案优雅的实现</a></p><p><a href="https://www.zybuluo.com/946898963/note/1219741" target="_blank" rel="noopener">MultiDex深入学习</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/edit/hexo_blog/blog/source/_posts/AndroidMultiDexOpt.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中View相关知识</title>
      <link href="/blog/posts/1b0362b/"/>
      <url>/blog/posts/1b0362b/</url>
      
        <content type="html"><![CDATA[<p>本文为笔记性质，尚未成文。</p><h1 id="View的坐标"><a href="#View的坐标" class="headerlink" title="View的坐标"></a>View的坐标</h1><p>Android中的坐标，以屏幕左上角顶点为原点(0,0)，以横轴为x轴，竖轴为y轴，数值依次递增。</p><p>View的坐标信息有以下几种，其坐标都是以父View的左上角顶点为原点：</p><ul><li><p>x，y 是View的左上角坐标。</p></li><li><p>translationX，translationY是View左上角顶点与父容器左上角顶点的偏移量，默认为0。</p></li><li><p>left，top 是分别是View左上角顶点的x轴，y轴坐标。</p><p>right，bottom分别是View右下角顶点的x轴，y轴坐标。</p></li></ul><blockquote><p>注意</p></blockquote><p>x = translationX + left；</p><p>y = translationY + top；</p><p>改变translationX/Y的值便可以更改<strong>View的位置</strong>。当View平移的时候，代表原始位置信息的left，right，top，bottom的值并不会变化。</p><p>在OnTouch事件中，我们可以从event得到两种值：</p><p>event.rawX,event.rawY 代表 相对于手机屏幕原点的坐标</p><p>event.X,event.Y 代表 相对于当前View左上角的坐标</p><p>TouchSlop则代表认为滑动开始的最小距离</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewConfiguration.<span class="keyword">get</span>(<span class="keyword">this</span>).scaledTouchSlop</span><br></pre></td></tr></table></figure><h1 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h1><p>mScroller.startScroll()方法可以实现平滑的滑动</p><p>scrollX,scrollY表示的是<em>view的X，Y坐标减去view内容的X，Y坐标</em>。</p><p>所以scrollX&gt;0，则表示view内容向左移动，scrollX&lt;0表示view内容向右移动。类似于窗户(view)位置不变，景色(view内容)的scrollX&gt;0即景色向右移动，则在窗户中看到的效果是景色向窗户左边移动。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mScroller = Scroller(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">smoothScrollBy</span><span class="params">(destX: <span class="type">Int</span>, destY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    mScroller.startScroll(scrollX, scrollY, destX, destY, <span class="number">1000</span>)<span class="comment">//destX, destY的值如果是正的话，会向左，上方移动</span></span><br><span class="line">    invalidate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeScroll</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">        scrollTo(mScroller.currX, mScroller.currY)</span><br><span class="line">        postInvalidate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scroller不能使View滑动，而只能配合View的computeScroll()方法实现是<strong>View的内容滑动</strong>的效果。</p><ul><li>mScroller.startScroll()记录下要滑动的数据，而invalidate()通知View重绘；</li><li>每次重绘都会调用computeScroll()方法，利用mScroller计算出接下来要scrollTo()的具体值并执行，再次postInvalidate()通知View重绘；</li><li>如此反复直到绘制滑动完毕。</li></ul><p>上述无论是translationX还是scrollX等引起的view变化，都不能改变View的定位（left，right，top，bottom值），而如果<strong>更改margin的值，则可以更改View的定位</strong>。</p><h1 id="Window和WindowManager"><a href="#Window和WindowManager" class="headerlink" title="Window和WindowManager"></a>Window和WindowManager</h1><p>WindowManager.LayoutParams.flags有三个常用选项：</p><ul><li>WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL // 只处理Window区域内的点击事件，之外的交给其他Window处理</li><li>WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE // 不接受输入事件，不获取焦点，同时会开启FLAG_NOT_TOUCH_MODAL，最终事件会传递给下层具有焦点的Window</li><li>WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED  // 让Window显示在锁屏界面上</li></ul><p>WindowManager.LayoutParams.type代表Window的类型(三个)：</p><ul><li>应用Window 对应一个Activity。<code>z-ordered</code>:1~99</li><li>子Window 不能单独存在，附属在特定的父Window中，如Dialog。<code>z-ordered</code>:1000~1999</li><li>系统Window 需要系统权限，如Toast，状态栏等。<code>z-ordered</code>:2000~2999</li></ul><p><code>z-ordered</code>值大的Window会覆盖掉低值的Window。</p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>recycleview滑动<br>ItemTouchHelper源码分析 <a href="https://www.jianshu.com/p/130fdd755471" target="_blank" rel="noopener">https://www.jianshu.com/p/130fdd755471</a><br>嵌套滑动 <a href="https://blog.csdn.net/qq_15807167/article/details/51637678" target="_blank" rel="noopener">https://blog.csdn.net/qq_15807167/article/details/51637678</a><br><a href="https://www.cnblogs.com/dasusu/p/9159904.html" target="_blank" rel="noopener">https://www.cnblogs.com/dasusu/p/9159904.html</a><br><del>滑动展示删除按钮</del> <a href="https://www.jianshu.com/p/9bfed6e127cc" target="_blank" rel="noopener">https://www.jianshu.com/p/9bfed6e127cc</a> &gt;&gt; 对应的demo：<a href="https://github.com/jixiaoyong/DiyWidget/blob/master/diy-widget/src/main/java/cf/android666/applibrary/SwipeRecyclerView.kt" target="_blank" rel="noopener">https://github.com/jixiaoyong/DiyWidget/blob/master/diy-widget/src/main/java/cf/android666/applibrary/SwipeRecyclerView.kt</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/Holmofy/article/details/53959511" target="_blank" rel="noopener">View滑动效果常用属性详解：scroll、translation、LayoutParams</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android中View相关知识.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android中的Messenger源码详解</title>
      <link href="/blog/posts/b0dc2559/"/>
      <url>/blog/posts/b0dc2559/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Messenger是Android中用于IPC的方式之一，使用Handler发送有序消息队列，底层是通过AIDL调用Binder实现。</p><p>Messenger只用于服务端和客户端串行的传递消息，如果大量并发或者跨进程调用服务端的方法，就需要考虑AIDL而非Messenger。</p><p>Messenger的使用可以参考<a href="https://jixiaoyong.github.io/blog/posts/ad4c562c/">这篇文章</a>,本文主要探索一下Messenger源码实现。</p><p>主要使用到的文件：</p><p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/IMessenger.aidl" target="_blank" rel="noopener">IMessenger.aidl</a></p><p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/Messenger.java" target="_blank" rel="noopener">Messenger.java</a></p><p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/Handler.java" target="_blank" rel="noopener">Handler.java</a></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>一个典型的Messenger服务如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> messenger = Messenger(MessengerHandler())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> messenger.binder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以从客户端的得到的Messenger中取出该Handler，并实现客户端-&gt;服务端通信</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> : <span class="type">Handler</span></span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            <span class="comment">//客户端的Messenger，用于服务端-&gt;客户端通信,可选</span></span><br><span class="line">            <span class="keyword">val</span> client = msg?.replyTo</span><br><span class="line">            client?.send(Message.obtain(<span class="literal">null</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到使用Handler创建一个Messenger，进入到源码看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IMessenger mTarget;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">    mTarget = target.getIMessenger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，在这里创建了一个新的与给定的Handler绑定在一起的Messenger，再看看<code>getIMessenger()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> IMessenger <span class="title">getIMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mQueue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> MessengerImpl();</span><br><span class="line">        <span class="keyword">return</span> mMessenger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">        Handler.<span class="keyword">this</span>.sendMessage(msg);<span class="comment">//使用Handler发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到<code>getIMessenger()</code>方法会创建一个MessengerImpl对象，而这个对象</p><p>实现了<code>send()</code>方法，也证实了我们之前的一个观点——Messenger底层是使用Handler发送消息。</p><p>同时，看到MessengerImpl继承的IMessenger.Stub类我们可以联想到这里应该有一个AIDL实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/os/IMessenger.aidl</span></span><br><span class="line"><span class="keyword">package</span> android.os;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(in Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>oneway</code> 关键字用于修改远程调用的行为。使用该关键字时，远程调用不会阻塞；它只是发送事务数据并立即返回。接口的实现最终接收此调用时，是以正常远程调用形式将其作为来自 <code>Binder</code> 线程池的常规调用进行接收。 如果 <code>oneway</code> 用于本地调用，则不会有任何影响，调用仍是同步调用</p><p><a href="https://developer.android.google.cn/guide/components/aidl?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.google.cn/guide/components/aidl?hl=zh-cn</a></p></blockquote><p>这也就解释了在服务的<code>onBind(intent: Intent?)</code>方法中，我们可以直接使用<code>messenger.binder</code>获取到Binder对象的原因。</p><p>再看看Messenger客户端的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> messenger: Messenger<span class="comment">//服务端的Messenger</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> replyMessenger: Messenger = Messenger(ReplyHandler())<span class="comment">//客户端的Messenger，用于服务端-&gt;客户端通信，可选</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mServiceConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">        messenger = Messenger(service)<span class="comment">//注意这里的构造方法传入的是IBinder对象</span></span><br><span class="line">        <span class="keyword">val</span> message = Message.obtain(<span class="literal">null</span>, <span class="number">1</span>)</span><br><span class="line">        message.replyTo = replyMessenger</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = Bundle()</span><br><span class="line">        <span class="keyword">data</span>.putString(<span class="string">"msg"</span>, <span class="string">"Hello World"</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messenger.send(message)<span class="comment">//使用服务端的Messenger向服务端发送消息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到在客户端通过<code>Messenger(IBinder target)</code>取得服务端的Messenger，而这里的IBinder对象则是通过服务端的Messenger的<code>getBinder()</code>获取的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stub.asInterface()</code>方法我们在<a href="http://jixiaoyong.github.io/blog/posts/88d0bcd1/">之前的文章</a>中介绍过，他会根据客户端和服务端是否在同一进程而决定返回Stub实例还是Proxy类实例以实现跨进程通信。</p><p>而通过比较 <code>Messenger(IBinder target)</code>和<code>Messenger(Handler target)</code>两个构造方法我们也可以知道，两个方法都只是用来初始化了<code>IMessenger mTarget</code>对象，这也就解释了在服务端和客户端可以通过两个不同的构造方法获取到有同样功能的Messenger。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Android开发艺术探索》</p><p><a href="https://developer.android.google.cn/guide/components/aidl?hl=zh-cn" target="_blank" rel="noopener">Android 接口定义语言 (AIDL)</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android中的Messenger详解.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android中AIDL相关知识</title>
      <link href="/blog/posts/2270057c/"/>
      <url>/blog/posts/2270057c/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>AIDL</code>是Android中用于IPC的语言，具体使用可以参见<a href="https://jixiaoyong.github.io/blog/posts/f931e8ae/">这篇文章</a>，这篇文章主要想总结一下<code>AIDL</code>具体为我们做了什么工作，主要参考书目《Android开发艺术探索》。</p><p>在Android中，除了<code>Socket</code>、<code>Intent</code>中使用<code>Bundle</code>、本地文件共享，<code>ContentProvider</code>等等之外，还有一个独有的IPC方式即<code>Binder</code>。在日常编程中使用<code>Binder</code>的主要有<code>AIDL</code>和<code>Messenger</code>两种方式，而<code>Messenger</code>也是用<code>AIDL</code>来实现的。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol><li>新建一个AIDL文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>用AndroidStudio自动生成一个Binder类</li></ol><p>使用<code>Build</code>-&gt;<code>Make Project</code>，会在<code>app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out</code>目录下生成<code>IBookManager.java</code>。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>AIDL从客户端(Client)发起请求至服务端(Server)相应的工作流程概览，图片来源(<a href="https://blog.csdn.net/qian520ao/article/details/78074983" target="_blank" rel="noopener">https://blog.csdn.net/qian520ao/article/details/78074983</a>)</p><p><img src="https://jixiaoyong.github.io/images/20190320205619.png" alt="AIDL从客户端(Client)发起请求至服务端(Server)的流程"></p><p>下面我们对<code>IBookManager.java</code>这个文件简单分析一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> * Original file: app/src/main/aidl/cf/android666/myapplication/IBookManager.aidl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">  <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span>//<span class="title">IInterface</span>接口，所有可以在<span class="title">Binder</span>中传输的接口都要继承自该接口</span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     * 持有Binder对象</span></span><br><span class="line"><span class="comment">     * 获取客户端传过来的数据，根据方法 ID 执行相应操作。</span></span><br><span class="line"><span class="comment">     * 将传过来的数据取出来，调用本地写好的对应方法。</span></span><br><span class="line"><span class="comment">     * 将需要回传的数据写入 reply 流，传回客户端。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">cf</span>.<span class="title">android666</span>.<span class="title">myapplication</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"cf.android666.myapplication.IBookManager"</span>;<span class="comment">//是Binder的唯一标识，一般为当前Binder的类目</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);<span class="comment">//将Binder和指定的接口绑定，这样当queryLocalInterface时会返回与DESCRIPTOR一致的IInterface</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an cf.android666.myapplication.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         * 将服务端的Binder转化为客户端需要的IInterface</span></span><br><span class="line"><span class="comment">         * 如果是相同的进程，则直接返回服务端的Stub对象本身（没有跨进程）；</span></span><br><span class="line"><span class="comment">         * 如果是不同的进程，则返回的是Stub.Proxy代理类对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> cf.android666.myapplication.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> cf.android666.myapplication.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((cf.android666.myapplication.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> cf.android666.myapplication.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 客户端远程请求经过系统封装后调用该方法，</span></span><br><span class="line"><span class="comment">        * 生成 _data 和 _reply 数据流，并向 _data 中存入客户端的数据。</span></span><br><span class="line"><span class="comment">        * 通过 transact() 方法将它们传递给服务端，并请求服务端调用指定方法。</span></span><br><span class="line"><span class="comment">        * 接收 _reply 数据流，并从中取出服务端传回来的数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(descriptor);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getSth: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);<span class="comment">//从data中可以读取参数</span></span><br><span class="line">                    <span class="keyword">this</span>.getSth();<span class="comment">//注意，这里调用的是IBookManager的getSth()，也就是需要我们在使用该Binder时实现的方法</span></span><br><span class="line">                    reply.writeNoException();<span class="comment">//可以往reply中写入结果</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Proxy类持有IBinder的引用</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">cf</span>.<span class="title">android666</span>.<span class="title">myapplication</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSth</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getSth, _data, _reply, <span class="number">0</span>);<span class="comment">//这里实际上是调用了远程的IBinder的transact()方法</span></span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getSth = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);<span class="comment">//这个是我们在AIDL中定义的getSth()方法的标志，用于在onTransact中区分调用的是哪个方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSth</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span>;<span class="comment">//这个是我们在AIDL中定义的方法,需要在服务端实现，并且会在客户端被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qian520ao/article/details/78074983" target="_blank" rel="noopener">Android 深入浅出AIDL（二）</a></p><p><a href="https://blog.csdn.net/qian520ao/article/details/78089877" target="_blank" rel="noopener">Android Binder之应用层总结与分析</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android中AIDL相关知识.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OKHttpUtils分析</title>
      <link href="/blog/posts/6ff87ae7/"/>
      <url>/blog/posts/6ff87ae7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是对张鸿洋的OKHttp辅助类<a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="noopener"><strong>okhttputils</strong></a>简要分析，以便学习如何封装常见工具的思想，建议配合源码食用。</p><p>主要涉及类：</p><ul><li>OkHttpUtils</li><li>OkHttpRequestBuilder</li><li>OkHttpRequest</li><li>RequestCall</li><li>Callback</li></ul><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a>是可以用于Android和Java的Http框架，经典的使用分为3步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个OkHttpClient客户端，在这里配置网络超时等全局配置</span></span><br><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建一个网络请求，每个Http访问对应一个Request，详细配置了访问的URL，类型，参数等信息</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request</span><br><span class="line">        .Builder()</span><br><span class="line">        .url(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 使用OkHttpClient客户端创建Call并执行该网络请求，分为阻塞和异步两种方式，异步会有对应回调</span></span><br><span class="line">okHttpClient.newCall(request)</span><br><span class="line">        .enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>虽然整体的逻辑已经很简单了，但是在实际使用的时候，不可能对每个网络请求都写一次上述代码，所以就需要对齐进行必要的封装以简化网络请求流程。</p><p>okhttputils就做到了这一点，并且将上述第二步常见网络请求的过程也加入链式调用中，使用起来更加连贯：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 全局配置唯一的OkHttpClient</span></span><br><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(<span class="number">10000L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        .readTimeout(<span class="number">10000L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">        .build();</span><br><span class="line">OkHttpUtils.initClient(okHttpClient);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.在需要网络请求的时候，执行对应代码</span></span><br><span class="line">OkHttpUtils.get()</span><br><span class="line">                .url(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">                .build()</span><br><span class="line">                .execute(<span class="keyword">new</span> com.zhy.http.okhttp.callback.Callback() &#123;</span><br><span class="line">                  <span class="comment">//回调方法</span></span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>其中<code>9~10</code>行相当于OKHttp步骤2创建网络请求，<code>11~14</code>则就是步骤3执行网络请求的过程。</p><p>每次使用网络请求时只需要选择<code>get</code>、<code>post</code>等方法获取并配置相应<code>builder</code>，然后选择<code>execute</code>执行即可。</p><h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><p>那么okhttputils是如何实现这一点的呢？</p><p>首先看看<code>OkHttpUtils</code>的结构：</p><p><img src="https://jixiaoyong.github.io/images/20190317141417.png" alt=""></p><p>可以看到大体上可以将其分为3个部分：</p><ol><li>OkHttpClient相关</li><li>网络请求相关信息</li><li>与具体执行网络请求有关的方法</li></ol><h2 id="OkHttpClient相关"><a href="#OkHttpClient相关" class="headerlink" title="OkHttpClient相关"></a>OkHttpClient相关</h2><p>我们先来看第一部分，OkHttpUtils本质上只是对OkHttpClient的方法进行了一次封装，所以其肯定要持有OkHttpClient对象，一般来说一个APP只需要一个OkHttpClient对象即可，所以可以看到OkHttpUtils做了双重锁定的单例处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpUtils <span class="title">initClient</span><span class="params">(OkHttpClient okHttpClient)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (OkHttpUtils.class)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mInstance = <span class="keyword">new</span> OkHttpUtils(okHttpClient);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在第一次使用<code>OkHttpUtils</code>的时候初始化的<code>OkHttpClient</code>便会被保存到这里，之后的使用中就不需要再去反复创建了。</p><p>此外在<code>OkHttpUtils</code>的结构中可以注意到有一个<code>mPlatform</code>的变量，他会根据当前是Android还是其他平台的不同被初始化为Android主线程或者普通线程池，这个我们在后面回调网络请求状态的时候会用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Platform mPlatform = findPlatform();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="网络请求相关信息"><a href="#网络请求相关信息" class="headerlink" title="网络请求相关信息"></a>网络请求相关信息</h2><p>有了<code>OkHttpClient</code>对象之后，下一步便是创建一个适当的网络请求。</p><p>在<code>OkHttpUtils</code>中使用的是<code>OkHttpRequestBuilder &lt;T extends OkHttpRequestBuilder&gt;</code>的子类来收集、配置相关的一些属性。</p><p>在该类中，定义了一系列网络请求基本的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String url;</span><br><span class="line"><span class="keyword">protected</span> Object tag;</span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, String&gt; headers;</span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, String&gt; params;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> id;</span><br></pre></td></tr></table></figure><p>此外还有一个抽象方法，用来创建执行网络请求的<code>RequestCall</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> RequestCall <span class="title">build</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法在其子类中的实现一般是调用<code>OkHttpRequest</code>子类的<code>build</code>方法，可以看到<code>OkHttpRequestBuilder</code>只是将网络请求的相关参数传递到<code>OkHttpRequest</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.builder.GetBuilder</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCall <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (params != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        url = appendParams(url, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GetRequest(url, tag, params, headers,id).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>OkHttpRequest</code>中，利用上述的参数可以并通过<code>generateRequest(Callback callback)</code>方法创建<code>Request</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.request.OkHttpRequest</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">OkHttpRequest</span><span class="params">(String url, Object tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Map&lt;String, String&gt; params, Map&lt;String, String&gt; headers,<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">        <span class="keyword">this</span>.params = params;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">        <span class="keyword">this</span>.id = id ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Exceptions.illegalArgument(<span class="string">"url can not be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initBuilder();<span class="comment">//初始化okhttp3.Request.Builder用于生成Request</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">generateRequest</span><span class="params">(Callback callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RequestBody requestBody = buildRequestBody();</span><br><span class="line">    RequestBody wrappedRequestBody = wrapRequestBody(requestBody, callback);<span class="comment">//用于更新下载进度等，为okhttp3.Callback增加更多功能</span></span><br><span class="line">    Request request = buildRequest(wrappedRequestBody);<span class="comment">//在子类中使用okhttp3.Request.Builder对象生成对应的Request</span></span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的抽象方法<code>wrapRequestBody()</code>，<code>buildRequest()</code>的实现，也是<code>OkHttpRequest</code>各个子类主要的不同点。</p><blockquote><p><code>Callback</code>是在<code>okhttp3.Callback</code>的基础上增加了before，progress和对请求结果的处理等的回调。</p></blockquote><p><code>OkHttpRequest</code>类的<code>build</code>方法则只是将其自身传递给<code>okhttp3.Call</code>的封装类<code>RequestCall</code>，创建并返回该类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.request.OkHttpRequest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCall <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestCall(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行网络请求"><a href="#执行网络请求" class="headerlink" title="执行网络请求"></a>执行网络请求</h2><p><code>RequestCall</code>类则是对<code>okhttp3.Call</code>类的进一步封装，对外提供更多的接口：开始、取消网络请求<code>cancel()</code>,<code>readTimeOut()</code>…等接口。</p><p>当执行<code>RequestCall</code>的<code>execute</code>方法时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.request.RequestCall</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Callback callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buildCall(callback);<span class="comment">//创建okhttp3.Call对象，其所用的Request对象来自于okHttpRequest.generateRequest(callback)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        callback.onBefore(request, getOkHttpRequest().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OkHttpUtils.getInstance().execute(<span class="keyword">this</span>, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看其最后只是将<code>RequestCall</code>和<code>callback</code>传递给了<code>OkHttpUtils</code>类的<code>execute</code>方法，也就是说，最终还是调用了<code>okhttp3.Call</code>的<code>enqueue()</code>方法，在这里执行了真正的网络请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.zhy.http.okhttp.OkHttpUtils</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> RequestCall requestCall, Callback callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>)</span><br><span class="line">        callback = Callback.CALLBACK_DEFAULT;</span><br><span class="line">    <span class="keyword">final</span> Callback finalCallback = callback;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> id = requestCall.getOkHttpRequest().getId();</span><br><span class="line"></span><br><span class="line">    requestCall.getCall().enqueue(<span class="keyword">new</span> okhttp3.Callback()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, <span class="keyword">final</span> IOException e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            sendFailResultCallback(call, e, finalCallback, id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Call call, <span class="keyword">final</span> Response response)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (call.isCanceled())</span><br><span class="line">                &#123;</span><br><span class="line">                    sendFailResultCallback(call, <span class="keyword">new</span> IOException(<span class="string">"Canceled!"</span>), finalCallback, id);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!finalCallback.validateReponse(response, id))</span><br><span class="line">                &#123;</span><br><span class="line">                    sendFailResultCallback(call, <span class="keyword">new</span> IOException(<span class="string">"request failed , reponse's code is : "</span> + response.code()), finalCallback, id);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object o = finalCallback.parseNetworkResponse(response, id);</span><br><span class="line">                sendSuccessResultCallback(o, finalCallback, id);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                sendFailResultCallback(call, e, finalCallback, id);</span><br><span class="line">            &#125; <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (response.body() != <span class="keyword">null</span>)</span><br><span class="line">                    response.body().close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而网络请求的回调，则是在本文最开始的<code>mPlatform</code>提供的线程中进行。这样保证了在Android中，<code>onBefore</code>、<code>onAfter</code>、<code>inProgress</code>等回调能够在UI线程进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSuccessResultCallback</span><span class="params">(<span class="keyword">final</span> Object object, <span class="keyword">final</span> Callback callback, <span class="keyword">final</span> <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    mPlatform.execute(<span class="keyword">new</span> Runnable()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            callback.onResponse(object, id);</span><br><span class="line">            callback.onAfter(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文中，<code>okhttputils</code>将初始化<code>OkHttpClient</code>的动作提取出来，这样同一个应用只需要在最开始的时候配置一下诸如网络超时、cookie等既可。</p><p>在具体的实现中，通过<code>OkHttpRequestBuilder</code>收集网络请求的属性并传递给<code>OkHttpRequest</code>，在其子类中按照不同的需要实现生成<code>Request</code>的方法。</p><p><code>OkHttpRequestBuilder</code>的<code>build()</code>方法会生成<code>RequestCall</code>对象，<code>RequestCall</code>对象的<code>execute()</code>方法会调用<code>OkHttpRequestBuilder</code>对象的<code>generateRequest()</code>方法产生<code>Request</code>，并据此产生<code>Call</code>对象，最后通过该<code>Call</code>对象的enqueue方法执行网络请求。</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/OkHttpUtils分析.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dagger 2 ❤️ Android</title>
      <link href="/blog/posts/c04fdc6c/"/>
      <url>/blog/posts/c04fdc6c/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="http://jixiaoyong.github.io/blog/posts/2822c354/">上篇文章</a>介绍了<code>Dagger 2</code> 的基本使用，本文跟随<a href="https://google.github.io/dagger/android" target="_blank" rel="noopener">官方文档</a>实践一下<code>Dagger 2</code>在<code>Android</code>中的使用，可以看做是官方文档的不完全翻译。</p><p>本文有关<code>Dagger 2</code>的使用分为<code>Activity</code>和<code>Fragment</code>两部分，二者的使用几乎没有差别，最后介绍一下在Google官方Demo中学到的一个小技巧，可以将几乎所有的和<code>Dagger 2</code>的逻辑放到一份代码里面，对<code>Android</code>工程的影响极小。</p><p>首先要添加相关依赖（Kotlin环境）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'kotlin-kapt'</span><span class="comment">//引用该插件</span></span><br><span class="line">implementation <span class="string">"com.google.dagger:dagger:$rootProject.dagger2Version"</span></span><br><span class="line">implementation <span class="string">"com.google.dagger:dagger-android-support:$rootProject.dagger2Version"</span><span class="comment">//Android特需</span></span><br><span class="line">kapt <span class="string">"com.google.dagger:dagger-compiler:$rootProject.dagger2Version"</span><span class="comment">//注意如果是kotlin语言，这里需要时#kapt#</span></span><br></pre></td></tr></table></figure><h1 id="在Activity中的使用"><a href="#在Activity中的使用" class="headerlink" title="在Activity中的使用"></a>在Activity中的使用</h1><h2 id="Application范围内的-Component"><a href="#Application范围内的-Component" class="headerlink" title="Application范围内的@Component"></a>Application范围内的@Component</h2><p>首先创建整个应用程序使用的<code>@Component</code>，并将<code>AndroidInjectionModule</code>加入其中，实现<code>Inject</code>注入入口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = [AndroidInjectionModule::class, MainActivityModule::class])</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(application: <span class="type">MainApplication</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppComponent</code>的范围是整个应用程序都有效。</p><h2 id="创建单个Activity的-Subcomponent"><a href="#创建单个Activity的-Subcomponent" class="headerlink" title="创建单个Activity的@Subcomponent"></a>创建单个Activity的@Subcomponent</h2><p>创建某个<code>Activity</code>专属的<code>@Subcomponent</code>，用于提供<code>AndroidInjector.Builder</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subcomponent</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainActivitySubComponent</span> : <span class="type">AndroidInjector</span>&lt;<span class="type">MainActivity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subcomponent</span>.Builder</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> : <span class="type">AndroidInjector.Builder</span>&lt;<span class="type">MainActivity</span>&gt;</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建单个Activity的-Module"><a href="#创建单个Activity的-Module" class="headerlink" title="创建单个Activity的@Module"></a>创建单个Activity的@Module</h2><p>创建属于整个<code>Activity</code>的<code>@Module</code>，注意这里要指明<code>@subcomponents</code>为刚刚创建的<code>MainActivitySubComponent</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module(includes = [MainActivityModule.InnerModule::class], subcomponents = [MainActivitySubComponent::class])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivityModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bindWaitForInjectClass</span><span class="params">()</span></span> = WaitForInjectClass()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Module</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerModule</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Binds</span></span><br><span class="line">        <span class="meta">@IntoMap</span></span><br><span class="line">        <span class="meta">@ClassKey(MainActivity::class)</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindInjectorFactory</span><span class="params">(builder: <span class="type">MainActivitySubComponent</span>.<span class="type">Builder</span>)</span></span>: AndroidInjector.Factory&lt;*&gt;<span class="comment">//注意这里是 Factory&lt;*&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitForInjectClass</span> //一个供依赖注入的类</span></span><br></pre></td></tr></table></figure><p>可以看到在<code>MainActivityModule</code>中提供了一个方法利用刚刚<code>MainActivitySubComponent</code>中提供的<code>MainActivitySubComponent.Builder</code>实例生成了一个<code>AndroidInjector.Factory</code>，而这个<code>Factory</code>就是我们后面要将<code>MainActivityModule</code>中的依赖实例通过<code>AppComponent</code>传递给<code>MainActivity</code>实例的关键。</p><blockquote><p>此外还可以看到提供该Factory的方法是放到了另外一个抽象类里面然后再导入MainActivityModule中的，这是因为该方法的注解@Binds要求方法是抽象的，而MainActivityModule要是需要给Activity提供依赖实例所必须的@Provides又要求类不能是抽象的，否则就要求该方法是静态的。权衡之下我觉得这种方式是比较能接受的，当然也不排除有其他更优雅的解决方案，欢迎提<a href="https://github.com/jixiaoyong/jixiaoyong.github.io/issues" target="_blank" rel="noopener">Issue</a>告知。</p></blockquote><p>然后，将<code>MainActivityModule</code>加入到应用程序的<code>@Component</code>——<code>AppComponent</code>中。</p><h2 id="使Application继承自-HasActivityInjector"><a href="#使Application继承自-HasActivityInjector" class="headerlink" title="使Application继承自 HasActivityInjector"></a>使Application继承自 <a href="https://google.github.io/dagger/api/latest/dagger/android/HasActivityInjector.html" target="_blank" rel="noopener"><code>HasActivityInjector</code></a></h2><p>使当前<code>MainApplication</code>继承自<code>HasActivityInjector</code>，该接口只有一个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns an &#123;<span class="doctag">@link</span> AndroidInjector&#125; of &#123;<span class="doctag">@link</span> Activity&#125;s. */</span></span><br><span class="line">AndroidInjector&lt;Activity&gt; activityInjector();</span><br></pre></td></tr></table></figure><p>这个类是用来为相应的<code>Activity</code>提供一个<code>AndroidInjector</code>。由于我们已经在<code>AppComponent</code>中包括了<code>AndroidInjectionModule</code>，所以<code>Dagger 2</code>已经可以自动为我们注入<code>DispatchingAndroidInjector</code>依赖，所以接下来的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> : <span class="type">HasActivityInjector</span>, <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        DaggerAppComponent.create().inject(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> dispatchActivityInjector: DispatchingAndroidInjector&lt;Activity&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">activityInjector</span><span class="params">()</span></span> = dispatchActivityInjector<span class="comment">//返回Dagger 2为我们注入的dispatchActivityInjector对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onCreate()</code>方法中传入当前<code>Application</code>的依赖。</p><h2 id="在Activity中使用自动注入依赖"><a href="#在Activity中使用自动注入依赖" class="headerlink" title="在Activity中使用自动注入依赖"></a>在Activity中使用自动注入依赖</h2><p>做完了以上所有内容，我们只需要在<code>Activity</code>中添加如下代码就可以实现自动注入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> waitForInjectClass: WaitForInjectClass</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        AndroidInjection.inject(<span class="keyword">this</span>)<span class="comment">//注意这里，在super()之前调用</span></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_dagger2_x_android_main)</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">"TAG"</span>, <span class="string">"The Class is <span class="variable">$waitForInjectClass</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上所有代码如下，或者也可以<a href="https://gist.github.com/jixiaoyong/db7e5f18b7106ce9cb36b61bf7134340" target="_blank" rel="noopener">在这里找到</a>：</p><script src="https://gist.github.com/jixiaoyong/db7e5f18b7106ce9cb36b61bf7134340.js"></script><h2 id="这一切是怎么实现的呢？"><a href="#这一切是怎么实现的呢？" class="headerlink" title="这一切是怎么实现的呢？"></a>这一切是怎么实现的呢？</h2><p>在<code>Android</code>程序运行时，<code>AndroidInjection.inject()</code>从<code>Application</code>中的<code>activityInjector()</code>方法获取到 <code>DispatchingAndroidInjector&lt;Activity&gt;</code> ，然后将<code>Activity</code>传入<code>inject(Activity)</code>。</p><p><code>DispatchingAndroidInjector</code> 通过<code>AppComponent</code>找到我们在<code>MainActivityModule</code>提供的对应的<code>AndroidInjector.Factory</code>，然后创建了 <code>AndroidInjector</code> ——这就是我们当前<code>Activity</code>对应的<code>MainActivitySubComponent</code>。</p><p>接下来便按照之前的逻辑，从<code>MainActivitySubComponent</code>中查找提供<code>waitForInjectClass</code>的实例方法完成注入。</p><h1 id="在Fragment中的使用"><a href="#在Fragment中的使用" class="headerlink" title="在Fragment中的使用"></a>在Fragment中的使用</h1><p><code>Dagger 2</code>在<code>Fragment</code>的使用和在<code>Activity</code>中的使用十分相似。</p><p>通过之前的代码我们可以知道，其基本的原理依旧是利用<code>@Component</code>和<code>@subcomponent</code>，<code>@Module</code>之间的关联关系将<code>Application</code>和<code>Activity</code>等的依赖注入通过<code>AndroidInjector</code>关联起来的：</p><p><code>MainActivitySubComponent</code>通过将<code>MainActivityModule</code>加入到<code>AppComponent</code>之中，然后当<code>MainActivity</code>之中需要使用到<code>MainActivitySubComponent</code>时，又通过<code>AndroidInjector</code>从<code>AppComponent</code>中拿到<code>MainActivityModule</code>中的<code>AndroidInjector.Factory</code>，通过该<code>Factory</code>和<code>MainActivitySubComponent</code>中的<code>Builder</code>产生关联，从而获取到了<code>MainActivitySubComponent</code>的实例供<code>Activity</code>使用。</p><p>在<code>Fragment</code>中我们也可以这样处理，只不过由于<code>Fragment</code>的特性，他的<code>@Module</code>不仅可以交给<code>Application</code>的<code>@Component</code>，也可以交给其他<code>Fragment</code>或者<code>Activity</code>的<code>@Component</code>，让其实现<code>HasFragmentInjector</code>即可，这取决于我们想要给<code>Fragment</code>绑定的依赖。</p><p>具体的实现一般分为下面几步：</p><ul><li><p>创建<code>Application</code>的<code>@Component</code>并添加<code>AndroidInjectionModule</code></p></li><li><p>创建实现了<code>AndroidInjector&lt;MainFragment&gt;</code>的<code>MainFragmentSubComponent</code>，其内部有方法提供<code>AndroidInjector.Builder&lt;MainFragment&gt;</code></p></li><li><p>创建包含了提供<code>AndroidInjector.Factory&lt;*&gt;</code>的抽象方法的<code>MainFragmentModule</code>，指定其<code>subcomponents</code>为<code>MainFragmentSubComponent</code>；</p></li><li><p>将<code>MainFragmentSubComponent</code>加入到想要加入的类的<code>@Component</code>中，比如<code>AppComponent</code>类</p></li><li><p>在<code>Application</code>（如果上一步是<code>Activity</code>，则本步也是<code>Activity</code>等）中参照在<code>Activity</code>实现的步骤实现<code>HasFragmentInjector</code></p><p>上述完整的代码如下，或者也可以<a href="https://gist.github.com/jixiaoyong/a24e76ca29f4c8062bf5c6a98529d252" target="_blank" rel="noopener">在这里找到</a>：</p><script src="https://gist.github.com/jixiaoyong/a24e76ca29f4c8062bf5c6a98529d252.js"></script></li></ul><p>关于<code>Fragment</code>加入到<code>Activity</code>的Demo在官方文档有，这里就不再赘述了，其实只要掌握原理，其他用法的完全可以触类旁通。</p><h1 id="一个小技巧"><a href="#一个小技巧" class="headerlink" title="一个小技巧"></a>一个小技巧</h1><p>通过观察上面的两份代码，我们发现虽然这<code>Dagger 2</code>已经替我们做了好多事情，我们只需要在需要使用依赖注入的类中使用诸如<code>AndroidInjection.inject(this)</code>这样的代码就可以了，但是如果<code>Activity</code>、<code>Fragment</code>类过多的时候，这样的重复性工作仍然是个不小的工作量，万一有某处遗忘了便会导致出错。</p><p>这时就可以用到我在<a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener">Google官方示例代码</a>中学到的一个小技巧了(针对本文中的例子做了一些修改)，或者你也可以<a href="https://gist.github.com/jixiaoyong/9260c3ae2a70555e14f40c4b95364715" target="_blank" rel="noopener">到这里查看源码</a>：</p><script src="https://gist.github.com/jixiaoyong/9260c3ae2a70555e14f40c4b95364715.js"></script><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://google.github.io/dagger/android" target="_blank" rel="noopener">Dagger 2 官方文档 Android篇</a></p><p><a href="https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample" target="_blank" rel="noopener">Google官方示例代码——GithubBrowserSample</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Dagger2在Android上的应用.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> dagger2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dagger 2 从0到1之旅</title>
      <link href="/blog/posts/2822c354/"/>
      <url>/blog/posts/2822c354/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Dagger 2</code>是Google维护的一款可用于<code>Java</code>和<code>Android</code>的依赖注入框架。</p><p>本文主要是简单梳理<code>Dagger 2</code>中各个注解的作用，以及其简单用法，不涉及具体项目应用。</p><p>先解释几个概念：</p><ul><li><p><strong><code>依赖注入</code></strong>：是一个对象（或静态方法）给另一个对象提供依赖的技术。</p></li><li><p><strong><code>依赖</code></strong>是可以使用的对象（<code>Service</code>），而把依赖提供给使用该依赖的对象（<code>Client</code>）的过程叫做<code>注入</code>。</p></li></ul><p>例如，下面这段代码中<code>Service</code>就是<code>Client</code>的依赖。：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>()&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> service = Service()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果每个依赖都这样写的话，如果<code>Service</code>类的构造方法有变更，就需要同时也更改<code>Client</code>对应的方法，这样深耦合的代码显然不是我们需要的。</p><p><code>Dagger 2</code>就是为了帮助我们解决这个问题，在使用它之后，<code>Client</code>类的代码只需要这样写成类似下面这样（示例代码）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> service: Service</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 某个将Service依赖注入的方法 magicFun()</span></span><br><span class="line">        <span class="keyword">val</span> newService = service<span class="comment">//使用Service的实例service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这时<code>Service</code>的实例化过程被移到了<code>Client</code>的外部某处，这样如果<code>Service</code>构造方法有更新时，我们只需要统一去修改<code>magicFun()</code>中对应的代码即可。</p><p>那么这一切<code>Dagger 2</code>到底是如何实现的呢？</p><h1 id="Dagger-2-具体实现"><a href="#Dagger-2-具体实现" class="headerlink" title="Dagger 2 具体实现"></a>Dagger 2 具体实现</h1><h2 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h2><p>首先需要请出第一个主角——<strong><code>@Inject</code></strong>。</p><p>在<code>Dagger 2</code>中，<code>@Inject</code>主要做两件事❶标记依赖类的构造方法；❷标记需要框架自动实例化的对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>()<span class="comment">//❶标记依赖类的构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> service: Service<span class="comment">//❷标记需要框架自动实例化的对象</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样<code>Dagger 2</code>就知道了有个对象需要它来帮助我们注入，同时也知道了有一个构造方法来实例化<code>Service</code>对象。但这时如何将二者联系起来呢？</p><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>这就要提到第二个主角——<strong><code>@Component</code></strong>。</p><p><code>@Component</code>标记的类是将一个类和他的依赖联系在一起的桥梁，通常是一个<strong>抽象类或者接口</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClientComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(client: <span class="type">Client</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>Client</code>和<code>Service</code>通过<code>ClientComponent</code>联系在一起，在使用时只需要将<code>Client</code>的引用传入即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="comment">//方式❶ DaggerClientComponent.create().inject(this)</span></span><br><span class="line">    <span class="comment">//方式❷ DaggerClientComponent.builder().build().inject(this)</span></span><br><span class="line">    <span class="keyword">val</span> newService = service</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上完整的代码可以参考这里,<a href="https://gist.github.com/jixiaoyong/8abd44901a2816e2b6722566bb8f08d8#file-dagger2_basic_guide_line_part1-kt" target="_blank" rel="noopener">若无法显示可点击这里查看</a>：</p><script src="https://gist.github.com/jixiaoyong/8abd44901a2816e2b6722566bb8f08d8.js"></script><p>到目前为止，对于我们自己定义的类，我们只需要使用<code>@Inject</code>标记其构造方法，然后再在使用该类的时候使用<code>@Inject</code>标记该对象，在需要使用该对象的地方通过<code>@Component</code>类传入使用该依赖的类的引用即可。</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://jixiaoyong.github.io/images/20190126184230.png"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">@Component自动实现依赖注入的示意图</div> </center><p>但是很显然实际开发中，不是所有的<code>Service</code>类都可以被我们随意修改，如果<code>Service</code>类是第三方提供的类，显然我们是无法用<code>@Inject</code>修饰其构造函数的。</p><h2 id="Module和-Provides"><a href="#Module和-Provides" class="headerlink" title="@Module和@Provides"></a>@Module和@Provides</h2><p>为了解决第三方依赖的问题，我们要引入另外两个主角——<strong><code>@Module</code></strong>和<strong><code>@Provides</code></strong>。</p><p><code>@Provides</code>用来提供一个方法，我们可以在其内部实例化并返回<code>Service</code>类，这样子当用到<code>Service</code>的时候，<code>@Component</code>类只需要找到<code>@Provides</code>提供的这个方法，并获取到他实例化好的<code>Service</code>对象注入到<code>Client</code>中就可以了。</p><p><code>@Module</code>则是提供一个<strong>类</strong>（注意是类，而非接口），像一个袋子一样把<code>@Provides</code>提供的方法“装”到一起，打包提供给<code>@Component</code>类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientModule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getService</span><span class="params">()</span></span> = Service()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(modules = [ClientModule::class])</span><span class="comment">//Component可以有多个Module类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClientComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(client: <span class="type">Client</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的<code>@Component(modules = [ClientModule::class])</code>将装有可以产生依赖的<code>@Provides</code>方法的“大袋子”<code>@Module</code>和“桥梁”<code>@Component</code>关联到了一起。</p><p><code>@Component</code>在产生依赖的时候会先到<code>@Module</code>类中的<code>@Provides</code>方法中查找；如果找不到才会再到<code>@Inject</code>中查找。（也就是说，此时<code>Service</code>类的<code>@Inject</code>构造方法其实是失效了的，完全可以没有<code>@Inject</code>注解——第三方类即是如此）。</p><p>上述完整代码如下,<a href="https://gist.github.com/jixiaoyong/35714a6287617260d8578c1b716427cb" target="_blank" rel="noopener">若无法显示可点击这里查看</a>：</p><script src="https://gist.github.com/jixiaoyong/35714a6287617260d8578c1b716427cb.js"></script><p>解决了第三方依赖引用的问题，还有一个非常重要的问题——我们使用的绝大多数类肯定不止一个构造方法，那么假设依赖类<code>Service</code>现在有两个构造方法，我们需要分别这两个构造方法，这种情况又该怎么处理呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(<span class="keyword">var</span> string: String = <span class="string">"default"</span>)</span><br></pre></td></tr></table></figure><p>很明显，这时候<code>@Inject</code>注解已经没用了，一个类只能有一个构造方法被<code>@Inject</code>修饰，否则会报错：<code>错误: Types may only contain one @Inject constructor</code>。</p><p>去掉<code>@Inject</code>后<code>Service</code>类变成如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>(<span class="keyword">var</span> string: String = <span class="string">"default"</span>)</span><br></pre></td></tr></table></figure><p>尝试在<code>@Module</code>中添加另外一个<code>@Provides</code>方法使用另外一个带参构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientModule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getService</span><span class="params">()</span></span> = Service()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span> </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getServiceWithArgs</span><span class="params">()</span></span> = Service(<span class="string">"Args"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时发现会出错，因为有两个方法都可以提供<code>Service</code>，<code>@Component</code>产生了迷失，不知道用哪一个好，导致错误。</p><h2 id="Named和-Qualifier"><a href="#Named和-Qualifier" class="headerlink" title="@Named和@Qualifier"></a>@Named和@Qualifier</h2><p>为了解决多个构造函数导致的问题，这时就需要第五个主角<strong><code>@Named</code></strong>以及幕后英雄<strong><code>@Qualifier</code></strong></p><p>首先，上述问题的解决方案是在另外一个方法上加一个注解<code>@Named</code>，表示他是一个特殊的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="meta">@Named(<span class="meta-string">"Args"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getServiceWithArgs</span><span class="params">()</span></span> = Service(<span class="string">"Args"</span>)</span><br></pre></td></tr></table></figure><p>当在<code>Client</code>中想使用这个方法的依赖时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@field:是kotlin中注解字段特别需要的，在Java中可以直接写成@Named("Args")</span></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="meta">@field:Named</span>(<span class="string">"Args"</span>)</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> service: Service</span><br></pre></td></tr></table></figure><p>查看<code>@Named</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Named &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The name. */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现<code>@Qualifier</code>才是他实现标识限定符注解（Identifies qualifier annotations）的力量之源。查看<code>@Qualifier</code>注解可以知道，我们也可以自定义基于<code>@Qualifier</code>的注解来实现和<code>@Named</code>完全一致的功能。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@MustBeDocumented</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">annotation</span>.Retention(AnnotationRetention.RUNTIME)</span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">YourQualifierName</span></span>(<span class="comment">//YourQualifierName可以是任意你喜欢的名字</span></span><br><span class="line">    <span class="comment">/** The name.  */</span></span><br><span class="line">    <span class="keyword">val</span> value: String = <span class="string">""</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>之后我们就可以使用<code>@YourQualifierName</code>替代<code>@Named</code>实现标识不同注解的作用，从而支持有多个构造函数的<code>Service</code>类的初始化。</p><p>上述完整代码如下,<a href="https://gist.github.com/jixiaoyong/fec4426183328346b955f62eb6e9c91a" target="_blank" rel="noopener">若无法显示可点击这里查看</a>：：</p><script src="https://gist.github.com/jixiaoyong/fec4426183328346b955f62eb6e9c91a.js"></script><p><code>@Component</code>可以有多个<code>@Module</code>，他们之间的关系可以用下图表示：</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://jixiaoyong.github.io/images/20190126201436.png"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">@Component 会先到他拥有的多个@Module中去查找Service类</div> </center><h2 id="Singleton和-Scope"><a href="#Singleton和-Scope" class="headerlink" title="@Singleton和@Scope"></a>@Singleton和@Scope</h2><p>在实际开发中，我们需要有的类只能有一个实例，从而在不同的地方共享一些数据——即单例，这种情况就需要另外一个角色<code>@Singleton</code>和他的幕后英雄<code>@Scope</code>。</p><p>@Singleton是用来标记类在其范围内只能被实例化一次。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Singleton &#123;&#125;</span><br></pre></td></tr></table></figure><p>通过查看其源码可以知道其背后是<code>@Scope</code>在起作用，<code>@Scope</code>的作用是限定其修饰的类的范围，适用于有可注入的构造函数并且包含控制类型实例如何重用的类。没有<code>@Scope</code>修饰的实例在构造完毕后就会失去控制，不再关心后续的发展（<em>then forgets it</em>），而<code>@Scope</code>修饰的类会在实例构造完毕后，继续保留一遍下一次可能的复用，当有多个线程可以访问该实例时，他的实现应该是线程安全的（<em>it‘s implementation should be thread safe</em>）。</p><p>此外<code>@Component</code>应该和他所包含的<code>@Module</code>的<code>@Provides</code>的<code>@Scope</code>范围一致：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component(modules = [ClientModule::class])</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClientComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(client: <span class="type">Client</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientModule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getService</span><span class="params">()</span></span> = Service()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span> <span class="meta">@Choose(<span class="meta-string">"Args"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getServiceWithArgs</span><span class="params">()</span></span> = Service(<span class="string">"Args"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外两个关系为<strong><code>dependencies</code></strong>的<code>@Component</code>可以分别拥有相同名称的<code>@Inject</code>、<code>@Module</code>、<code>@Provides</code>而不会被<em>merge</em>，两者可以相互访问。</p><p>而<strong><code>subcomponents</code></strong>则不能和<code>@Component</code>有以上相同的项。</p><blockquote><p><code>Subcomponent</code>从它的父类访问所有依赖</p><p><code>@Component</code>只能访问在基类<code>@Component</code>接口暴露的公共性的依赖</p><p>——<a href="https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/" target="_blank" rel="noopener">Subcomponents和Component Dependencies——Sinyuk Blog</a></p></blockquote><p>他们之间的关系可以表示为下图：</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://jixiaoyong.github.io/images/20190127204658.png"> <br> <div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">@Subcomponent,@Component之间的关系</div> </center><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/android-cn/blog/tree/master/java/dependency-injection" target="_blank" rel="noopener">android-cn：依赖注入—— Github</a></p><p><a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener">Dependency Injection ——wikipedia</a></p><p><a href="https://medium.com/@elye.project" target="_blank" rel="noopener">Elye的Dagger 2 系列</a></p><p><a href="https://google.github.io/dagger/users-guide" target="_blank" rel="noopener">Dagger 2 官方手册</a></p><p><a href="https://www.jianshu.com/p/2cd491f0da01" target="_blank" rel="noopener">Android - Dagger2使用详解——简书</a></p><p><a href="https://sinyuk.me/2016/04/11/Subcomponents%E5%92%8CComponent-Dependencies/" target="_blank" rel="noopener">Subcomponents和Component Dependencies——Sinyuk Blog</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Dagger2从0到1之旅.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> dagger2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Sunflower开始学习优雅的Jetpack架构</title>
      <link href="/blog/posts/27065732/"/>
      <url>/blog/posts/27065732/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Google大法NB！！！(破音)</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://developer.android.google.cn/jetpack/" target="_blank" rel="noopener">Jetpack</a>是Google推出的一系列Android软件集合，<em>“使您可以更轻松地开发出色的 Android 应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上”</em>。</p><p><a href="https://github.com/googlesamples/android-sunflower" target="_blank" rel="noopener">Sunflower</a>则是Google用来演示如何使用Jetpack进行Android开发的Demo，有着非常优雅的架构与十分简洁的代码，可以帮助我们很好地学习Jetpack以及MVVM思想。</p><p>本文主要是结合Sunflower中的示例代码，分析Jetpack架构中各部分的作用，以及他们如何巧妙的搭配使用，方便指导日后对Jetpack的使用。</p><blockquote><p>本文中的大部分代码、示意图除非特殊注明外，皆来自Google的<a href="https://github.com/googlesamples/android-sunflower" target="_blank" rel="noopener">Sunflower工程</a>或其他互联网资源，根据篇幅需要做了部分精简，所有权益归原作者所有。</p></blockquote><p>下图是<a href="https://developer.android.google.cn/jetpack/" target="_blank" rel="noopener">Google Jetpack官网</a>对Jetpack的介绍图：</p><center>     <img style="border-radius: 0.3125em;     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://jixiaoyong.github.io/images/jetpack_donut.png">     <br>     <div style="color:orange; border-bottom: 1px solid #d9d9d9;     display: inline-block;     color: #999;     padding: 2px;">Jetpack示意图 <font style="color: #BEBEBE">来自GoogleJetpack官网</font></div> </center><h1 id="对Sunflower的整体分析"><a href="#对Sunflower的整体分析" class="headerlink" title="对Sunflower的整体分析"></a>对Sunflower的整体分析</h1><p>下图是Sunflower架构的简单示意图：</p><p><img src="https://jixiaoyong.github.io/images/20190124212220.png" alt=""></p><p>可以看到，APP的界面有<code>我的花园</code>、<code>植物目录</code>和<code>植物介绍</code>三部分，这三者的切换逻辑通过<font color="#0288d1" size="4"><strong><code>Navigation</code></strong></font>实现。</p><p>每个界面的<strong><code>XML</code></strong>中的布局信息（包括<code>数据、事件（clickListener等），RecycleView的LayoutManager，Adapter等等</code>）通过<font color="#0288d1" size="4"><strong><code>DataBinding</code></strong></font>与<font color="#0288d1" size="4"><strong><code>ViewModel</code></strong></font>中的可观察数据<font color="#0288d1" size="4"><strong><code>LiveData</code></strong></font>绑定在一起，只要数据库中的<code>数据</code>有更新，就会通过<code>LiveData</code>主动通知布局更新界面；同时<code>DataBinding</code>还通过与<code>Adapter</code>（这些继承自<strong><code>ListAdapter</code></strong>的Adapter实现了<font color="#0288d1" size="4"><strong><code>Paging</code></strong></font>的作用）将<code>ItemView</code>的<code>ViewModel</code>与布局<code>XML</code>中绑定在一起，通过<code>BindingAdapter</code>对<code>XML</code>中的数据做预处理（加载imgUrl中的图片到ImageView等等）。</p><p>在<font color="black" size="5"><strong><code>View</code></strong></font>中指定这些<code>DataBinding</code>与<font color="black" size="5"><strong><code>ViewModel</code></strong></font>之间以及<code>ViewModel</code>与<font color="black" size="5"><strong><code>Model</code></strong></font><code>数据库</code>之间的逻辑关系，这些数据与操作都受着<font color="#0288d1" size="4"><strong><code>Lifecycle</code></strong></font>的影响。</p><p><code>ViewModel</code>的数据来源——<code>Model</code>在这里的实现是一个<code>数据库</code>。每个<code>ViewModel</code>有一个<code>XXXViewModelFactory</code>类，用来使用数据类<code>XXXRepository</code>类的实例创建对应的<code>ViewModel</code>。<code>XXXViewModelFactory</code>向<code>Activity</code>等屏蔽了<code>ViewModel</code>的具体实现。</p><p><code>XXXRepository</code>类的出现时为了将<code>ViewModel</code>与数据的具体实现解耦合，这样<code>ViewModel</code>只需要关心他要的操作而不必关系数据来源的具体实现。在本例中，<code>XXXRepository</code>类对应封装了这数据库<code>AppDatabase</code>中对两个表的操作。</p><p>数据库使用<font color="#0288d1" size="4"><strong><code>Room</code></strong></font>实现，从底层开始依次分为<code>表Entity</code>，<code>数据访问对象DAO</code>和<code>数据库DataBase</code>三个层次。每个DAO对应一个包装类<code>XXXRepository</code>类供<code>ViewModel</code>使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Entity    GardenPlanting    //表，定义了存储的数据项及其格式</span><br><span class="line">@Dao    GardenPlantingDao    //数据访问对象，定义了例如插入数据、查询数据等操作</span><br><span class="line"> GardenPlantingRepository    //对DAO的封装，将数据的的具体实现与ViewModel对数据的操作解耦</span><br><span class="line">@Database     AppDatabase    //数据库，包括表和对表的操作</span><br></pre></td></tr></table></figure><p><font color="#0288d1" size="4"><strong><code>WorkManager</code></strong></font>则管理着一个从Json读取数据并加载到数据库中的后台任务<code>SeedDatabaseWorker</code>。</p><h1 id="具体实现分析"><a href="#具体实现分析" class="headerlink" title="具体实现分析"></a>具体实现分析</h1><p>首先看一下<strong><code>View</code></strong>部分，Sunflower只有简单的3个页面，全都是用<code>Fragment</code>实现，由<code>Activity</code>通过<code>Navigation</code>控制切换：</p><ul><li><code>GardenActivity</code> 主页面，唯一的一个Activity</li><li><code>GardenFragment</code> 我的花园 界面，会显示用户在植物目录中选择并种植的植物信息</li><li><code>PlantListFragment</code> 植物目录 界面，所有的植物信息列表</li><li><code>PlantDetailFragment</code> 植物介绍 界面，当在“我的花园”或“植物列表”选择了某个植物后，会进入该界面显示植物详细介绍</li></ul><h2 id="Navigation控制界面切换"><a href="#Navigation控制界面切换" class="headerlink" title="Navigation控制界面切换"></a>Navigation控制界面切换</h2><p>先看一下<a href="https://developer.android.google.cn/topic/libraries/architecture/navigation/" target="_blank" rel="noopener">Navigation</a>的定义：</p><blockquote><p>Navigation是APP设计中的关键部分，可以用来定义用户从不同的界面切换、进入和推出的交互逻辑。</p></blockquote><p>和布局文件一样，我们可以在编译器的可视化界面中，直接预览、设计不同界面切换效果。他可以负责<code>Fragment</code>、<code>Activity</code>、<code>Navigation graphs</code> 与 <code>subgraphs</code> 以及<code>Custom destination types</code>，他们之间通过不同的<code>action</code>连接起来。</p><p>通过官方文档可知，<code>Navigation</code>可以和<code>AppBar</code>，<code>ToolBar</code>等组合起来控制Fragment显示，此外可以通过<code>ViewModel</code>在绑定到同一个<code>Activity</code>的<code>Fragment</code>之间共享数据，或者也可以通过<a href="https://developer.android.google.cn/topic/libraries/architecture/navigation/navigation-pass-data" target="_blank" rel="noopener"><code>Bundle</code>或<code>Safe Args</code></a>在两个<code>Fragment</code>之间传递数据。</p><p>那么，在<code>Sunflower</code>中<code>Navigation</code>是怎么控制界面切换的呢？</p><p>首先，在<code>res/navigation/</code>目录下面新建一个<code>嵌套导航图(Nested navigation graphs)</code>,定义各个界面之前的切换关系：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">"@+id/garden_fragment"</span>&gt;</span></span><br><span class="line">//app:startDestination定义了在这个导航图中首次启动展示的界面</span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/garden_fragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.google.samples.apps.sunflower.GardenFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/my_garden_title"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">"@layout/fragment_garden"</span>&gt;</span></span><br><span class="line">//action定义了在各个界面的切换关系</span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/action_garden_fragment_to_plant_detail_fragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">"@id/plant_detail_fragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:enterAnim</span>=<span class="string">"@anim/slide_in_right"</span>//<span class="attr">enterAnim</span>等指定执行<span class="attr">action</span>时的动画</span></span><br><span class="line"><span class="tag">          <span class="attr">...</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>&gt;</span></span><br><span class="line">//argument定义了在切换界面时需要带的参数，需要androidx.navigation.safeargs的支持,具体见参考资料-Android Jetpack-Navigation 使用中参数的传递</span><br><span class="line">        <span class="tag">&lt;<span class="name">argument</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"plantId"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:argType</span>=<span class="string">"string"</span> /&gt;</span>//参数类型小写</span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在Activity对应的XML中插入该导航：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/garden_nav_fragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"androidx.navigation.fragment.NavHostFragment"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:defaultNavHost</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:navGraph</span>=<span class="string">"@navigation/nav_garden"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后就可以在Activity或者Fragment中获取该导航的实力，用来切换界面了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//activity</span></span><br><span class="line"><span class="keyword">val</span> navController = Navigation.findNavController(<span class="keyword">this</span>, R.id.garden_nav_fragment)</span><br><span class="line"><span class="comment">//fragment或其他地方</span></span><br><span class="line"><span class="keyword">val</span> direction = GardenFragmentDirections<span class="comment">//嵌套导航图中Fragment自动生成的类</span></span><br><span class="line">.ActionGardenFragmentToPlantDetailFragment(plantId)</span><br><span class="line">it.findNavController().navigate(direction)</span><br></pre></td></tr></table></figure><h2 id="DataBinding绑定布局和数据"><a href="#DataBinding绑定布局和数据" class="headerlink" title="DataBinding绑定布局和数据"></a>DataBinding绑定布局和数据</h2><p>Navigation解决了不同的布局间交互的逻辑，DataBinding则充当布局View和数据（ViewModel、LiveData）之间的桥梁，将二者联系起来。</p><p>从<a href="https://developer.android.google.cn/topic/libraries/data-binding/" target="_blank" rel="noopener">官网</a>的表述中我们知道，DataBinding使用在XML中声明的方式（而非编程的方式），将布局中的组件捆绑到APP中使用到的数据上，这样当数据更新时，布局也会随之自动更新。</p><p>DataBinding在XML中的形式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"viewmodel"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"com.myapp.data.ViewModel"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintLayout...</span> /&gt;</span> <span class="comment">&lt;!-- UI layout's root element --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是原先的页面布局信息<code>&lt;ConstraintLayout... /&gt;</code>包裹在<code>&lt;layout... /&gt;</code>中，同时多了一个数据域<code>&lt;data... /&gt;</code>，我们可以在其中定义一些变量<code>&lt;variable... /&gt;</code>，并在布局中使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>除了常见的<code>android:text</code>，<code>android:onClick</code>等通用的属性可以直接绑定外，我们还可以通过自定义<a href="https://developer.android.google.cn/topic/libraries/data-binding/binding-adapters.html" target="_blank" rel="noopener"><strong>Binding adapters</strong></a>支持更多形式的属性绑定：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">"app:goneUnless"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">goneUnless</span><span class="params">(view: <span class="type">View</span>, visible: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    view.visibility = <span class="keyword">if</span> (visible) View.VISIBLE <span class="keyword">else</span> View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就支持了<code>app:goneUnless</code>的解析，我们只要在XML中为组件加上这个属性就可以实现相应的效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.userName&#125;"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">app:goneUnless</span>=<span class="string">"@&#123;viewmodel.isGone&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>最后，我们需要在对应的Activity或Fragment中，用如下代码将布局与页面绑定到一起：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setContentView(R.layout.activity_main)</span></span><br><span class="line"><span class="keyword">val</span> binding: ActivityMainBinding = DataBindingUtil.setContentView(</span><br><span class="line">            <span class="keyword">this</span>, R.layout.activity_main)</span><br><span class="line">binding.viewmodel = ...</span><br></pre></td></tr></table></figure><p>这里的<code>ActivityMainBinding</code>类是<code>DataBinding</code>根据XML文件的名字自动替我们生成的，规律是<code>XML文件名+Binding</code>的驼峰命名。</p><p>在Sunflower中有类似的应用有很多处：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Copyright 2018 Google LLC ...</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">                <span class="attr">name</span>=<span class="string">"hasPlantings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">type</span>=<span class="string">"boolean"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/garden_list"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:isGone</span>=<span class="string">"@&#123;!hasPlantings&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layoutManager</span>=<span class="string">"androidx.recyclerview.widget.LinearLayoutManager"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">tools:listitem</span>=<span class="string">"@layout/list_item_garden_planting"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ViewModel管理数据与页面的交互"><a href="#ViewModel管理数据与页面的交互" class="headerlink" title="ViewModel管理数据与页面的交互"></a>ViewModel管理数据与页面的交互</h2><p><code>DataBinding</code>通过标记的形式将数据和组件绑定，在这个过程中他使用的数据则是来自于<code>ViewModel</code>的。在页面<code>Activity</code>(或<code>Fragment</code>)中，我们可以处理这两者之间的关系。</p><p><code>ViewModel</code>是设计用来以一种可以感知生命周期（<code>lifecycle</code>）的方式存储和管理与UI相关的数据，它可以允许数据在诸如屏幕旋转的变化中存活下来，也就是说<code>VideModule</code>的数据生命周期可能要比他附着的<code>Activity</code>或<code>Fragment</code>的生命周期长。</p><p>同时，<code>UI controller</code>可以在<code>Activity</code>等不再需要数据时，自动调用<code>ViewModel</code>的<code>onCleared()</code>方法清除这些数据以避免内存泄漏。</p><p>下图是<code>ViewModel</code>和<code>Activity</code>的生命周期对比：</p><center>     <img style="border-radius: 0.3125em;     box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://jixiaoyong.github.io/images/20190202161443.png">     <br>     <div style="color:orange; border-bottom: 1px solid #d9d9d9;     display: inline-block;     color: #999;     padding: 2px;">ViewModel和Activity的生命周期对比图：左图Activity先经历了一次旋转，然后finish，右边是与此相关的ViewModel的生命周期<br><font style="color: #BEBEBE">来自GoogleJetpack官网</font></div> </center><p>此外，由于默认的获取ViewModel的方法只能调取无参构造函数，当需要向ViewModel传递参数时，就需要用到Factory工厂模式来创建ViewModel：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> viewModel = ViewModelProviders.of(<span class="keyword">this</span>, factory).<span class="keyword">get</span>(GardenPlantingListViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlantDetailViewModelFactory</span></span>(args:Any) : ViewModelProvider.NewInstanceFactory() &#123;...&#125;</span><br></pre></td></tr></table></figure><p>还可以将<code>ViewModel</code>于<code>LiveData</code>结合，这样在<code>Activity</code>等地方对<code>LiveData</code>进行订阅后，当<code>LiveData</code>的值发生变化时<code>Activity</code>等可以及时得到通知，而做出相应变化。此外<code>ViewModel</code>与<code>lifecycle</code>的结合可以保证在<code>Activity</code>等生命周期结束后数据得到及时的清理。</p><h2 id="Room保存数据"><a href="#Room保存数据" class="headerlink" title="Room保存数据"></a>Room保存数据</h2><blockquote><p>Room持久性库在SQLite上提供了一个抽象层，以便在充分利用SQLite强大功能的同时，能够流畅的访问数据库。——Android Developers</p></blockquote><p><code>Room</code>需要3个元素：</p><ul><li><code>Database</code> 数据库，可以提供对表格的操作方法<code>@DAO</code>。是一个继承自<code>RoomDatabase</code>的抽象类。</li><li><code>Entity</code> 表格，规定了每个表格可以保存的数据格式。是一个普通类。</li><li><code>Dao</code> 数据访问结构（<code>Data Access Object</code>），定义了对表格<code>@Entity</code>中的数据的操作。是一个接口或者抽象类。</li></ul><p>此外，还可以对<code>@DAO</code>进行进一步的封装得到一个<code>XXXRepository</code>类，<code>ViewModel</code>通过这个<code>XXXRepository</code>类来操作数据，从而将其与数据的具体实现解耦。</p><h2 id="WorkManager管理任务"><a href="#WorkManager管理任务" class="headerlink" title="WorkManager管理任务"></a>WorkManager管理任务</h2><p><code>WorkManager</code>用来管理即时或定时任务。</p><p>和他相关的有下面几个关键类：</p><ul><li><code>Worker</code> 定义要执行的任务内容</li><li><code>WorkRequest</code> 代表一项单独的任务，明确具体要执行的任务内容（Worker）、任务的类型（WorkRequest.Builder的子类，决定任务一次性还是重复的）以及任务执行的条件（Constraints，如联网、电池电量等等）</li><li>WorkManager 执行管理WorkRequest</li><li>WorkInfo 包含一个指定任务的信息</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.android.google.cn/jetpack/" target="_blank" rel="noopener">Android Jetpack官网</a></p><p><a href="https://blog.csdn.net/weixin_42215792/article/details/80395379" target="_blank" rel="noopener">Android Jetpack-Navigation 使用中参数的传递</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/从Sunflower开始学习优雅的Jetpack架构.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/blog/posts/d0edc1ed/"/>
      <url>/blog/posts/d0edc1ed/</url>
      
        <content type="html"><![CDATA[<h1 id="复制，删除，移动"><a href="#复制，删除，移动" class="headerlink" title="复制，删除，移动"></a>复制，删除，移动</h1><p><code>cp</code>拷贝，<code>rm</code>删除，<code>mv</code>移动。</p><p><code>-r</code>表示递归 <code>-f</code>强制，无提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp [-r] fromFilePath toFilePath</span><br><span class="line">rm [-r] fromFilePath toFilePath</span><br><span class="line">mv [-r] fromFilePath toFilePath</span><br></pre></td></tr></table></figure><h1 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> - 返回上次所在目录</span><br><span class="line"><span class="built_in">cd</span> ~ 切换到当前用户home路径下</span><br><span class="line"><span class="built_in">cd</span> . 当前路径</span><br><span class="line"><span class="built_in">cd</span> .. 上层路径</span><br><span class="line"><span class="built_in">cd</span> ../linux 切换到同一级的linux目录</span><br></pre></td></tr></table></figure><h1 id="新建文件、文件夹"><a href="#新建文件、文件夹" class="headerlink" title="新建文件、文件夹"></a>新建文件、文件夹</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir dirName 创建文件夹</span><br><span class="line">touch fileName 创建文件</span><br></pre></td></tr></table></figure><p>Linux文件和目录名字除了“/”都合法，但是尽量不要用正则表达式之类的符号，因为有可能会在进行正则匹配时造成误删等问题</p><p>假设当前目录有文件<code>f1,f2,f3</code>和<code>f[123]</code><br>执行：<code>rm f[123]</code>本来是希望删除<code>f[123]</code>,但是由于正则匹配，会先删除<code>f1,f2,f3</code>这三个文件。</p><h1 id="查看文件信息"><a href="#查看文件信息" class="headerlink" title="查看文件信息"></a>查看文件信息</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file fileName 查看文件格式信息</span><br><span class="line">cat fileName 以文本格式查看文件全部内容</span><br><span class="line">less fileName 以分页形式查看文件内容，Q键退出</span><br></pre></td></tr></table></figure><h1 id="常用目录"><a href="#常用目录" class="headerlink" title="常用目录"></a>常用目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/home 当前用户主目录，root用户为/root</span><br><span class="line">/bin、/usr/bin 常用的可执行文件，root用户为/sbin</span><br><span class="line">/media、/mnt 用户硬件挂载点</span><br><span class="line">/etc 系统的配置文件，所有用户可见，root用户可以更改</span><br><span class="line">/boot 系统内核，开机必备文件</span><br><span class="line">/dev 系统的所有设备文件，如硬盘、光驱等</span><br><span class="line">/var和/srv 系统运行时的用户数据</span><br><span class="line">/proc 内存中的状态信息</span><br><span class="line">/lib、/usr/lib、/usr/<span class="built_in">local</span>/lib 库文件</span><br><span class="line">/temp 临时文件，所有用户可见</span><br><span class="line">/usr 程序相关文件unix system resource</span><br></pre></td></tr></table></figure><h1 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h1><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p><strong><code>ls</code></strong>  展示当前目录下文件信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [-alhd] l</span><br></pre></td></tr></table></figure><p><code>l</code>展示目录下的文件列表，<code>a</code>展示所有文件（包括隐藏文件），<code>h</code> 展示带单位的文件大小， <code>d</code>展示当前目录本身信息</p><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p><strong><code>chmod</code></strong>  更改权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] mode fileName</span><br></pre></td></tr></table></figure><p><code>mode</code>组成如下：<code>[范围] [操作] [权限]</code></p><p><code>范围</code>：<code>u</code>用户、<code>g</code>群组、<code>o</code>其他、<code>a</code>以上所有（ugo）</p><p><code>操作</code>：<code>+</code> 增加、<code>-</code> 减去、<code>=</code> 等于</p><p><code>权限</code>：<code>r</code> 读权限<code>4</code>、<code>w</code> 写权限<code>2</code>、 <code>x</code> 执行权限<code>1</code> 、无权限  <code>0</code></p><p><strong>权限验证</strong> ： root用户可以访问任何用户文件，不受权限限制；普通用户需要验证权限</p><p><em>要读取文件夹中的内容，也需要执行权限<code>x</code></em></p><h2 id="文件权限与umask"><a href="#文件权限与umask" class="headerlink" title="文件权限与umask"></a>文件权限与umask</h2><p>Linux创建新项目时默认的权限分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件夹 777</span><br><span class="line">文件 666</span><br></pre></td></tr></table></figure><p>但是，经过umask（此处为0022）遮盖后，变成了755 ，644，这才是真正创建后的结果</p><p>可以通过<code>umask查看</code>umask的值，一般只去其<strong>后3位</strong>，遮盖的原则是从原先的权限中<strong>减去</strong>umask中的权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始权限  ： r w x      7</span><br><span class="line">umask： -  w x      3</span><br><span class="line">结   果  ： r - -      4</span><br></pre></td></tr></table></figure><h2 id="查看、管理当前用户信息"><a href="#查看、管理当前用户信息" class="headerlink" title="查看、管理当前用户信息"></a>查看、管理当前用户信息</h2><p><code>users</code> 和<code>whoami</code>输出当前用户名</p><p>增、删、改用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd / userdel / usermod username</span><br><span class="line">group群组管理也类似</span><br><span class="line">groupadd / groupmod ...</span><br></pre></td></tr></table></figure><p>其中<code>userdel -r username</code>在删除用户时，也会删除用户对应的主目录<code>home</code></p><p><code>groups</code> 查看用户所在群组，其中第一个是主要群组，其余是次要群组。</p><p><em>主要群组</em> 在用户创建新的文件时，文件群组权限一项默认为该群组</p><p><code>who</code> 、<code>w</code>可以查看用户相关信息</p><p><code>id</code> 查看某人或者自己相关的<code>UID、GID</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finger [-s] username</span><br><span class="line">查看用户相关信息</span><br><span class="line">-s 仅显示用户账号、全名、登录时间</span><br></pre></td></tr></table></figure><p><code>GID</code> 系统 <500 ，用户="">500</500></p><h2 id="改密码"><a href="#改密码" class="headerlink" title="改密码"></a>改密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><h2 id="文件打包、压缩和解压缩"><a href="#文件打包、压缩和解压缩" class="headerlink" title="文件打包、压缩和解压缩"></a>文件打包、压缩和解压缩</h2><p><code>.gz</code> 压缩后格式，<code>.tar</code>打包后格式，<code>tar.gz</code>先打包后压缩的格式（常用）</p><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>gzip压缩会删除源文件,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [-cdtv#] filename</span><br></pre></td></tr></table></figure><p><code>#</code> 压缩等级</p><p><code>v</code> 显示压缩前后压缩比</p><p><code>t</code> 校验是否是gzip压缩的文件</p><p><code>c</code> 压缩文件并输出到屏幕</p><p><code>d</code> 解压文件</p><p>使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gizp file 将file压缩成file.gz，会删除file</span><br><span class="line">gzip -c file &gt; file.gz 压缩文件file并输出到file.gz</span><br></pre></td></tr></table></figure><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>打包，在压缩文件夹时，一般为了效率都会先打包，在压缩，由此形成的格式一般是类似<code>*.tar.gz*</code>的后缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">打包</span><br><span class="line">tar [-jcv] -f outFileName.tar inDirPath</span><br><span class="line">解包</span><br><span class="line">tar [-jxv] -f inFileName.tar -C outputPath</span><br></pre></td></tr></table></figure><p><code>c</code> 建立打包文档</p><p><code>x</code> 解包<code>-C</code> 输出目录</p><p><code>t</code> 查看打包文件的内容</p><p><code>j</code> / <code>z</code> 使用<code>bz2</code> / <code>gzip</code> 压缩、解压</p><p><code>v</code> 输出信息</p><p><code>f</code> 后面紧跟要操作的文件</p><h1 id="bash-shell"><a href="#bash-shell" class="headerlink" title="bash shell"></a>bash shell</h1><p>bash是用户和内容交互的桥梁 <code>用户 ↔ bash ↔ Unix内核</code></p><p><code>env</code> 查看环境变量</p><p><code>type</code> 查看类型</p><p><code>which</code> 查看指令的位置</p><p><code>clear</code> 、 <code>cls</code> 清屏</p><p><strong>bash shell 设置</strong></p><h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p><code>key=value</code> 增加一个值为<code>value</code>的变量<code>key</code></p><p>其中，如果value有空格的话需要用引号包住：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">双引号 可以用$KEY 引用其他KEY的值</span><br><span class="line">单引号 内容是纯文本</span><br></pre></td></tr></table></figure><p><code>echo $KEY​</code>可以输出<code>KEY</code>的值</p><p><code>set</code> 查看所有变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set | grep HIST 查看shell命令历史</span><br><span class="line">set | grep PSI 提示符前面的内容，username-MBP:dirpath username$</span><br></pre></td></tr></table></figure><h2 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h2><p><code>alias</code> 查看所有别名</p><p><code>alias newCmd=oldCmd</code>使用<code>newCmd</code>表示<code>oldCmd</code></p><p><code>unalias newCmd</code> 删除别名</p><p>如:<code>alias cls=clear</code>,执行<code>cls</code>就等于执行<code>clear</code></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>export KEY=VALUE</code> 将值为<code>VALUE</code>的<code>KEY</code>添加到环境变量（本次shell有效）</p><p>此外还可以写到一些文件中，在开机、登录、注销登录时调用执行——自动执行脚本<strong><code>shell startup scripts</code></strong></p><h2 id="shell-startup-scripts"><a href="#shell-startup-scripts" class="headerlink" title="shell startup scripts"></a>shell startup scripts</h2><p>开机时执行：</p><ul><li><code>/etc/profile</code></li><li><p><code>/ect/profile.d/*.sh</code></p></li><li><p><code>~/.bash_profile , ~/.bash_login , ~/.profile</code>这三个只要其中一个成功执行了，后面的就不会执行，<code>~/.bash_profile</code>会执行<code>~/.bashrc</code></p></li><li><p><code>/etc/.bashrc</code></p></li></ul><p>未登录时会执行：</p><ul><li><code>~/.bashrc</code></li><li><code>/etc/bashrc</code></li><li><code>/etc/profile.d/*.sh</code></li></ul><p>注销时执行<code>~/bash_logout</code></p><p><strong>在修改了以上文件后，可以使用<code>source path_to_file</code>或者重新登录使其立即生效</strong></p><h1 id="标准输入输出等"><a href="#标准输入输出等" class="headerlink" title="标准输入输出等"></a>标准输入输出等</h1><table><thead><tr><th>代码编号</th><th>名称</th><th>代码</th><th>作用对象</th></tr></thead><tbody><tr><td>0</td><td>标准输入</td><td>stdin</td><td>键盘等</td></tr><tr><td>1</td><td>标准输出</td><td>stdout</td><td>屏幕等</td></tr><tr><td>2</td><td>标准错误</td><td>stderr</td><td>屏幕等</td></tr></tbody></table><p>定向</p><ul><li><code>&lt;</code>和<code>&lt;&lt;</code> 输入和 追加输入</li><li><code>&gt;</code> 和<code>&gt;&gt;</code> 输出 和追加输出</li></ul><p>使用：<code>ls -al | &gt;&gt; result.txt</code>将<code>ls</code>的内容追加输出到<code>result.txt</code>文件中。</p><p><code>|</code>叫做管道，可以将前者的<strong>标准输出</strong>当做后者的输入。</p><p> <code>cmd0 &amp;&amp; cmd1</code> 前者执行成功才会执行后者；</p><p><code>cmd0 || cmd1</code> 前者执行失败才会执行后者。</p><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>查询内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-cinv] 'key' filename</span><br></pre></td></tr></table></figure><p><code>c</code> 计算次数</p><p><code>i</code> 忽略大小写</p><p><code>n</code> 行号</p><p><code>v</code> 显示没有该字符的行号</p><p><code>&#39;key&#39;</code>可以是正则表达式</p><p><code>--color=auto</code> 对查找到的文本显示颜色</p><h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>排序，默认以第一列排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [-fbknrtu] filename</span><br></pre></td></tr></table></figure><p><code>f</code> 忽略大小写</p><p><code>b</code>忽略最前面的空格（要是排序不生效时可以试一下，推荐）</p><p><code>k</code> 以第几列为标准排序，默认第一列</p><p><code>n</code> 以数组排序</p><p><code>r</code> 逆序</p><p><code>t</code> 待排序的文件的分隔符，默认是tab</p><p><code>M</code> 以英文月份排序</p><h1 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h1><p>统计字符数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [lwm] filename</span><br></pre></td></tr></table></figure><p><code>l</code> 行</p><p><code>w</code> 词</p><p><code>m</code> 字符</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Linux常用命令.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程安全与volatile和synchronize</title>
      <link href="/blog/posts/24967ad4/"/>
      <url>/blog/posts/24967ad4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java多线程编码中，保证线程安全的实质是保证对数据操作的原子性，即一个线程对数据的操作能够及时的更新到其他使用该数据的线程中，这样就可以避免多个线程因为操作的数据值不一致而产生错误。</p><p><img src="https://jixiaoyong.github.io/images/20190112144856.png" alt="线程、主内存、工作内存三者交互关系——深入理解JAVA虚拟机"></p><p>由于Java内存模型（JMM）规定，所有线程公用的数据保存在主内存中，而线程在使用时先从主内存中取到线程私有的工作内存中，之后再在使用完毕后同步到主内存中，在这过程中，如果其他线程也用到了该数据则可能会出现问题，因此在线程操作数据时需要考虑线程并发时操作数据的同步问题。</p><p><code>volatile</code>和<code>synchronize</code>因此而生。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p><code>volatile</code>修饰的变量有两个特性：</p><ul><li>变量对所有线程可见  普通变量则需要等线程操作完毕，将结果从工作内存写入到主内存中才可以被其他线程可见，volatile修饰的变量会在修改后通知其他线程该变量已经被更改，从而让其他线程再去主内存中读取最新的值</li><li>禁止指令重排优化</li></ul><p><code>volatile</code>修饰的变量执行效率和普通变量差别不大，其写操作因为要插入内存屏障，所以会稍微慢一些</p><p>需要注意的是：</p><ul><li><p>由于Java运算的具体实现并非原子性的，故而虽然<code>volatile</code>修饰的变量在所有线程可见，但是并发下并不线程安全。</p><blockquote><p>Java代码编译成class文件后可以看到，类似<code>c = c + 1</code>这样的语句，会被分为：读取<code>c</code>的值；计算<code>c+1</code>的值；将结果赋予<code>c</code>这几步来完成。所以在此期间如果有其他的线程访问这段代码，就会发生冲突。</p></blockquote></li><li><p>Java会通过<strong>指令重排</strong>来优化代码</p><blockquote><p>指令重排 指对于变量的赋值会在定义该变量和使用该变量的值之间的任意位置执行，不一定和代码中的顺序一致</p></blockquote><p><code>volatile</code>修饰的变量则会插入<em>内存屏障</em>，从而实现屏蔽指令重排的效果</p></li></ul><h1 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h1><p><code>synchronize</code>实现的原理是<strong>锁定指定的对象</strong>（如果没有指定则锁定对应的类对象或class对象），然后阻塞其他线程进入（获取到该锁的线程可以多次重入）。</p><p>由于Java的线程实现是映射到系统线程的，阻塞和唤醒需要由系统内核完成，会消耗大量的时间，因此<code>synchronize</code>是<strong>重量级操作</strong>。</p><h1 id="JMM与三个特征"><a href="#JMM与三个特征" class="headerlink" title="JMM与三个特征"></a>JMM与三个特征</h1><p>JMM的设计是围绕着<strong>原子性、可见性、有序性</strong>三个特征进行的。</p><ul><li><p><strong>原子性</strong> JVM中的<code>read,load,assign,use,store,write</code>操作和<code>synchronize</code></p></li><li><p><strong>可见性</strong> 一个线程更改了共享变量的值时，其余线程能够立即得知这个更改。通过<code>synchronize</code>，<code>final</code>和<code>volatile</code>保证。</p><p><code>final</code>要保证可见性的前提是要被<strong>安全的构建出来</strong>，避免<strong>“this引用逃逸”</strong></p><blockquote><p><strong>this引用逃逸</strong> 对象还没有被构造完成，他的<code>this引用</code>就已经被发布出去了。</p><p>在构造函数中生成内部类，由于内部类自动持有外部类的<code>this引用</code>，如果有对象在内部类语句之后构造，则就有可能发生“内部类访问这个对象时，该对象还没有构造完毕”的情况。</p></blockquote></li><li><p><strong>有序性</strong> 通过<code>synchronize</code>,<code>volatile</code>保证。</p></li></ul><p>线程从内部观察时有序（线程内是串行的语义），线程外部观察是无序（由指令重排、工作内存与主内存同步延迟导致）</p><h1 id="实现线程安全"><a href="#实现线程安全" class="headerlink" title="实现线程安全"></a>实现线程安全</h1><p>实现线程安全有以下几种方法：</p><h2 id="互斥同步（阻塞同步）"><a href="#互斥同步（阻塞同步）" class="headerlink" title="互斥同步（阻塞同步）"></a>互斥同步（阻塞同步）</h2><p>互斥同步的思想是：多个线程使用同一个共享数据时，保证同一时刻只能被一个线程使用</p><p>有两种途径：</p><ul><li><code>synchronize</code> （原生语法层），优先使用</li><li><code>ReentrantLock</code> 重入锁（API层），功能有：1.等待可中断（可以放弃等待）2.公平锁 多个线程申请锁时必须按照申请时间顺序获得锁 3.锁绑定多个条件</li></ul><h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>减少了阻塞/唤醒的耗时，在操作时进行CAS（比较并交换），在冲突发生的时候不断尝试执行所需操作，直到执行成功。</p><p>但是有一个逻辑漏洞：如果在第一次操作失败到第二次再次尝试操作之间，<em>其他线程对齐进行了操作但是该数据最终没有被变化</em>，当第二次再次尝试时，其实已经被其他线程访问过了。</p><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>保证线程安全，不一定需要同步，当线程操作的数据不是共享数据时，即使不同步也是线程安全的。</p><ul><li><strong>可重入代码</strong> 指在代码执行的过程中，如果中断其运行并运行其他的线程，当再次返回继续执行该代码时不会影响到其执行结果的代码。这种代码一般没有用到堆中的公用资源。</li><li><strong>线程本地存储</strong> 共享数据值存在于同一个线程中，如每个线程的ThreadLocal对象</li></ul><h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>JDK1.6以后，在HotSpot虚拟机上实现了许多锁优化技术：</p><ul><li><p>自旋锁</p><p>实现阻塞同步时，阻塞和唤醒会很耗时，为了避免这种情况，可以先对其进行<em>忙循环</em>，如果还不行再去执行阻塞操作</p><p><em>自适应自旋</em> 由JVM智能决定自旋次数</p></li><li><p>锁消除</p><p>JVM会自动取出不必要的锁</p></li><li><p>锁粗化</p><p>如果一段代码中有连续的锁，则JVM会将这些锁合并为一个大锁</p></li><li><p>轻量级锁</p><p>轻量级锁消耗比传统锁机制小，会优先尝试使用轻量级锁，如果不行，在升级为互斥锁</p><p>大多数情况下会减少消耗，但如果存在锁竞争，则除了互斥锁的开销外，还有轻量级锁的开销</p></li><li><p>偏向锁</p><p>在无竞争的情况下消除同步</p></li><li><p>乐观锁</p><p>读取数据时默认该对象不会被其他对象更改而不加锁，每次写数据时对比当前值与持有值是否一致，一致时才去更新数据</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《深入理解Java虚拟机——JVM高级特性与最佳实践》 周志明</p><p><a href="https://blog.csdn.net/u010571316/article/details/77993309" target="_blank" rel="noopener">this引用逃逸——蜡笔小勋</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Java线程安全之volatile和synchronize.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_总结</title>
      <link href="/blog/posts/851be5ef/"/>
      <url>/blog/posts/851be5ef/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文汇总了数据结构的优缺点及应用场景。</p><p>通用数据结构：数组、链表、树、哈希表</p><p>专用数据结构：栈、队列、优先级队列</p><p>排序：冒泡排序、选择排序、插入排序，希尔排序、快速排序、归并排序、堆排序</p><p>图：邻接矩阵、邻接表</p><h1 id="通用数据结构"><a href="#通用数据结构" class="headerlink" title="通用数据结构"></a>通用数据结构</h1><p>这些数据结构使用关键字的值存储、查找数据</p><p>其速度如下：</p><p><code>哈希表 &gt; 树 &gt; 链表 &gt; 数组</code></p><p>数组：数据量小，大小可以预测时使用</p><p>链表：数据大小不可预知，或需要频繁插入删除元素时使用</p><p>二叉搜索树：如果数组和链表都很慢时，优先考虑二叉树</p><p>平衡树：二叉搜索树很快，但是如果遇到数据是逆序的时候，就会很耗性能，而平衡树则不会</p><p>哈希表：在数据存储结构中最快，但是需要有额外的空间</p><p>下面是以上数据结构的速度：</p><p><img src="https://jixiaoyong.github.io/images/20190105140704.png" alt="通用数据结构速度统计"></p><h1 id="专用数据结构"><a href="#专用数据结构" class="headerlink" title="专用数据结构"></a>专用数据结构</h1><p>包括栈、队列、优先级队列（堆），都是抽象数据结构(ADT)，由更加基础的<code>通用数据结构</code>组成。</p><p>不能查找或者遍历，只能访问指定元素（头部，队列也可以访问尾部）。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出(FILO)，最后插入的数据在栈顶，每次只能访问栈顶元素。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出(FIFO)，最后插入的数据在队尾，最先插入的在队首，每次先弹出队首的元素。</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>是一种特殊的队列，不同的是优先级高的在队首，优先级低的在队尾，每次弹出优先级最高的元素（这意味着每次插入或弹出时要进行排序）。</p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p><img src="https://jixiaoyong.github.io/images/20190105141727.png" alt="专用数据结构效率比较"></p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序包括冒泡排序、选择排序、插入排序，希尔排序、快速排序、归并排序、堆排序。</p><p>一般使用排序优先级：</p><p><code>插入排序 &gt; 希尔排序 &gt; 快速排序 &gt; 归并排序 &gt; 堆排序</code></p><p>归并排序：需要辅助存储空间</p><p>堆排序：需要一个堆的数据结构，比快速排序更适于非随机数据</p><p>快速排序：处理非随机数据时会慢到$O(N^2)​$</p><p>下面是排序算法比较：</p><p><img src="https://jixiaoyong.github.io/images/20190105142406.png" alt="排序算法比较"></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_总结.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_二叉树</title>
      <link href="/blog/posts/101c73f/"/>
      <url>/blog/posts/101c73f/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍了二叉树，及其应用。</p><p>树，既能像链表那样快速插入和删除，又可以像数组那样快速查找。</p><p><img src="https://jixiaoyong.github.io/images/20190103200423.png" alt="树"></p><p>每棵树有且只有一个<strong>根</strong>，从根到任何一个节点<strong>有且只有一条路径</strong>；每个节点都可以有0个或者多个<strong>子节点</strong>，没有子节点的节点叫做<strong>叶子节点</strong>。</p><p><strong>层</strong>是指从根节点到该节点的“代”树，根节点的在<strong>0层</strong>。</p><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>一个节点只能有0~2个子节点的树叫做<strong>二叉树</strong>；</p><p>如果二叉树的左子节点的关键字小于该节点，右子节点的关键字大于该节点，则该二叉树称为<strong>二叉搜索树</strong>。</p><p>如下，是一个二叉树的节点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span></span>(<span class="keyword">val</span> iId: <span class="built_in">Int</span>, <span class="keyword">val</span> dData: <span class="built_in">Double</span>, <span class="keyword">var</span> left: BinaryNode? = <span class="literal">null</span>, <span class="keyword">var</span> right: BinaryNode? = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;<span class="variable">$iId</span>,<span class="variable">$dData</span>&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历树指安装一定的顺序访问数的每个节点，按照访问节点的顺序不同，可以分为三种：</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><p>以中序遍历为例，其访问节点的顺序如下：</p><ol><li>调用自身遍历该节点的左子树；</li><li>访问这个节点；</li><li>调用自身遍历该节点的右子树。</li></ol><p>实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历法</span></span><br><span class="line"><span class="comment"> * 使所有节点的关键值按照升序被访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inTraversing</span><span class="params">(node: <span class="type">BinaryNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    inTraversing(node.left)</span><br><span class="line">    print(<span class="string">"<span class="variable">$node</span>,"</span>)</span><br><span class="line">    inTraversing(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h2><p>二叉搜索树的最大值是右子树中最右端没有子节点的右子节点；</p><p>二叉搜索树的最小值是左子树中最左端没有子节点的左子节点。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>二叉搜索树因为节点要满足<code>左子节点 &lt; 节点 &lt; 右子节点</code>这个条件，所以删除需要分以下几种情况：</p><p>按照要删除的节点子节点数目的不同，分为3种情况</p><ul><li><p>要删除的节点是叶节点 将其父节点的指向设为null即可</p></li><li><p>要删除的节点有且只有一个节点 将其父节点指向其子节点</p></li><li><p>要删除的节点有两个子节点 这时候可以找该子节点的右子树中最小的（或者左子树中最大的）节点并替换掉要删除的节点，</p><p>与此同时如果这个节点有右子节点（或对应的左子节点）则按照2/3的规则处理，这样就能保证这个树的结构不会出错</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(iId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//查找iId对应的节点</span></span><br><span class="line">        <span class="keyword">var</span> current = root</span><br><span class="line">        <span class="keyword">var</span> parent = root</span><br><span class="line">        <span class="keyword">while</span> (current?.iId != iId) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            parent = current</span><br><span class="line">            current = <span class="keyword">if</span> (iId &gt; current.iId) &#123;</span><br><span class="line">                current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 按照要删除的节点子节点数目的不同，分为3种情况</span></span><br><span class="line"><span class="comment">         * 1/3 要删除的节点是叶节点 将其父节点的指向设为null即可</span></span><br><span class="line"><span class="comment">         * 2/3 要删除的节点有且只有一个节点 将其父节点指向其子节点</span></span><br><span class="line"><span class="comment">         * 3/3 要删除的节点有两个子节点 这时候可以找该子节点的右子树中最小的（或者左子树中最大的）节点并替换掉要删除的节点，</span></span><br><span class="line"><span class="comment">         *     与此同时如果这个节点有右子节点（或对应的左子节点）则按照2/3的规则处理，这样就能保证这个树的结构不会出错</span></span><br><span class="line"><span class="comment">         *     下面采用的是找该节点的右子树最小值，即右子节点或者右子节点的最后一个左子节点</span></span><br><span class="line"><span class="comment">         *     找到后用该子节点的值替换掉要删除的节点值，如果该子节点还有右子节点，将该子节点的父节点指向其右子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span> &amp;&amp; current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//双子节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前点右子节点的左子节点为null</span></span><br><span class="line">            <span class="keyword">if</span> (current.right!!.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                    parent.right = current.right</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.left = current.right</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//TODO 是否需要将右节点的左子节点指向当前点的左子节点</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> cChildNode = current.right</span><br><span class="line">            <span class="keyword">var</span> cParentNode = current!!</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cChildNode?.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                cParentNode = cChildNode</span><br><span class="line">                cChildNode = cChildNode.left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后继节点</span></span><br><span class="line">            cParentNode.left = cChildNode!!.right</span><br><span class="line">            cChildNode!!.right = current.right</span><br><span class="line">            cChildNode!!.left = current.left</span><br><span class="line">            <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                parent.right = cChildNode</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = cChildNode</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                parent.right = <span class="literal">null</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = current.right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.iId &gt; parent.iId) &#123;</span><br><span class="line">                parent.right = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.left = current.left</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>哈夫曼编码用来对一段文本进行压缩，解压。</p><blockquote><p>压缩：用字符的编码替代字符</p><p>解压：用字符代替对应的编码</p></blockquote><p>实现思路如下：</p><ul><li>将字符按照出现的频次生成优先级队列；</li><li>依次<strong>取出</strong>两个最小的字符，为他们生成一个父节点（父节点频次为两个子节点之和）；</li><li>并将插入优先级队列中，依次循环直到优先级队列中只有一个节点——哈夫曼树的根节点；</li><li>从哈夫曼树的根开始，以向左为0，向右为1对其叶子节点上的字符赋予编码。</li></ul><p>其过程如下图所示：</p><p><img src="https://jixiaoyong.github.io/images/20190103203447.png" alt="哈夫曼编码示意图"></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/BinaryTree.kt" target="_blank" rel="noopener">👉点这里</a> 查看<code>二叉树</code>源码</p><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/HuffmanCodeUtils.kt" target="_blank" rel="noopener">👉点这里</a> 查看<code>哈夫曼编码</code>源码</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_二叉树.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_高级排序</title>
      <link href="/blog/posts/2041f2cb/"/>
      <url>/blog/posts/2041f2cb/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍两种高级排序：希尔排序和快速排序。</p><p>希尔排序的时间复杂度是$O(N*(LogN)^2)$，简单易实现，在所有排序中可以优先使用。</p><p>快速排序的时间复杂度是$O(N*LogN)$，是所有通用排序中最快的。</p><p>排序方向：<code>小 → 大</code>。</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序基于插入排序（将左边无须的元素依次插入到右边有序数组中），不同的是希尔排序的增量逐渐减小到1，而插入排序的增量一直是1。</p><blockquote><p>增量 排序的时候进行比较的两个元素之间的间隔：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>对于数组<code>arr</code>中的元素来说，<code>1</code>和 <code>2</code>之间的增量是1，而 <code>1</code>和 <code>3</code>之间的增量是2，以此类推。</p></blockquote><p>由于插入排序在排序进行到后期，右边有序数组的大小变大，导致插入和移动的次数越来越多，而且如果数组恰好是反序的，会很耗时。</p><p>而希尔排序在刚开始排序时，先取一个适当的增量<code>n</code>，按照这个增量对数组<code>arr</code>进行插入排序，得到一个<em>基本有序</em>的数组，他内部有<code>n</code>个有序的子数组；再将增量<code>n</code>减一，在此进行插入排序；如此反复直到n为1，排序完毕的数据即为有序数组。</p><p><img src="https://jixiaoyong.github.io/images/20190103191850.png" alt="希尔排序——4增量排序示意图"></p><h2 id="增量的选择"><a href="#增量的选择" class="headerlink" title="增量的选择"></a>增量的选择</h2><p>可以想象，增量的计算对希尔排序效率有很大影响。</p><p>这些增量的集合称为<strong>间隔序列</strong>，一般要求这些增量之间互质，这样就不会对已经排序的数组再次排序。</p><p>一个常用的间隔序列计算公式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h=<span class="number">3</span>h+<span class="number">1</span></span><br><span class="line">计算的h值一般为：<span class="number">1</span>,<span class="number">13</span>,<span class="number">40</span>,<span class="number">21</span>...</span><br></pre></td></tr></table></figure><p>增量<code>h</code>要小于数组大小。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * 思路:</span></span><br><span class="line"><span class="comment"> * 1/3 将待排序数组分为h个间隔为h的小数组，</span></span><br><span class="line"><span class="comment"> * 2/3 对这些小数组进行插入排序,将排序结果写入原待排序数组</span></span><br><span class="line"><span class="comment"> * 3/3 按照 h=3*h+1 的算法减小h在此进行希尔排序，直至h为1</span></span><br><span class="line"><span class="comment"> * --将大数组分为较小的数组，拍完序后再对这些"有序"的小数组进行排序</span></span><br><span class="line"><span class="comment"> * 小 - &gt; 大</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">shellSort</span><span class="params">(intArray: <span class="type">IntArray</span>, h: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> insertSort(intArray)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//间隔排序</span></span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">0</span> until h) &#123;<span class="comment">//依次遍历x,x+1,x+2 ... x+(h-1);形成h个有序子数组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> list = arrayListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">            intArray.forEachIndexed &#123; index, i -&gt;</span><br><span class="line">                <span class="keyword">if</span> ((index + x) % h == <span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(i)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> partSortArr = insertSort(list.toIntArray())</span><br><span class="line">            <span class="keyword">var</span> listIndex = <span class="number">0</span></span><br><span class="line">            intArray.forEachIndexed &#123; index, i -&gt;</span><br><span class="line">                <span class="keyword">if</span> ((index + x) % h == <span class="number">0</span>) &#123;</span><br><span class="line">                    intArray[index] = partSortArr[listIndex++]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将增量减小，再次减小排序，直到h==1</span></span><br><span class="line">        <span class="keyword">return</span> shellSort(intArray, (h - <span class="number">1</span>) / <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取希尔排序间隔</span></span><br><span class="line"><span class="comment"> * 对排序速度影响较大，要求互质，计算方式不唯一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getShellSortH</span><span class="params">(range: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (range &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; range) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (h - <span class="number">1</span>) / <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1/2 先假设第一个数是已经排好序的</span></span><br><span class="line"><span class="comment"> * 2/2 将后面的数字依次与其比较，并插入到对应位置</span></span><br><span class="line"><span class="comment"> * small -&gt; big</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertSort</span><span class="params">(intArray: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until intArray.size) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intArray[i] &lt; intArray[j]) &#123;</span><br><span class="line">                <span class="keyword">val</span> temp = intArray[i]</span><br><span class="line">                <span class="keyword">for</span> (x <span class="keyword">in</span> i downTo j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x - <span class="number">1</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    intArray[x] = intArray[x - <span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                intArray[j] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序在大多数情况下都是最快的。</p><h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><p>划分指在一组数据中，指定一个值<code>C</code>,所有小于<code>C</code>的移动到左边，所有大于<code>C</code>的移动到右边。</p><p>选出来的这个值<code>C</code>，叫做<strong>枢纽</strong>。</p><h3 id="划分算法"><a href="#划分算法" class="headerlink" title="划分算法"></a>划分算法</h3><ul><li>在数据左右两端各有一个指针指向当前元素：<code>left</code>，<code>right</code>；</li><li><code>left</code>指针向右移动查找比<code>C</code>大的值，<code>right</code>指针向左移动查找比<code>C</code>小的值，当遇到满足条件的元素则退出；</li><li>当两个指针都退出时，将其指向的元素交换位置，然后再分别移动指针，直到两个指针相遇，划分结束。</li></ul><h2 id="快速排序的思路"><a href="#快速排序的思路" class="headerlink" title="快速排序的思路"></a>快速排序的思路</h2><p>快速排序，选取一个枢纽，将数组<strong>划分</strong>为两个子数组，这样在枢纽<code>C</code>两边的数组满足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[左边子数组所有元素] &lt; n &lt; [右边子数组所有元素]</span><br></pre></td></tr></table></figure><p>这样将得到的每个子数组都划分为两个子数组，直到子数组只有一个元素（一个元素就是有序的），这样就完成了整个快速排序。</p><h2 id="枢纽的选择"><a href="#枢纽的选择" class="headerlink" title="枢纽的选择"></a>枢纽的选择</h2><p>枢纽选择影响着快速排序的效率：</p><ul><li>最简单的，可以选取数组第一个或者最后一个元素</li><li>“三数据项取中”法，在数组首、尾、中取数排序，选中间的数作为枢纽。这样排序数组大小要&gt;3。</li></ul><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序所用的数组，使用前先初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> quickArray: IntArray</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序算法</span></span><br><span class="line"><span class="comment"> * #1 选择数组最右端元素作为枢纽</span></span><br><span class="line"><span class="comment"> * 思想是</span></span><br><span class="line"><span class="comment"> * 1/2 选出一个枢纽，先将其按大小划分为左右两部分</span></span><br><span class="line"><span class="comment"> * 2/2 在划分好的两个数组中，分别再找一个枢纽，重复步骤1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quickSort1</span><span class="params">(left: <span class="type">Int</span>, right: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n 这个枢纽的取法很关键，决定了算法的速度</span></span><br><span class="line"><span class="comment">     * 除过这里用到的取法之外，还可以有"三数据项取中"法，在数组首、尾、中取数排序，选中间的数作为枢纽。这样排序数组要&gt;3</span></span><br><span class="line"><span class="comment">     * 对于这些小于3的数组可以用插入排序法进行排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> n = quickArray[right]</span><br><span class="line">    <span class="keyword">val</span> nIndex = devideArrayByN1(left, right, n)</span><br><span class="line">    <span class="keyword">if</span> (nIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        quickSort1(left, nIndex - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort1(nIndex + <span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 划分算法决定了排序的准确性</span></span><br><span class="line"><span class="comment"> * 提出一个阈值，并以此将数组划分为两部分</span></span><br><span class="line"><span class="comment"> * 左边都小于枢纽，右边都大于枢纽</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">devideArrayByN1</span><span class="params">(left: <span class="type">Int</span>, right: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> leftIndex = left - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> rightIndex = right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; quickArray[++leftIndex] &lt; n) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; quickArray[--rightIndex] &gt; n) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> temp = quickArray[leftIndex]</span><br><span class="line">        quickArray[leftIndex] = quickArray[rightIndex]</span><br><span class="line">        quickArray[rightIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> right downTo rightIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        quickArray[i] = quickArray[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    quickArray[rightIndex] = n</span><br><span class="line">    <span class="keyword">return</span> rightIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希尔排序、快速排序的思路，都是将一个大的待排序数组，通过不同的方法拆分成小的子数组，这样比较、移动的次数要小很多。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/sort/SortUtils.kt" target="_blank" rel="noopener">👉点这里</a> 查看源码</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_高级排序.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_递归和汉诺塔问题</title>
      <link href="/blog/posts/466fbe25/"/>
      <url>/blog/posts/466fbe25/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍了递归，归并排序，还有递归在汉诺塔问题上的应用。</p><p>排序顺序为 <code>小 → 大</code></p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归是一种在函数内部调用自己的函数。在满足一定条件后可以退出递归。</p><p>比如三角数组就是一个简单的递归：</p><blockquote><p>有一组数据，满足这样的条件<code>第n项</code> = <code>第n-1项</code> + <code>n</code>，就称为三角数组，如：</p><p><code>1,2,6,10,15,21...</code></p></blockquote><p>这里面，<strong><code>第n项</code> = <code>第n-1项</code> + <code>n</code></strong>,就是一个递归，每一项的计算结构都依赖于前一项的计算，直到第1项的计算结果为确定的1，不再继续递归。</p><p>实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三角数</span></span><br><span class="line"><span class="comment"> * 第n个数 == 第n-1个数 + n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">triangleNum</span><span class="params">(num: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num + triangleNum(num - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h1><p>汉诺塔是一种游戏，有三个柱子，其中一棵柱子上面有若干个半径依次递减的空心圆盘，每次只能移动最顶端的圆盘，并且下面的圆盘要比上面的圆盘直径大。游戏的目的就是在满足这些条件的前提下，将所有圆盘依次转移到另外一个圆盘上面。</p><p><img src="https://jixiaoyong.github.io/images/20190102201005.png" alt="汉诺塔问题分析"></p><p>如图，实现的思路就是递归：</p><ol><li><p>将除最底部的圆盘<code>bottom</code>之外的所有圆盘当做一个整体<code>other</code>，那么问题就变成了如何将<code>bottom</code>和<code>other</code>这“两”个圆盘通过<code>柱子B</code>，移动到<code>柱子C</code>，这个问题显然很好解决，只需要将<code>other</code>移动到<code>柱子B</code>，再将<code>bottom</code>移动到<code>柱子C</code>即可。</p></li><li><p>那么剩下的问题就成了如何将<code>other</code>从<code>柱子A</code>移动到<code>柱子B</code>，很显然可以参照<code>步骤1</code>。</p></li><li>这样子这个问题就成了如何将一个<code>bottom</code>从一个柱子，移动到另外一个柱子的问题，而每个这样的问题的解决都依赖于<code>other</code>的解决，而这就是递归。</li></ol><p>具体实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 汉诺塔问题</span></span><br><span class="line"><span class="comment"> * 将汉诺塔问题简化为3步：</span></span><br><span class="line"><span class="comment"> * 1/3 将最上层n-1项移动到过渡层</span></span><br><span class="line"><span class="comment"> * 2/3 将最底层n移动到目标层</span></span><br><span class="line"><span class="comment"> * 3/3 将n-1项移动到目标层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要移动的层数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> from 所在层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inter 过渡层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 目标层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hanioStepNum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hanioTower</span><span class="params">(num: <span class="type">Int</span>, from: <span class="type">String</span>, inter: <span class="type">String</span>, to: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        println(<span class="string">"move 1 to <span class="variable">$to</span>"</span>)</span><br><span class="line">        hanioStepNum++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hanioTower(num - <span class="number">1</span>, from, to, inter)<span class="comment">//把`other`移动到中间柱子</span></span><br><span class="line">        println(<span class="string">"move <span class="variable">$num</span> to <span class="variable">$to</span>"</span>)<span class="comment">//把`bottom`移动到目标柱子</span></span><br><span class="line">        hanioStepNum++</span><br><span class="line">        hanioTower(num - <span class="number">1</span>, inter, from, to)<span class="comment">//把`other`移动到目标柱子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序<code>merge</code>，将一个数组，分成两个子数组分别排序，之后再将拍好序的数组合并，这样就得到了一个有序数组。时间复杂度是$O(N*Log(N))$。</p><p>其思路是，将数组无限的分成两份分别进行排序，然后再将排好序的两个数组归并在一起得到有序数组。每个子数组的有序都依赖于其子数组的有序，直到每个子数组只有一个元素，这样的数组本身就是有序的。</p><p>原理如下（假设序列共有n个元素）：</p><ol><li>将序列每相邻两个数字进行<strong>归并操作</strong>，形成两个<code>n/2</code>序列，排序后每个序列包含1/2元素</li><li>若此时序列数不是1个，则将上述序列再次归并，分别形成两个<code>n/4</code>序列，每个序列包含1/4个元素</li><li>重复步骤2，直到所有元素排序完毕，即序列数为1</li></ol><p><img src="https://zh.wikipedia.org/wiki/File:Merge-sort-example-300px.gif" alt="归并排序动态演示"></p><p><strong>合并两个有序的数组(<code>a</code>,<code>b</code>)思想</strong>：</p><p>将<code>b</code>中比<code>a</code>中小的元素都复制到<code>a</code>中对应位置，然后将剩下的元素全部依次复制到<code>a</code>的末尾。</p><p>归并排序具体实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * 归并排序占空间（多占一个排序数组的大小），排序快（N*LogN）</span></span><br><span class="line"><span class="comment"> * 思想是:</span></span><br><span class="line"><span class="comment"> * 1/2 将数组无限分成两份，直到两份数组都是有序的（每个数组只有一个元素）</span></span><br><span class="line"><span class="comment"> * 2/2 再对其进行归并</span></span><br><span class="line"><span class="comment"> * 小 -&gt; 大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intArr 待排序的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mergeSort</span><span class="params">(intArr: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">var</span> size = intArr.size</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> intArr</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> half = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (size % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            half = size / <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            half = (size + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr1 = intArr.copyOfRange(<span class="number">0</span>, half)</span><br><span class="line">        <span class="keyword">val</span> arr2 = intArr.copyOfRange(half, intArr.size)</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(arr1), mergeSort(arr2))<span class="comment">//将合并好的两个有序子数组合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并</span></span><br><span class="line"><span class="comment"> * 合并两个有序的数组为新的有序数组</span></span><br><span class="line"><span class="comment"> * 思想：</span></span><br><span class="line"><span class="comment"> * 1/2 相互比较两个数组每项大小，并将小的复制到新数组</span></span><br><span class="line"><span class="comment"> * 2/2 将剩余的数组全部复制到新数组</span></span><br><span class="line"><span class="comment"> * 小 -&gt; 大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intArrA 有序数组1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intArrB 有序数组2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(intArrA: <span class="type">IntArray</span>, intArrB: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">var</span> resultArr = IntArray(intArrA.size + intArrB.size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> indexA = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> indexB = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> indexC = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (indexA &lt; intArrA.size &amp;&amp; indexB &lt; intArrB.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intArrA[indexA] &lt; intArrB[indexB]) &#123;</span><br><span class="line">            resultArr[indexC++] = intArrA[indexA++]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultArr[indexC++] = intArrB[indexB++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (indexA &lt; intArrA.size) &#123;</span><br><span class="line">        resultArr[indexC++] = intArrA[indexA++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (indexB &lt; intArrB.size) &#123;</span><br><span class="line">        resultArr[indexC++] = intArrB[indexB++]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>👉<a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/link/Triangle.kt" target="_blank" rel="noopener">点这里</a> 查看<code>汉诺塔</code>和<code>递归排序</code>源码</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">归并排序——维基百科</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_递归和汉诺塔问题.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_栈和队列</title>
      <link href="/blog/posts/8d059318/"/>
      <url>/blog/posts/8d059318/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍栈、队列两种抽象数据类型。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈<code>stack</code>，又称堆栈，是一种抽象数据类型，每次只能访问栈顶元素<code>top</code>，可以进行压入<code>push</code>和推出<code>pop</code>操作。其元素<strong>先进后出(FILO)</strong>。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列<code>queue</code>,是和栈相对的一种抽象数据类型，每次从后端<code>rear</code>插入，从前端<code>front</code>删除。其元素<strong>先进先出(FIFO)</strong>。</p><p>用链表实现的队列可以自由扩充，不存在伪溢出问题，但是插入和读取比较耗时；</p><p>用数组实现的队列大小固定，可以使用<strong>循环队列</strong>解决伪溢出问题，即当尾端（前端也类似）指针指向超出数组大小时，可以指向数组开始位置，因为此时大小不超过数组的队列前端已经指向0之后的位置了，所以不会冲突。</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>和队列定义一致，只是在每次插入的时候都进行排序，以满足排序规则（如<code>尾端→前端</code> <code>小→大</code>）。</p><h1 id="中缀表达式与后缀表达式"><a href="#中缀表达式与后缀表达式" class="headerlink" title="中缀表达式与后缀表达式"></a>中缀表达式与后缀表达式</h1><p>中缀表达式，指运算符在操作数中间的，如<code>1 + 2</code>。</p><p>后缀表达式，指运算符在操作数后面的，如<code>1 2 +</code>。</p><p>中缀表达式 ↔ 后缀表达式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中缀表达式：<span class="number">1</span> + <span class="number">2</span> * ( <span class="number">3</span> + <span class="number">5</span> ) - <span class="number">2</span> * <span class="number">3</span> - <span class="number">9</span> / <span class="number">2</span></span><br><span class="line">后缀表达式：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> + * + <span class="number">2</span> <span class="number">3</span> * - <span class="number">9</span> <span class="number">2</span> / -</span><br></pre></td></tr></table></figure><p>转换规则：</p><p>设一个栈用于保存运算符，从左到右依次遍历中缀表达式，假设读取到的是<code>x</code></p><ol><li><p>如果是操作数，则直接打印</p></li><li><p>如果是运算符<code>(</code>，则压入栈中</p></li><li><p>如果是运算符<code>)</code>，则推出栈中的元素，直到遇到<code>(</code>,推出<code>(</code>，继续读取下一个</p></li><li><p>否则，读取栈顶元素<code>top</code>，如果是<code>(</code>，将<code>x</code>压入栈中；</p><p>如果<code>x</code>优先于<code>top</code>，将<code>x</code>压入栈中；</p><p>否则，将<code>top</code>推出，在此和新的<code>top</code>比较，直到遇到<code>top</code>是<code>(</code>或者优先级比<code>x</code>高，或者栈已经空了，将<code>x</code>插入栈中。</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中缀表达式转化为后缀表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> infix 中缀表达式 1+2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 后缀表达式 1 2 +</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> static String[] covertInfixToPostfix(String <span class="keyword">infix</span>) &#123;</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    OperatorStack operatorStack = new OperatorStack();</span><br><span class="line">    <span class="keyword">for</span> (char item : <span class="keyword">infix</span>.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// 数字</span></span><br><span class="line">        <span class="keyword">if</span> (item &gt;= <span class="string">'0'</span> &amp;&amp; item &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            stringBuilder.append(item + <span class="string">","</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">'('</span>) &#123;</span><br><span class="line">            operatorStack.insert(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">')'</span>) &#123;</span><br><span class="line">            int size = operatorStack.size();</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    char pop = operatorStack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (pop == <span class="string">'('</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        stringBuilder.append(pop + <span class="string">","</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"栈为空"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                char peek = operatorStack.peek();</span><br><span class="line">                <span class="keyword">if</span> (peek == <span class="string">'('</span>) &#123;</span><br><span class="line">                    operatorStack.insert(item);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPre(item, peek) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    operatorStack.insert(item);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    int size = operatorStack.size();</span><br><span class="line">                    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            char pop = operatorStack.peek();</span><br><span class="line">                            <span class="keyword">if</span> (pop == <span class="string">'('</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPre(item, peek) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                stringBuilder.append(pop + <span class="string">","</span>);</span><br><span class="line">                                operatorStack.pop();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    operatorStack.insert(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.err.println(<span class="string">"栈为空"</span>);</span><br><span class="line">                operatorStack.insert(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size = operatorStack.size();</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stringBuilder.append(operatorStack.pop() + <span class="string">","</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"栈为空"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String result = stringBuilder.toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.split(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>👉<a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/InfixAndPostfix/CovertInfixToPostfix.java" target="_blank" rel="noopener">点这里</a>查看<code>中缀表达式 → 后缀表达式</code>源码</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">堆栈——维基百科</a></p><p><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">队列——维基百科</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_栈和队列.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_数组，链表</title>
      <link href="/blog/posts/9a784fe0/"/>
      <url>/blog/posts/9a784fe0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍了数组、链表等数据结构。</p><p>设定所有排序：小→大。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组（array）是一组具有相同类型元素的集合，用一段连续的内存来保存。使用下标来访问保存的元素，如<code>a[0]</code>。</p><p>数组是一种数据存储结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>数组大小固定，对指定下标元素读写快O(1)，但是查找慢O(N)，删除元素慢O(N)。</p><h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>在每次插入的时候对元素进行排序，就得到有序数组。</p><p>有序数组查找快O(LogN)，但插入慢O(N)，删除元素慢O(N)。</p><p><strong>有序数组插入</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertSort</span><span class="params">(key: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= sortArr.size) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        sortArr[size++] = key</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> insertIndex = ++size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (key &lt; sortArr[insertIndex - <span class="number">1</span>]) &#123;</span><br><span class="line">        sortArr[insertIndex] = sortArr[insertIndex - <span class="number">1</span>]</span><br><span class="line">        insertIndex--</span><br><span class="line">        <span class="keyword">if</span> (insertIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortArr[insertIndex] = key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有序数组要找到某个元素t可以使用二分查找，其思想是：</p><ol><li>选取一个中间值n将当前数组一分为二。</li><li>如果<code>t==n</code>那么查找结束，如果<code>t&lt;n</code>,那么在右半部分数组查找，否则在左半部分数组查找。</li><li>重复步骤<code>1</code>,<code>2</code>，直到找到n或者数组已经不可再分（不存在n），结束查找。</li></ol><p><strong>二分法查找</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dichotomy</span><span class="params">(array: <span class="type">IntArray</span>, key: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> centerIndex = array.size / <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> centerKey = array[centerIndex]</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        key == centerKey -&gt; centerIndex</span><br><span class="line">        key &lt; centerKey -&gt; dichotomy(array.copyOfRange(<span class="number">0</span>, centerIndex), key)</span><br><span class="line">        <span class="keyword">else</span> -&gt; dichotomy(array.copyOfRange(centerIndex - <span class="number">1</span>, array.size), key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表的每个节点除了保存的数据外，还保存着下一个节点的引用<code>next</code>，最后一个元素中该引用为<code>null</code>。</p><p>链表的大小不固定，查找，删除，插入指定节点都需要O(N)</p><p>链表有以下分类：</p><ul><li><p>单链表 每个节点只有指向下一个节点的引用，链表只保留第一个链节点的引用<code>first</code></p><p><img src="https://jixiaoyong.github.io/images/20190101132535.png" alt="单链表"></p></li><li><p>双向链表 每个节点保存有父节点和子节点的引用。双向链表也可以是双端链表。</p><p><img src="https://jixiaoyong.github.io/images/20190101132614.png" alt="双向链表"></p></li></ul><p><strong>双端链表</strong> 双端链表保存第一个链节点<code>farst</code>和最后一个链节点<code>last</code>的引用。</p><p><img src="https://jixiaoyong.github.io/images/20190101132649.png" alt="双端链表"></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/tree/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/link" target="_blank" rel="noopener">👉点这里</a> 查看<code>链表</code>源码</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">数组–维基百科</a></p><p><a href="https://book.douban.com/subject/1144007/" target="_blank" rel="noopener">Java数据结构和算法（第二版）Robert Laforce 计晓云等译</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_数组和链表.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_简单排序</title>
      <link href="/blog/posts/125c8a12/"/>
      <url>/blog/posts/125c8a12/</url>
      
        <content type="html"><![CDATA[<h1 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h1><p>所有排序顺序为 <code>小 → 大</code>。</p><p>时间负责度都是O(N^2^)。</p><p>排序速度：<code>插入排序&gt;选择排序&gt;冒泡排序</code></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度：O(N^2^) </p><p>最慢的排序，但是简单</p><p>规则如下：</p><ol><li>从左到右，比较a和b，如果<code>a&gt;b</code>，就交换a和b的位置</li><li>再将a，b中较大的那个与c按照2的规则比较，直到最后一位</li><li>重复1，2直到没有待排序的项目</li></ol><p>其思想是：每次选出当前未排序的元素中最大的元素并放到队尾（每次比较最大元素都会“冒泡”到队尾），这样当连续遍历n次后，每个元素都会排好序。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     * 1. 每次比较前1~（n-i）个元素（i是排序次数），每次有大的就【移动】，</span></span><br><span class="line"><span class="comment">     * 这样子一轮比赛完毕最大的就在后面了</span></span><br><span class="line"><span class="comment">     * 2. 这样子比较n次就可以完成排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bubbleSort</span><span class="params">(intArray: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">var</span> result = intArray</span><br><span class="line">        <span class="keyword">var</span> size = result.size</span><br><span class="line">        <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">0</span> until size - index - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result[x] &gt; result[x + <span class="number">1</span>]) &#123;<span class="comment">//【注意】冒泡排序，每次比较满足条件就会交换</span></span><br><span class="line">                    <span class="keyword">var</span> temp = result[x]</span><br><span class="line">                    result[x] = result[x + <span class="number">1</span>]</span><br><span class="line">                    result[x + <span class="number">1</span>] = temp</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>时间复杂度：O(N^2^) </p><p>因为交换次数少，所以比冒泡快</p><p>规则如下：</p><ol><li>假设第一项值最大，设其坐标为<code>max</code>，从左到右依次比较<code>max</code>和其他元素，如果遇到比<code>max</code>大的，将max坐标指向该值</li><li>每轮结束后<code>max</code>就表示这轮比较最大的值坐标，将其与当前未排序的最后一项交换</li><li>这样重复步骤1，2， <code>n次</code>就可以排序完成</li></ol><p>其思想是：每次比较当前最大的值，记录下其坐标，等当前比较完成就和<code>未比较的最后一位</code>交换，（这样子避免每次比较都要交换）。同样这样子比较n次就可以完成排序。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 1. 每次比较前1~（n-i）个元素（i是排序次数），如果有大的就记录下位置，一轮比较完毕后交换他和最后一位的位置</span></span><br><span class="line"><span class="comment"> * 2. 这样子比较n次就可以完成排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">selectSort</span><span class="params">(intArray: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">var</span> result = intArray</span><br><span class="line">    <span class="keyword">var</span> size = result.size</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">0</span><span class="comment">//假设arr[0]最大</span></span><br><span class="line">        <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">0</span> until size - index - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result[max] &lt; result[x + <span class="number">1</span>]) &#123;<span class="comment">//将max与每一项比较，注意这里参与比较的是max</span></span><br><span class="line">                max = x + <span class="number">1</span><span class="comment">//遇到比max大的则记录下其位置 【注意】这里并没有交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在每轮比较完毕后max就是这轮比较出来的最大值位置，将其放到对应位置</span></span><br><span class="line">        <span class="keyword">var</span> temp = result[size - index - <span class="number">1</span>]</span><br><span class="line">        result[size - index - <span class="number">1</span>] = result[max]</span><br><span class="line">        result[max] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度：O(N^2^) </p><p>比冒泡快一倍，比选择排序快一些</p><p>思想：假设一个标记元素的左边全部是有序数组，右边全是无序数组，那么只需要将右边的元素依次拿出来插入到左边的有序数组中即可。刚开始这个标记元素可以为0或者1（假设一个元素就是有序的）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 假设右端数组是有序的，依次从左端数组取出元素比较，插入到右边的有序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insertSort</span><span class="params">(intArray: <span class="type">IntArray</span>)</span></span>: IntArray &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = intArray</span><br><span class="line">    <span class="keyword">var</span> size = result.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (insertIndex <span class="keyword">in</span> <span class="number">1</span> until size ) &#123;<span class="comment">//假设arr[0]已经是有序的，所以从1开始</span></span><br><span class="line">        <span class="keyword">var</span> insertPoint = result[insertIndex]</span><br><span class="line">        <span class="keyword">for</span> (index <span class="keyword">in</span> insertIndex - <span class="number">1</span> downTo  <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (insertPoint &lt; result[index]) &#123;</span><br><span class="line">                <span class="comment">//默认要插入的点是有序的，如果有比插入点大的，则将该点和插入点交换</span></span><br><span class="line">                result[index + <span class="number">1</span>] = result[index]</span><br><span class="line">                result[index] = insertPoint</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//因为左边的数组是有序的，只要有比插入点小的元素，则剩下的肯定都小于该元素，不用再比较了</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/sort/BasicSort.kt" target="_blank" rel="noopener">👉点这里</a>查看源码</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_简单排序.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_图</title>
      <link href="/blog/posts/a71f2ecc/"/>
      <url>/blog/posts/a71f2ecc/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>图</strong>，是由可以有多个边的顶点组成的结构。</p><p>两个顶点之间有边连接，则称这两个顶点是<strong>邻接</strong>的。</p><p>几个相互邻接的顶点组成的线叫做<strong>路径</strong>,至少有一条路径可以到达所有顶点的图叫做<strong>连通图</strong>。</p><p>如果图的顶点只能从A→B，不能从B→A，就称图是<strong>有向图</strong>。</p><p>如果边被赋予一定的权值（数字），就称图为<strong>带权图</strong></p><p><img width="30%" height="30%" src="https://jixiaoyong.github.io/images/20181227232301.png"></p><h1 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h1><p>图一般有两种存储方式：</p><ul><li><p>邻接矩阵 用N*N的数组保存图中所有的顶点,<code>Arr[m][n]</code>即表示m、n顶点是否邻接（Y:1,N:0）。</p><p>比较占地方。</p><p><img src="https://jixiaoyong.github.io/images/20181227233341.png" alt="邻接矩阵"></p></li><li><p>邻接表 用一个N大小的数组保存，数组元素是保存着顶点和他所有的邻接点的链表。</p><p><img src="https://jixiaoyong.github.io/images/20181227233435.png" alt="邻接表"></p></li></ul><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>图的操作有插入（顶点），搜索等等。</p><p>以下操作以邻接表方式为例。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入分为插入顶点和插入边。</p><p>插入边的时候需要注意，要同时更新start和end两个顶点对应的链表。</p><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>原理同插入边。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>搜索要求从某个特定顶点开始，沿着边移动到其他顶点，移动完毕后要保证访问了每个顶点。</p><p>搜索又分为DFS（深度优先搜索）、BFS（广度优先搜索）。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS的思想是，依次沿着顶点某一个邻接点，纵深访问，将该邻接点当做新的顶点压入栈中，继续纵深访问，直到有顶点没有可以访问的邻接顶点，将其打印出来（从栈中推出）；然后再返回上一层的邻接顶点中还可以访问的顶点（查找当前栈顶元素未访问的邻接点），直到没有可以访问的顶点。</p><p>用栈实现，会先往深处遍历完一条路径，再遍历下一条。每个顶点只访问一次</p><p>规则：</p><ul><li>1/3 访问一个邻接的未访问顶点，访问并标记，将其压入栈中；</li><li>2/3 当规则1不能满足时，如果栈不为空，从栈中弹出一个顶点；</li><li>3/3 1,2都无法满足时，搜索结束。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stacks = DfsStacks(hashMap.size)</span><br><span class="line">    <span class="keyword">var</span> keyArr = hashMap.keys.toIntArray()</span><br><span class="line">    stacks.push(keyArr[<span class="number">0</span>])</span><br><span class="line">    hashMap[keyArr[<span class="number">0</span>]]?.isVisited = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> index = hashMap[keyArr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> (stacks.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> availableKey = getAvailableNode(index!!.<span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (availableKey != -<span class="number">1</span>) &#123;</span><br><span class="line">            index = hashMap[availableKey]<span class="comment">//深度优先搜索，会先顺着一个邻接点一直走到头</span></span><br><span class="line">            index!!.isVisited = <span class="literal">true</span></span><br><span class="line">            stacks.push(availableKey)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pop = stacks.pop()</span><br><span class="line">            print(<span class="string">"<span class="variable">$pop</span> "</span>)</span><br><span class="line">            index = hashMap[stacks.peek()]<span class="comment">//如果一个邻接点再没有未访问的邻接点，那么去访问下一个未访问的邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS的思想是，向将当前顶点的所有可以访问的邻接点访问完毕；之后将该顶点打印（推出），再去访问其邻接点的所有可以访问邻接点（从队列头取出一个顶点，查找其未访问的邻接点）。</p><p>用队列实现，会先遍历完本层所有的顶点，然后再移向下一层</p><p>规则：</p><ul><li>1/3 先访问当前顶点的所有邻接顶点，标记，并插入到队列；</li><li>2/3 如果没有可以访问的邻接点，且队列不为空，从队列头取出一个顶点[此处又用到了一次该点]，使其成为当前顶点，重复1；</li><li>3/3 如果2不能满足，搜索结束。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bfs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> queue = BfsQueue()</span><br><span class="line">    <span class="keyword">var</span> keyArr = hashMap.keys.toIntArray()</span><br><span class="line">    queue.push(keyArr[<span class="number">0</span>])</span><br><span class="line">    hashMap[keyArr[<span class="number">0</span>]]!!.isVisited = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> index = hashMap[keyArr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> (queue.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> availableKey = getAvailableNode(index!!.<span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">if</span> (availableKey != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> current = hashMap[availableKey]!!<span class="comment">//广度优先搜索，优先将一个节点的所有邻接点依次访问</span></span><br><span class="line">            current.isVisited = <span class="literal">true</span></span><br><span class="line">            queue.push(current.<span class="keyword">data</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> pop = queue.pop()</span><br><span class="line">            print(<span class="string">"<span class="variable">$pop</span> "</span>)</span><br><span class="line">            <span class="keyword">if</span> (queue.peek() == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            index = hashMap[queue.peek()]<span class="comment">//如果该点没有未访问的邻接点，就选择去访问该点邻接点的邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树MST"><a href="#最小生成树MST" class="headerlink" title="最小生成树MST"></a>最小生成树MST</h1><blockquote><p>生成树（Template:Lang-en-short）是具有图G的全部顶点，但边数最少的连通子图.</p><p>——维基百科</p></blockquote><p>带权图的生成树中，总权重最小的称为最小生成树。</p><p>最小生成树边比顶点数小1。</p><ul><li><p>当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。</p></li><li><p>如果图的每一条边的权值都互不相同，那么最小生成树将只有一个。</p></li></ul><p>无向不带权图中，只需要找出最小数量的边即可。用DFS比较好实现，因为他对每个顶点只访问一次。</p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序是指<strong>有向图</strong>的顶点排序，满足以下条件<a href="#参考资料">*</a>：</p><ol><li>每个顶点出现且只出现一次；</li><li>若A在序列中排在B的前面，则在图中不存在从B到A的<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%84_(%E5%9B%BE%E8%AE%BA" target="_blank" rel="noopener">路径</a>)。</li></ol><p>实现思路是：</p><ul><li><p>依次推出有向图中没有后继点的顶点作为排序的最后项，这是因为按照拓扑排序<code>条件2</code>没有后继点的顶点必然排在后面；</p></li><li><p>当去掉没有后继点的顶点后又会产生新的没有后继点的顶点，这样依次循环，当图中没有顶点的时候，就可以在有向无环图中完成拓扑排序。</p></li></ul><p>对于有环存在（即存在类似A→B，B→C，C→A的情况）的有向图，会出现找不到<code>没有后继点的顶点</code>，但同时<code>图中顶点数不为0</code>的情况，遇到这种情况退出循环，并说明有环存在即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拓扑排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">topologicalSort</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashMap.size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> displayList = ArrayList&lt;T?&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hashMap.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> successorKey = getSuccessorNode()</span><br><span class="line">        <span class="keyword">if</span> (successorKey == <span class="literal">null</span>) &#123;<span class="comment">//图中还有顶点，但却找不到“没有后继点的顶点”，说明有环</span></span><br><span class="line">            println(<span class="string">"图中有环"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.remove(successorKey)<span class="comment">//如果找到满足条件的顶点，从图中删除并保存的排序结果中</span></span><br><span class="line">            displayList.add(successorKey)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"\n <span class="subst">$&#123;displayList.reversed()&#125;</span> \n"</span>)<span class="comment">//以正确的顺序输出排序结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历图，查找没有后继点的顶点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> -1表示没有这样的点 否则返回该点key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSuccessorNode</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">val</span> result: T? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> ketSet = hashMap.keys</span><br><span class="line"></span><br><span class="line">    ketSet.map &#123;<span class="comment">//遍历图中每个顶点</span></span><br><span class="line">        <span class="comment">//如果顶点没有后继点(没有邻接点，或者邻接点已经被删除)就是满足条件</span></span><br><span class="line">        <span class="keyword">var</span> node: GraphicNode&lt;T&gt;? = hashMap[it]?.next ?: <span class="keyword">return</span> it</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> realNode = hashMap[node.<span class="keyword">data</span>]</span><br><span class="line">            <span class="keyword">if</span> (realNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@map</span><span class="comment">//有后继点，不满足条件，查找下一个顶点</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next<span class="comment">//还有其他邻接点，依次遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result<span class="comment">//没有找到“没有后继点的顶点”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/GraphClazz.kt" target="_blank" rel="noopener">👉点这里</a> 查看<code>DFS/BFS/MST</code>源码</p><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/graph/Digraph.kt" target="_blank" rel="noopener">👉点这里</a> 查看<code>拓扑排序</code>源码</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">拓扑排序——维基百科</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_图.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_堆</title>
      <link href="/blog/posts/b3af796a/"/>
      <url>/blog/posts/b3af796a/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆是一种特殊的二叉树，用他实现的优先级队列插入和删除时间复杂度都是$O(LogN)$ 。</p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ol><li>堆是完全二叉树<a href="#完全二叉树">*</a></li><li>常用数组实现</li><li>每个堆的节点都满足堆的条件，即堆的每个节点关键字都大于（或等于）子节点的关键字</li></ol><p><code>特征3</code>保证了根节点是堆中最大的值，以及顺着某一个节点一直到遇到叶节点的路径上的节点关键字是依次递减的，但是没法保证这个值是这个堆中的最小值，这是因为堆中每个节点的左右子节点的位置和大小无关，两条这样的路径之前的值的大小没有一定的关系。</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>堆可以进行插入、移除，遍历等操作，时间复杂度都是$O(LogN)$。初次之外，利用堆根节点关键值最大这个属性，还可以进行堆排序,时间复杂度为$O(N*LogN)$。</p><p>对于在数组中保存的堆，设元素下标为<code>x</code>，则各个相关元素下标如下：</p><ul><li>父节点<code>(x-1)/2</code></li><li>左子节点 <code>2*x+1</code></li><li>右子节点 <code>2*x+2</code></li></ul><p>在插入，移除的时候为了保证满足堆的条件，需要对堆进行向上或向下的遍历，将修改的值移动到对应的位置，在这过程中涉及到复制和交换。如果每次比较都需要交换数据的话会复制很多次，而如果将最终要移动值保存在临时变量中，用一个值专门记录要移动到的下标，在每次符合条件时只复制参与对比的值，在最后再将要临时保存的值复制到目的下标，就会减少复制的次数。</p><p>如下图就将复制次数从9次减少到了5次。</p><p><img src="https://jixiaoyong.github.io/images/20181225213813.png" alt=""></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入操作思路是，将元素插入到数组最后一位，然后依次向元素父节点遍历，将不满足的元素下沉，直到找到满足<code>堆特征3</code>（父节点关键字大于该点，并且子节点关键字小于该点）的下标，或者指向了根目录，将该元素插入该处。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下向上遍历</span></span><br><span class="line"><span class="comment">    * 如果父节点比插入值小，就将父节点移动到插入值的位置，将toIndex指向空出的地方</span></span><br><span class="line"><span class="comment">    * 依次查找，直到查找到父节点比插入值大，子节点比插入值小的地方，或者指向了根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkUp</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">       <span class="keyword">var</span> bottom = headArray[index]<span class="comment">//headArray是保存堆元素的数组</span></span><br><span class="line">       <span class="keyword">var</span> toIndex = index</span><br><span class="line">       <span class="keyword">var</span> father = (toIndex - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">       <span class="keyword">while</span> (toIndex &gt; <span class="number">0</span> &amp;&amp; bottom!!.key &gt; headArray[father]!!.key) &#123;</span><br><span class="line">           headArray[toIndex] = headArray[father]<span class="comment">//将父节点下沉</span></span><br><span class="line">           toIndex = father</span><br><span class="line">           father = (toIndex - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">       &#125;</span><br><span class="line">       headArray[toIndex] = bottom<span class="comment">//将该值插入到对应下标</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>移除指的是将根节点推出堆中。</p><p>基本思路是将根节点推出，再将数组最后一个节点（同时也是堆的最后一个节点）移动到根节点空出的位置，再依次向下遍历，直到将该节点放到符合堆条件的位置或者到达叶子节点。</p><p>和插入相比，移除时要移动的节点要比较的稍微多些。</p><ul><li>该节点是叶节点    直接插入✅</li><li>有两个子节点        和两个叶子节点中最大的比较，如果小于则交换，并再和新的子节点比较</li><li>只有左节点    如果左节点大于本节点则交换，否则就是该位置</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从上向下遍历</span></span><br><span class="line"><span class="comment"> * 如果遇到比当前值top大的就将其复制到当前位置toIndex，并记录下空出的位置为toIndex</span></span><br><span class="line"><span class="comment"> * 再以toIndex为起点向下比较，直到遇到top比父节点小，比子节点大的位置，或者叶子节点</span></span><br><span class="line"><span class="comment"> * 将top移动到该位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkDown</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> toIndex = index</span><br><span class="line">    <span class="keyword">var</span> top = headArray[size - <span class="number">1</span>]!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (toIndex &lt; size / <span class="number">2</span>) &#123;<span class="comment">//非叶子节点</span></span><br><span class="line">        <span class="keyword">var</span> leftIndex = <span class="number">2</span> * toIndex + <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> rightIndex = <span class="number">2</span> * toIndex + <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (headArray[rightIndex] == <span class="literal">null</span>) &#123;<span class="comment">//只有左节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (headArray[leftIndex]!!.key &gt; top.key) &#123;</span><br><span class="line">                headArray[toIndex] = headArray[leftIndex]</span><br><span class="line">                toIndex = leftIndex</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (headArray[leftIndex] != <span class="literal">null</span> &amp;&amp; headArray[rightIndex] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (headArray[leftIndex]!!.key &gt;= headArray[rightIndex]!!.key) &#123;<span class="comment">//如果左节点比较大</span></span><br><span class="line">                <span class="keyword">if</span> (headArray[leftIndex]!!.key &gt; top.key) &#123;</span><br><span class="line">                    headArray[toIndex] = headArray[leftIndex]</span><br><span class="line">                    toIndex = leftIndex</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果右节点比较大</span></span><br><span class="line">                <span class="keyword">if</span> (headArray[rightIndex]!!.key &gt; top.key) &#123;</span><br><span class="line">                    headArray[toIndex] = headArray[rightIndex]</span><br><span class="line">                    toIndex = rightIndex</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    headArray[toIndex] = top<span class="comment">//将该节点移动到找到的下标处</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>利用堆<code>根节点关键值最大</code>这一特性，可以进行堆排序。</p><p>只需要将待排序的数组依次插入堆中，然后再依次移除即可。</p><p>这样需要有两倍与待排序数组大小的空间。如果每次插入时候只保存数据，不进行向上遍历，在每次移除数据时进行向下遍历，将当前剩余数据最大值选出来（其余数据仍然无序）从堆中移除根元素时都会在数组末尾空出一个位置，将该值存储在该位置即可，这样等完全插入、移除后就得到一个有序数组【从数组末尾开始依次减小】</p><p>堆排序和快速排序时间复杂度都是 <code>O(N*LogN)</code> ，但是由于向上、向下遍历耗时，实际上要比快速排序稍慢一些。但是堆排序堆数据初始分布不敏感一直都是 <code>O(N*LogN)</code> ，快速排序在某些情况下时间复杂度可达到 <code>O(N^2)</code> 。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>满二叉树指除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。</p><p>如果一个二叉树的层数为K，且节点总数是 $(2^k) -1$  ，则它就是满二叉树。</p><p><img src="https://jixiaoyong.github.io/images/20181225210750.png" alt="满二叉树"></p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树 如果将二叉树每层从左到右遍历，那么完全二叉树只有最后一层的右边会出现没有叶子节点的情况，即在前1~n之间没有“洞”。</p><p>如下图就是一个完全二叉树：</p><p><img src="https://jixiaoyong.github.io/images/20181225211304.png" alt="完全二叉树"></p><p>但下图不是完全二叉树：</p><p><img src="https://jixiaoyong.github.io/images/20181223211217.png" alt="不是完全二叉树"></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/HeadClazz.kt" target="_blank" rel="noopener">👉点这里</a> 查看源码</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">满二叉树——百度百科</a></p><p><a href="https://blog.csdn.net/u013812939/article/details/46798743" target="_blank" rel="noopener">完全二叉树与满二叉树的区别</a></p><p>《Java数据结构和算法 （第二版）》 Robert Lafore 陈维宁</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_堆.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_Hash表</title>
      <link href="/blog/posts/1f6681a0/"/>
      <url>/blog/posts/1f6681a0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hash表是一种可以快速插入和查找的数据结构，将数据保存在通过hash函数计算得到的下标中。</p><p>插入和删除 所需时间为O(1)。在确定容量、无需遍历时效果最好。</p><p>当其大小接近容量时，效率会变得很差。</p><h1 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h1><p>Hash表有两种存储方式</p><ol><li><p>开放地址法</p><p>开放地址法，直接将数据存储在数组中。</p><p>当hash算出的地址已经被占用时，则走过一定的步长找到另外一个空位（在填充质数很大时就会很耗时）并保存数据。</p></li><li><p>链地址法</p><p>链地址法，创建保存数据的数组，该数组中不直接保存数据，而是保存一个用来存储这些数据的链表，将数据项直接存储的链表中。</p><p>当hash算法计算出的地址时，遍历数组中对应的链表找到空位并保存。</p></li></ol><p>其中，开放地址法又分为3种实现：</p><ul><li><p>线性探测</p><p>每次前进的步长为1</p><p>即查找的位置依次是<code>x + 1,2,3,4,5,……</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储达到容量2/3以上时候读写性能会很差</span><br></pre></td></tr></table></figure></li><li><p>二次探测</p><p>每次前进的步长为当前查找次数的平方</p><p>即查找的位置依次是<code>x + 1,4,9,……</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前几次找不到之后就会很恐慌，步长越来越大到后面无法继续下去</span><br></pre></td></tr></table></figure></li><li><p>再哈希法</p><p>每次前进的步长是根据另外一个hash算法计算出来的值</p><p>这个算法要求如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 与第一次hash输出不同  </span><br><span class="line"><span class="number">2</span>. 不能输出<span class="number">0</span></span><br></pre></td></tr></table></figure><p>已经有一个公认的比较好的二次hash算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stepSize = constant - (key % constant)</span><br><span class="line">如：stepSize = <span class="number">5</span> - (key % <span class="number">5</span>)</span><br><span class="line">* constant 是小于数组容量的质数</span><br></pre></td></tr></table></figure></li></ul><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p><strong>再哈希法 VS 二次探测法</strong></p><p>在小型哈希表中，再哈希法比二次探测好；</p><p>但如果容量充足，并且容量大小不再变化时，二次探测效果好，在装填因子小于0.5时几乎没有性能损失</p><p><strong>开放地址法 VS 链地址法</strong></p><p>hash表容器大小未知时，用链地址法比较好</p><p>当装填因子变得很大时，开放地址法性能下降很快，但链地址法只是线性下降。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/Hash.kt" target="_blank" rel="noopener">👉点这里</a>查看源码</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_Hash表.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_红黑树</title>
      <link href="/blog/posts/11c01876/"/>
      <url>/blog/posts/11c01876/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>红黑树是一种特殊的二叉搜索树，查找，插入和删除的时间复杂度均为$O(log_2N)$。</p><p>红黑树必须满足以下条件：</p><ol><li><p>必须有颜色（黑/红）</p></li><li><p>根节点颜色为黑</p></li><li>若节点是红色，则子节点必须是黑色（反之则不然）</li><li>到叶节点或空子节点的每一条边上的黑色节点数量必须相同（空子节点指本应该有叶节点却没有的节点，默认为黑色）</li></ol><p>如果不满足可以通过以下方式修正：</p><ul><li>改变节点颜色</li><li>旋转（左、右）</li></ul><h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>以某个支点旋转（右旋为例，旋转时注意更新各个节点的父节点）：</p><p>本质是将该<code>节点a</code>向下进一位插入到其<code>右节点b</code>原先的位置，将其<code>左节点c</code>向上进一位插入到该<code>节点a</code>原先的位置，并将<code>左节点c的右节点</code>赋值给该<code>节点a</code>。</p><p>步骤：</p><ol><li><p>将该<code>节点a</code>放到<code>右节点b</code>的位置，将该<code></code>左节点c<code>放到</code>节点a`原先的位置，依次类推</p></li><li><p>特殊的，将该<code>点a的内侧孙子</code>（<code>a的左子节点c</code>的<code>右子节点d</code>）断开与其<code>父节点c</code>的连接，转而连接到<code>a</code>上，成为<code>a的左子节点</code></p></li></ol><p>如图，依次插入<code>6,34,23</code>，<strong>以<code>34</code>为支点右旋</strong>：</p><p><img src="https://jixiaoyong.github.io/images/20181223175956.png" width="50%" height="50%"></p><p>对获得的结果，由于<font color="#ff0000">23</font>，<font color="#ff0000">34</font>都是红色违反了<code>规则3</code>，将<code>34的父节点23</code>设置黑，<code>祖父节点6</code>设为红，<strong>以<code>祖父节6</code>点为支点左旋</strong>：</p><p><img src="https://jixiaoyong.github.io/images/20181223180637.png" alt="最终结果"></p><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>每次插入红色节点，能够避免规则4。</p><p>一般先以二叉搜索树的规则将数据插入表中，然后再对照规则检查是否需要调整红黑树。</p><p>红黑树插入情况分类如下：</p><ol><li>插入位置为根节点，将节点颜色更改为黑色</li><li>插入位置的父节点为根节点或父节点颜色为黑色，直接插入</li><li>父节点为红色。</li></ol><p>只有父节点为红色这种情况需要进行修正，这时又可以细分为以下三种情况：</p><p><img src="https://jixiaoyong.github.io/images/20181223182532.jpg" alt="表格来自 http://www.cnblogs.com/skywang12345/p/3245399.html#a1"></p><p>【注意】对于<code>Case 3</code>当祖父节点没有<strong>左节点</strong>无法右旋时的特殊处理：</p><p>需要对先对当前节点的父节点进行右旋，再以父节点作为<strong>新插入的点N</strong>，将N的父节点设置为黑色，祖父节点设置为红色，以祖父节点为支点左旋。</p><p>如依次插入如下值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32,3,53,13,983,[137],237,83,483,43,183</span><br></pre></td></tr></table></figure><p>当插入<code>137</code>后红黑树如图：</p><p><img src="https://jixiaoyong.github.io/images/20181223210305.png" alt="插入137后的树"></p><p>本来按照<code>Case 3 父红 叔黑 是左节点</code> 应该要以祖节点右旋，但是组节点53没有左子节点，无法右旋，所以先对父节点983进行右旋：</p><p><img src="https://jixiaoyong.github.io/images/20181223210800.png" alt=""></p><p>再以<code>983</code>为新节点，<code>父红 叔黑 是右节点</code>，将<code>父节点137</code>设置为黑色，<code>祖节点53</code>设置为红色，以<code>组节点53</code>为支点左旋：</p><p><img src="https://jixiaoyong.github.io/images/20181223211217.png" alt=""></p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>删除比较复杂，可以有两种操作：</p><ol><li>在节点中保存一个标志位，标记该节点是否被删除，并不针真的删除该点。</li><li>在执行删除操作时真正删除该点。</li></ol><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/Notes-Files/blob/master/AndroidLearningResource/java_note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/tree/RedBlackTree.kt" target="_blank" rel="noopener">👉点这里</a>查看源码</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://sandbox.runjs.cn/show/2nngvn8w" target="_blank" rel="noopener">在线操作红黑树</a></p><p><a href="http://www.cnblogs.com/skywang12345/p/3245399.html#a1" target="_blank" rel="noopener">红黑树(一)之 原理和算法详细介绍</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/数据结构_红黑树.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用travis通过Hexo在Github上自动部署Markdown文档</title>
      <link href="/blog/posts/b00ac86a/"/>
      <url>/blog/posts/b00ac86a/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文介绍了一个只需要更新Markdown文档到Github，即可实时更新博客内容的方法。</p><p>本文参考<a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener">这篇文章</a> 实现，并根据我的需求更改了部分内容，以实现<strong>部署多个hexo工程到同一Github项目不同目录下</strong>。</p></blockquote><p>Github为我们提供了<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 方便我们建立简单的网页来介绍项目，很多时候我们用他来搭建静态博客。</p><p>通过<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>可以将我们写的<code>Markdown文档</code>格式化为<code>静态网页</code>，再将其部署到Github上面对应的<code>user_name.github.io</code>上面，就可以拥有一个在线的静态博客。</p><p>但是受Hexo的限制，每次更新博客内容都需要在更新完Markdown文档后，都需要再次重新创建对应的静态网页、将更新提交到Github。这样的步骤繁琐且没有意义，而且更换电脑后这些环境都需要重新设置一次。</p><p>通过<a href="https://www.travis-ci.org" target="_blank" rel="noopener">travis</a>提供的免费CI技术，可以让云服务器代替我们实现Hexo创建以及同步Github等步骤，每次更新博客时<strong>只需要将写好的Markdown文档推送到Github项目对应目录中，等待一会儿就可以看到更新后的博客了</strong>。</p><p>具体搭建过程可以参考<a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener">这篇文章</a> 本文只讲述实现<strong>部署多个hexo工程到同一Github项目不同目录下</strong>需要注意的地方：。</p><blockquote><p><strong>懒——是第一生产力</strong></p></blockquote><h1 id="具体差异"><a href="#具体差异" class="headerlink" title="具体差异"></a>具体差异</h1><h2 id="hexo分支的结构"><a href="#hexo分支的结构" class="headerlink" title="hexo分支的结构"></a>hexo分支的结构</h2><p>因为有多个hexo项目，所以在github项目的hexo分支下，对不同的hexo项目分别新建文件夹存放。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- your_name.github.io //github项目，切换到hexo分支</span><br><span class="line">  --hexo_project1 //本地hexo项目1的所有文件</span><br><span class="line">  --hexo_project2 //本地hexo项目2的所有文件</span><br></pre></td></tr></table></figure><h2 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a>.travis.yml</h2><p>重点修改<code>script:</code>和<code>after_script:</code>两部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="comment"># 1. 创建对应的静态博客内容</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">blog</span> <span class="comment"># 第一个本地hexo项目</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">imissyou</span> <span class="comment"># 第二个本地hexo项目</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"jixiaoyong"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"jixiaoyong1995@gmail.com"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">mkdir</span> <span class="string">publish</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">publish</span></span><br><span class="line">  <span class="comment"># 2. 在这里再拉取master分支的文件，并删除旧的博客内容</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">clone</span> <span class="attr">https://$&#123;GH_TOKEN&#125;@github.com/jixiaoyong/jixiaoyong.github.io.git</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">rm</span> <span class="bullet">-rf</span> <span class="string">./jixiaoyong.github.io/blog/*</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">rm</span> <span class="bullet">-rf</span> <span class="string">./jixiaoyong.github.io/imissyou/*</span></span><br><span class="line">   <span class="comment"># 3. 将第1步生成的静态博客内容添加到master分支，并同步到github上面</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">..</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cp</span> <span class="bullet">-rf</span> <span class="string">jixiaoyong.github.io/blog/public/*</span> <span class="string">publish/jixiaoyong.github.io/blog/</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cp</span> <span class="bullet">-rf</span> <span class="string">jixiaoyong.github.io/imissyou/public/*</span> <span class="string">publish/jixiaoyong.github.io/imissyou/</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">publish/jixiaoyong.github.io/</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"auto update by www.travis-ci.org"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure><p>文档链接：<a href="https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/.travis.yml" target="_blank" rel="noopener">.travis.yml</a></p><h1 id="更新博客内容"><a href="#更新博客内容" class="headerlink" title="更新博客内容"></a>更新博客内容</h1><p>当以上内容都配置完成后，只要新建一个符合hexo要求的文档，并提交到Github对应项目的hexo分支中<code>source</code>目录，Travis便会自动帮我们创建并更新静态网页。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener">Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程</a> （完全在该文档指导下完成，部分步骤有差异，感谢作者<a href="https://juejin.im/user/56efe6461ea493005565dafd" target="_blank" rel="noopener">MichaelX</a> ）</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/利用GitHub-Hexo-travis自动部署发布Markdown文件.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> ci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android运行时权限</title>
      <link href="/blog/posts/a2863875/"/>
      <url>/blog/posts/a2863875/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了Android运行时权限的一些处理流程。</p><p>Android运行时权限是Android6之后出现的处理权限的新方式，此前开发者只需要应用需要的权限在AndroidManifest.xml文件中声明即可，现在则需要在使用到对应权限时检测是否有该权限并作出相应处理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><ol><li><p>在<code>AndroidManifest.xml</code>中声明所需权限</p></li><li><p>在使用之前检查是否有该权限<code>checkSelfPermission()</code>,如果有则继续相应操作</p></li><li><p>如果没有权限则检测是否需要向用户解释为什么需要该权限<code>ActivityCompat.shouldShowRequestPermissionRationale()</code>，再决定如何申请权限<code>requestPermissions()</code></p><blockquote><p>需要说明的是，shouldShowRequestPermissionRationale()在第一次申请该权限时会返回false，第二次申请时返回true；</p><p>但是如果用户选择了<em>不再提醒</em> 则会一直返回false。所以如果判断当前并非第一次申请该权限，并且返回结果为false，就说明用户选择了不再提示，一般就需要提示用户到设置中开启对应权限。</p></blockquote></li><li><p>申请权限的结果在<code>onRequestPermissionsResult()</code>方法中返回，根据用户对权限的处理结果决定接下来的操作</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>onCreate()</code>方法中调用对应方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mSharedPreferences = getSharedPreferences(packageName, Context.MODE_PRIVATE)</span><br><span class="line">checkCameraDeviceAndPremissions()</span><br></pre></td></tr></table></figure><p><code>checkCameraDeviceAndPremissions()</code>具体内容</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkCameraDeviceAndPremissions</span><span class="params">()</span></span> &#123;</span><br><span class="line">     ...</span><br><span class="line">    <span class="comment">//[2]每次使用之前检测是否有改权限</span></span><br><span class="line">        <span class="keyword">if</span> (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            safeRequestCameraPermission()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            safeOpenCamera(cameraId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对申请结果进行处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            <span class="comment">//[4]处理请求权限的结果</span></span><br><span class="line">            REQUEST_CAMERA -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    safeOpenCamera(cameraId)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> noCameraPermissionDialog = AlertDialog.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line">                        .setTitle(<span class="string">"警告⚠️"</span>)</span><br><span class="line">                        .setMessage(<span class="string">"没有相机权限，不可继续！\n请赋予相机权限"</span>)</span><br><span class="line">                        .setCancelable(<span class="literal">false</span>)</span><br><span class="line">                        .setPositiveButton(<span class="string">"Yes"</span>) &#123; _, _ -&gt;</span><br><span class="line">                            safeRequestCameraPermission()</span><br><span class="line">                        &#125;</span><br><span class="line">                        .setNegativeButton(<span class="string">"No"</span>) &#123; _, _ -&gt; finish() &#125;</span><br><span class="line">                        .create()</span><br><span class="line">                    noCameraPermissionDialog.show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>safeRequestCameraPermission()</code>的内容，这里才是处理申请权限的相关代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">safeRequestCameraPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//[3]检测是否需要解释为什么需要改权限</span></span><br><span class="line">    <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, Manifest.permission.CAMERA)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次请求时为false</span></span><br><span class="line"><span class="comment">         * 第二次请求时为true，需要解释为什么需要这个权限</span></span><br><span class="line"><span class="comment">         * 若用户选择了不再提示则一直为false</span></span><br><span class="line"><span class="comment">         * 综上，如果不是第一次请求该权限，并且返回值为false，那么可以判断用户选择了不再提示</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//向用户解释为什么需要改权限</span></span><br><span class="line">        <span class="keyword">var</span> noCameraDialog = AlertDialog.Builder(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line">            .setTitle(<span class="string">"提示️"</span>)</span><br><span class="line">            .setMessage(<span class="string">"本应用正常运行需要相机权限，点击确认开始赋予权限"</span>)</span><br><span class="line">            .setCancelable(<span class="literal">false</span>)</span><br><span class="line">            .setPositiveButton(<span class="string">"Yes"</span>) &#123; _, _ -&gt;</span><br><span class="line">                <span class="comment">//用户同意后开始申请权限</span></span><br><span class="line">                doRequestCameraPermission()</span><br><span class="line">            &#125;</span><br><span class="line">            .create()</span><br><span class="line">        noCameraDialog.show()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.d(<span class="string">"TAG"</span>, <span class="string">"count "</span> + mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> (mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, <span class="number">0</span>) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//TODO 用户拒绝了赋予权限，并且选择了“不再提醒”，提示用户到设置中开启</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doRequestCameraPermission()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doRequestCameraPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//每次申请权限时更新计数器</span></span><br><span class="line">    <span class="keyword">var</span> count = mSharedPreferences.getInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    mSharedPreferences.edit().putInt(KEY_COUNT_REQUEST_CAMERA_PERMISSION, count).apply()</span><br><span class="line">    requestPermissions(arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>样例代码: <a href="https://github.com/jixiaoyong/Notes-Files/commit/f41afa99c24cde1dab619462754435f2a2afc64e#diff-67ccb5e5c6c34760486a1071b23338a2" target="_blank" rel="noopener">Github</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android运行时权限.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的泛型</title>
      <link href="/blog/posts/b2cdb69e/"/>
      <url>/blog/posts/b2cdb69e/</url>
      
        <content type="html"><![CDATA[<p>Java中的泛型实现了<strong>参数类型化</strong>的概念。</p><p>主要有以下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneClazz</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    &lt;Y&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文主要记录Java泛型一些比较特殊的知识点。</p><h1 id="泛型特性"><a href="#泛型特性" class="headerlink" title="泛型特性"></a>泛型特性</h1><p>泛型在Java SE5被引入，可以在类和方法中，将类型作为类型参数传入。</p><p>泛型类型参数会在实际运行时被<strong>擦除</strong>到他的第一个边界。如<code>&lt;T&gt;</code>会被擦除为<code>Objet</code>，而<code>&lt;T extends ClazzA&gt;</code>则会被擦除为<code>ClazzA</code>。</p><h1 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h1><h2 id="不能有泛型数组"><a href="#不能有泛型数组" class="headerlink" title="不能有泛型数组"></a>不能有泛型数组</h2><p>这是因为Java中Object[]默认为所有数组的父类，如下代码虽然在编译期不会报错，但是在运行时会被检查出objArr指向的数组实际类型（String）和要赋予的类型（Integer）不一致而报错。</p><p>也就是说，数组只能存放<strong>定义的实际类型</strong>以及他们的<strong>子类型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] objArr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">objArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但是，如果支持泛型数组：由于泛型类型参数会在运行时被擦除，导致即使到了运行时也无法发现这个错误，从而会导致错误。</p><p>如下，加入支持泛型参数，则objArr1中实际保存的类型（Map&lt;String,Integer&gt;），在编译的时候由于objArr1和objArr2都是Object类型的数组，编译通过；在运行的时候，由于Map中的泛型参数类型已经被擦除，也无法区分objArr1和objArr2中实际指向的两个Map&lt;K,V&gt;数组，也是合法的，这样原本定义的是Map&lt;String,Integer&gt;数组，却可以保存任何类似的Map，而这本来是不允许的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] objArr1 = <span class="keyword">new</span> Map&lt;String,Integer&gt;[<span class="number">10</span>];</span><br><span class="line">Object[] objArr2 = <span class="keyword">new</span> Map&lt;Double,Integer&gt;[<span class="number">10</span>];</span><br><span class="line">objArr1[<span class="number">0</span>] = objArr2[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><blockquote><p>Collections 类通过一种别扭的方法绕过了这个问题，在 Collections 类编译时会产生类型未检查转换的警告。</p><p><code>ArrayList</code>具体实现的构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">private</span> V[] backingArray;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;         backingArray = (V[])<span class="keyword">new</span> Object()[DEFAULT_SIZE];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>为何这些代码在访问 <code>backingArray</code>时没有产生 <code>ArrayStoreException</code>呢？无论如何，都不能将 <code>Object</code>数组赋给 <code>String</code>数组。因为泛型是通过擦除实现的，<code>backingArray</code>的类型实际上就是 <code>Object[]</code>，因为 <code>Object</code>代替了 <code>V</code>。</p><p><strong>这意味着：实际上这个类期望 <code>backingArray</code>是一个 <code>Object</code>数组，但是编译器要进行额外的类型检查，以确保它包含 <code>V</code>类型的对象。</strong></p><p>来源：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp01255.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp01255.html</a></p></blockquote><h1 id="泛型容器"><a href="#泛型容器" class="headerlink" title="泛型容器"></a>泛型容器</h1><p>由于泛型的类型在运行时会被擦除，所以将类型检查放到了编译期。</p><p><code>List&lt;Clazz&gt;</code> 泛型列表只能保存指定泛型类型<code>T</code>的数据，而不能保存其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//编译时报错，类型不兼容</span></span><br><span class="line">List&lt;Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br></pre></td></tr></table></figure><p>但是能保存Fruit的容器应该也要能安全的保存Apple，为了实现这一点，类似于数组中<code>Object[] arr = Apple[]</code>的向上转型，可以使用<code>?</code>引入协变。</p><h2 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h2><p><code>List&lt;? extends T&gt;</code> 可以<strong>合法的指向一个<code>List&lt; SubT&gt;</code></strong>，这个过程会完成自动<strong>向上转型</strong>，成为可以持有<strong>某个诸如T或者T的子类</strong>的List，但是编译器不知道这个<strong>类</strong>具体是什么，所以拒绝向其中传递任何类型对象，即使Object也不行。</p><p>可以这么想，<code>&lt;? extends T&gt;</code>表示的是T的子类，那么<code>List&lt;? extends T&gt;</code> 保存的便是<strong>T的某个子类</strong>，所以不能保存Object或者T等类型，又由于列表不能保存不同的类型，所以也不能保存任何T的子类,即容器将数组在运行时才会有的类型检查放到了编译期（原因是运行时类型会被擦除）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();<span class="comment">//可以安全的应用</span></span><br><span class="line">fruits2.add(<span class="keyword">new</span> Apple());<span class="comment">//编译时报错，类型转化错误</span></span><br><span class="line">fruits2.add(<span class="keyword">new</span> Fruit());<span class="comment">//编译时报错</span></span><br></pre></td></tr></table></figure><h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h2><p><code>List&lt;? super T&gt;</code> <strong>主动声明</strong>通配符<code>?</code>的超类型为<code>T</code>,即List保存的是<strong>T的某个父类</strong>，那么List也可以安全的保存<strong>T或者T的子类</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span></span>&#123;</span><br><span class="line">    apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Fruit());<span class="comment">//error 类型错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/20928981/answer/39234969" target="_blank" rel="noopener">java为什么不支持泛型数组？ - ylxfc的回答 - 知乎</a></p><p><a href="https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html" target="_blank" rel="noopener">Oracle Java 泛型原理</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp01255.html" target="_blank" rel="noopener">Java 理论和实践-了解泛型-识别和避免学习使用泛型过程中的陷阱</a></p><p><a href="https://www.jianshu.com/p/2bf15c5265c5" target="_blank" rel="noopener">Java泛型（二） 协变与逆变</a></p><p>《Java编程思想 第4版》</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Java中的泛型.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter Widget简单入门</title>
      <link href="/blog/posts/e35c106d/"/>
      <url>/blog/posts/e35c106d/</url>
      
        <content type="html"><![CDATA[<p>Flutter是Google提出的跨平台开发框架，使用Dart语言，支持Android，IOS系统。Flutter一个重要的概念即是——<em>“万物皆控件（Widget）”</em>，像<code>Padding</code>,<code>Center</code>等都是Widget。</p><p>Widget和Android中的View很相似但又有不同，Widget一旦生成便“一成不变”，直到下一次因为Widget更改或者state更新而被重新创建（Flutter’s framework creates a new tree of widget instances.），而View则只会被<code>drawn</code>一次，直到<code>invalidate</code>方法被调用。</p><p>本文主要记录一下Flutter中两个重要的控件：StatelessWidget和StatefulWidget，以及Flutter开发的一些基础知识。</p><h1 id="Flutter基础知识"><a href="#Flutter基础知识" class="headerlink" title="Flutter基础知识"></a>Flutter基础知识</h1><p>Flutter以Dart开发，其工程基本的结构如下：</p><ul><li>android</li><li>ios</li><li>lib<ul><li>main.dart</li></ul></li><li>pubspec.yaml //Flutter工程的配置信息</li></ul><p>Flutter项目启动后会首先加载<code>/lib/main.dart</code>中的<code>main()</code>方法。<br>一个标准的material app的main.dart内容如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./product_manager.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() =&gt; runApp(MyApp());<span class="comment">//在main()方法中调用了material的runApp()方法，里面传入了要展示的Widget——APP的界面，相当于Android的setContentView()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.deepOrange</span><br><span class="line">      ),</span><br><span class="line">      home: Scaffold(<span class="comment">//脚手架，一个预制的APP界面结构，也可以使用自定义Widget</span></span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">"EasyList"</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: ProductManager(<span class="string">"Test"</span>),<span class="comment">//这里是自定义的控件，布局信息主要在这里展示</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="StatelessWidget-amp-StatefulWidget"><a href="#StatelessWidget-amp-StatefulWidget" class="headerlink" title="StatelessWidget &amp; StatefulWidget"></a>StatelessWidget &amp; StatefulWidget</h1><p>StatelessWidget和StateFulWidget区别在于：前者一旦创建，状态便不会再更改，而后者则可以动态改变State从而使flutter改变其状态。但是两者都会在每一帧被rebuild。</p><h2 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2><blockquote><p>A <code>StatelessWidget</code> is just what it sounds like—a widget with no state information.</p></blockquote><p>StatelessWidget一旦创建便不会更改，其状态只和构造函数中的参数有关。下面是一个StatelessWidget示例，一般只需要重写其build()方法，返回要展示的控件即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomerWidget();<span class="comment">//在这里构建一个页面并返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><blockquote><p><code>StatefulWidget</code> has a <code>State</code> object that stores state data across frames and restores it.</p></blockquote><p>StatefulWidget可以通过动态更改其包含的State，从而使flutter在下一次更新界面时依据state更新StateWidget，<em>本质上还是更新了一个可以在多帧之间存活的State，在下一帧更新控件</em>。</p><p>下面是一个StatefulWidget的示例:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductManager</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> ProductManagerState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductManagerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ProductManager</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomerWidget();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到StatefulWidget重写了<code>createState()</code>，而该方法返回了自定义的<code>ProductManagerState</code>类对象，在该类中<code>build()</code>方法实现和StatelessWidget中的方法类似，返回要展示的页面控件。</p><p>两者的不同之处在于，StatefulWidget中可以调用<code>setState()</code>，更改其相应的<code>state</code>，以便告诉flutter在下一次rebuild的时候更新UI。</p><p>StatelessWidget要想实现动态更新其内容，可以在其外部包裹一层StatefulWidget，通过StatefulWidget更改状态state，将更改后的state传给StatelessWidget，从而间接更新了StatelessWidget的状态。</p><p>可以通过对该方法就行包装，使得在StatelessWidget控件中调用StatefulWidget控件的<code>setState()</code>方法，达到刷新页面的效果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatefulWidget</span></span><br><span class="line">  <span class="keyword">void</span> aFun()&#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// update UI</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">AStatelessWidget(aFun);<span class="comment">// 将该方法传入StatelessWidget中</span></span><br><span class="line"><span class="comment">// StatelessWidget</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">Function</span> aFun</span><br><span class="line">AStatelessWidget(<span class="keyword">this</span>.aFun);<span class="comment">// 接收传入的方法</span></span><br><span class="line">aFun();<span class="comment">// 执行该方法，从而实现调用StatelessWidget中的方法也可以刷新UI</span></span><br></pre></td></tr></table></figure><h1 id="与Android的对比"><a href="#与Android的对比" class="headerlink" title="与Android的对比"></a>与Android的对比</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Android的Intent有两个主要作用：</p><ul><li>Activity间跳转</li><li>组件间传递数据</li></ul><p>Flutter对此相应：</p><ul><li>使用Navigator和<code>Route</code>s实现在同一个“Activity”中不同的界面间（ “screen” or “page”）跳转（push，pop），Navigator类似于Android中的Activity栈。</li><li>通过Android原生Intent组件获取到其他App传来的数据，然后中通过下面的方法实现Android和Flutter交互：</li></ul><p>示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Android</span></span><br><span class="line"> MethodChannel(getFlutterView(), <span class="string">"app.channel.shared.data"</span>)</span><br><span class="line">      .setMethodCallHandler(MethodChannel.MethodCallHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public <span class="keyword">void</span> onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123;</span><br><span class="line">          <span class="keyword">if</span> (methodCall.method.contentEquals(<span class="string">"getSharedText"</span>)) &#123;</span><br><span class="line">            result.success(sharedText);</span><br><span class="line">            sharedText = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"> <span class="comment">//Flutter</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">_SampleAppPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">SampleAppPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> platform = <span class="keyword">const</span> MethodChannel(<span class="string">'app.channel.shared.data'</span>);</span><br><span class="line">  <span class="built_in">String</span> dataShared = <span class="string">"No data"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    getSharedText();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(body: Center(child: Text(dataShared)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSharedText() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sharedData = <span class="keyword">await</span> platform.invokeMethod(<span class="string">"getSharedText"</span>);</span><br><span class="line">    <span class="keyword">if</span> (sharedData != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        dataShared = sharedData;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>Flutter是单线程的，他的线程和Android的UI线程绑定，在进行网络请求，IO操作等时，可以使用<code>sync/await</code> 在执行完耗时操作后，再去更新state刷新UI。</p><blockquote><p>Since Flutter is single threaded and runs an event loop (like Node.js), you don’t have to worry about thread management or spawning background threads. If you’re doing I/O-bound work, such as disk access or a network call, then you can safely use async/await and you’re all set. </p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> dataURL = <span class="string">"https://jsonplaceholder.typicode.com/posts"</span>;</span><br><span class="line">  http.Response response = <span class="keyword">await</span> http.<span class="keyword">get</span>(dataURL);</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    widgets = json.decode(response.body);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果有特别频繁的cpu计算以至于能导致UI挂起，可以考虑使用<code>Isolate</code>s利用CPU多核心处理任务，但是这样就不能和主线程共享数据，通过<code>ReceivePort</code>，<code>SendPort</code>等传递数据。</p><blockquote><p>Isolates(隔离) are separate execution threads that do not share any memory with the main execution memory heap. This means you can’t access variables from the main thread, or update your UI by calling <code>setState()</code>. Unlike Android threads, Isolates are true to their name, and cannot share memory (in the form of static fields, for example).</p></blockquote><h2 id="本地资源"><a href="#本地资源" class="headerlink" title="本地资源"></a>本地资源</h2><p>截止Flutter beta 2 仍然不能直接访问Android assets或者其他本地资源，但是Android可以访问flutter的assets资源：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val flutterAssetStream = assetManager.open(<span class="string">"flutter_assets/assets/my_flutter_asset.png"</span>)</span><br></pre></td></tr></table></figure><p>通过Channel，flutter可以间接访问Android资源，反之亦然。</p><blockquote><p>主要是通过Channel完成，可以称之为隧道。主要是MethodChannel和MessageChannel两种，第一种是调用方法，第二种是传递信息。首先通信的双方是Flutter和本地操作系统或者应用，而且方法的调用和消息的方法可以从任何一方发起，类似RPC（远程过程调用）。</p><p>作者：黄马</p><p>链接：掘金  <a href="https://juejin.im/post/5b35a75e51882574ea3a25e3" target="_blank" rel="noopener">https://juejin.im/post/5b35a75e51882574ea3a25e3</a></p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Flutter生命周期没有Android中那么“重要”，可以重写 <code>didChangeAppLifecycleState()</code> 监听。</p><ul><li><code>inactive</code> — 应用处于非活动状态，不接受输入。iOS</li><li><code>paused</code> — 应用在后台运行，不可见，不接受输入。类似Android的<code>onPause()</code></li><li><code>resumed</code> — 应用可见，并接受输入。类似Android的<code>onPostResume()</code></li><li><code>suspending</code> — 应用请求暂停。类似Android的<code>onStop()</code></li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>Flutter有布局Widget如：</p><ul><li>Column 列</li><li>Row 行</li><li>Stack 左上角堆积，类似FrameLayout</li></ul><h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>FLutter中的“<code>onClick()</code>”: <code>onPressed</code>,<code>onTap</code>等等。</p><p>添加点击事件,在Widget外面添加一个<code>GestureDetector</code>Widget：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector(</span><br><span class="line">  child: Padding(</span><br><span class="line">      padding: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">      child: Text(<span class="string">"Row <span class="subst">$i<span class="string">")),</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  onTap: () &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    print('row tapped');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;,</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">);</span></span></span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.youtube.com/watch?v=GLSG_Wh_YWc" target="_blank" rel="noopener">Flutter Tutorial for Beginners - Build iOS and Android Apps with Google’s Flutter &amp; Dart</a></p><p><a href="https://flutter.io/flutter-for-android/" target="_blank" rel="noopener">Flutter for android</a></p><p><a href="https://juejin.im/post/5b35a75e51882574ea3a25e3" target="_blank" rel="noopener">Flutter 访问本地资源</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/FlutterWidget简单入门.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中AIDL的使用</title>
      <link href="/blog/posts/f931e8ae/"/>
      <url>/blog/posts/f931e8ae/</url>
      
        <content type="html"><![CDATA[<p>AIDL（Android Interface Definition Language ，Android接口定义语言）用于Android IPC，适用于<strong>大量并发</strong>请求。</p><p>主要分为两部分：</p><ol><li>服务端 创建Service监听Client的请求，通过创建AIDL将接口暴露给客户端</li><li>客户端 绑定到服务端获取BInder对象，将其转化为对应AIDL，并调用接口对应方法。</li></ol><p>两者的连线就是AIDL，因此两个APP的AIDL必须一致，可以将AIDL文件放到一个Android Library中，或者打成aar文件供二者依赖。</p><p>也可以将AIDL涉及到的AIDL文件、java都放到AIDL文件夹下，然后在build.gradle的<code>android{...}</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">     main&#123;</span><br><span class="line">         java.srcDirs = [&apos;src/main/java&apos;,&apos;src/main/adil&apos;]</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 即添加一个java路径</p><h1 id="AIDL-文件特点"><a href="#AIDL-文件特点" class="headerlink" title="AIDL 文件特点"></a>AIDL 文件特点</h1><h2 id="支持的数据格式"><a href="#支持的数据格式" class="headerlink" title="支持的数据格式"></a>支持的数据格式</h2><p>基本数据类型、List（ArrayList）、Map（HashMap）以及实现了Parcelable接口的对象、AIDL接口。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>自定义的Parcelable对象、AIDL对象必须显示import。</li><li>AIDL中用到的Parcelable对象必须新建一个同名AIDL接口，声明其为Parcelable类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// People.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line">parcelable People;</span><br></pre></td></tr></table></figure><ul><li>AIDL中除了基本数据类型，其他的参数必须标记方向（in,out,inout）。</li><li>AIDL不支持方法重载，也就是说不能有两个同名的方法（即使参数类型、个数不同也不行）。</li><li>AIDL中只支持方法，不支持静态变量。</li></ul><h1 id="AIDL用法"><a href="#AIDL用法" class="headerlink" title="AIDL用法"></a>AIDL用法</h1><h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ManagerAidl.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.TaskCallBack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ManagerAidl</span> </span>&#123;</span><br><span class="line">    <span class="comment">//客户端提供的方法</span></span><br><span class="line">    <span class="function">List&lt;People&gt; <span class="title">getPeopleList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addPeople</span><span class="params">(in People people)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调接口，用于服务端往客户端通信</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerCallBack</span><span class="params">(in TaskCallBack callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterCallBack</span><span class="params">(in TaskCallBack callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskCallBack.aidl</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://blog.csdn.net/woshiwoshiyu/article/details/54266101</span></span><br><span class="line"><span class="comment">//回调的具体方法，供服务端回调</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TaskCallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callBack</span><span class="params">(in <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPeopleChange</span><span class="params">(in List&lt;People&gt; peoples)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//People.java</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PeopleManager.java</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.androidlib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个管理类，封装了客户端绑定服务端的一些方法</span></span><br><span class="line"><span class="comment"> * 属于客户端部分，不过放在AIDL中便于多个客户端开发</span></span><br><span class="line"><span class="comment"> * Created by jixiaoyong on 2018/8/6.</span></span><br><span class="line"><span class="comment"> * email:jixiaoyong1995@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PeopleManager mPeopleManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Context mContext;</span><br><span class="line">    <span class="keyword">private</span>  Listener mListener;</span><br><span class="line">    <span class="keyword">private</span> ManagerAidl managerAidl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;People&gt; peopleList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现该回调方法，用于调用客户端的具体方法</span></span><br><span class="line">    <span class="comment">//注意这里是new TaskCallBack.Stub()，而非new TaskCallBack(),否则服务器无法接收到callback</span></span><br><span class="line">    <span class="comment">//TaskCallBack.Stub()是TaskCallBack的子类，当跨进程通信时传递的是proxy类</span></span><br><span class="line">    <span class="keyword">private</span> TaskCallBack callBack = <span class="keyword">new</span> TaskCallBack.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callBack</span><span class="params">(<span class="keyword">int</span> size)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mListener.onCallback(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeopleChange</span><span class="params">(List&lt;People&gt; peoples)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            peopleList = peoples;</span><br><span class="line">            mListener.onPeopleListChange(peoples);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection serviceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在连接上服务端后，客户端从IBinder对象中获取到AIDL接口对象，并执行其方法</span></span><br><span class="line">            managerAidl =  ManagerAidl.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                peopleList = managerAidl.getPeopleList();</span><br><span class="line">                managerAidl.registerCallBack(callBack);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            mListener.onCreate(mPeopleManager);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                managerAidl.unregisterCallBack(callBack);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PeopleManager</span><span class="params">(Context context,Listener listener)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mListener = listener;</span><br><span class="line">        peopleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"cf.android666.demo"</span>,</span><br><span class="line">                <span class="string">"cf.android666.demo.MService"</span>));<span class="comment">//Android5.0后必须显示的启动服务</span></span><br><span class="line">        context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context,Listener listener)</span> </span>&#123;</span><br><span class="line">        mPeopleManager = <span class="keyword">new</span> PeopleManager( context, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPeople</span><span class="params">(People people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            managerAidl.addPeople(people);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;People&gt; <span class="title">getPeopleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> peopleList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类可以实现该Listener的方法，在服务端调用这些方法时执行对应操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(PeopleManager peopleManager)</span></span>;<span class="comment">//服务连接成功</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCallback</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onPeopleListChange</span><span class="params">(List&lt;People&gt; peoples)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>注意MService在AndroidManife.xml中配置:</p><p><code>android:exported=&quot;true&quot;android:enabled=&quot;true&quot;android:process=&quot;:people&quot;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MService.java</span></span><br><span class="line"><span class="keyword">package</span> cf.android666.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteCallbackList;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.text.InputFilter;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.ManagerAidl;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.People;</span><br><span class="line"><span class="keyword">import</span> cf.android666.androidlib.TaskCallBack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by jixiaoyong on 2018/8/6.</span></span><br><span class="line"><span class="comment"> * email:jixiaoyong1995@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MService</span> <span class="keyword">extends</span> <span class="title">Service</span> <span class="keyword">implements</span> <span class="title">ManagerAidl</span>.<span class="title">Stub</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;People&gt; mPeopleList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RemoteCallbackList&lt;TaskCallBack&gt; callbackList = <span class="keyword">new</span> RemoteCallbackList&lt;&gt;();;</span><br><span class="line">    <span class="keyword">private</span> TaskCallBack mCallBack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用AIDL接口生成mIBinder，在服务端实现接口各个方法，供客户端调用</span></span><br><span class="line">    <span class="keyword">private</span> IBinder mIBinder = <span class="keyword">new</span> ManagerAidl.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;People&gt; <span class="title">getPeopleList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mPeopleList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPeople</span><span class="params">(People people)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mPeopleList.add(people);</span><br><span class="line">            onPeopleChange(mPeopleList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCallBack</span><span class="params">(TaskCallBack callback)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mCallBack = callback;</span><br><span class="line">            Log.d(<span class="string">"TAG"</span>, <span class="string">"registerCallBack注册回调方法 callback == null"</span> + callback);</span><br><span class="line">            <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;<span class="comment">//注意这里一定要判断非空</span></span><br><span class="line">                callbackList.register(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterCallBack</span><span class="params">(TaskCallBack callback)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callbackList.unregister(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"tag"</span>, <span class="string">"onBind  MService开始了"</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPeopleList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPeopleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            mPeopleList.add(<span class="keyword">new</span> People(<span class="string">"people"</span> + i, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mIBinder;<span class="comment">//返回开始用AIDL创建的IBinder</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现DeathRecipient接口的方法，在客户端终止后自动调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callbackList.unregister(mCallBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里时在服务端调用回调方法的写法，是从callbackList依次取出来执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onPeopleChange</span><span class="params">(List&lt;People&gt; peoples)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = callbackList.beginBroadcast();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                callbackList.getBroadcastItem(i).onPeopleChange(peoples);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            callbackList.finishBroadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>这里用来注册监听的类是RemoteCallbackList</p><p>我们知道跨进程的两个listener是两个不同的对象，那他是怎么保证跨进程注册、注销的是指定的listener呢？</p><p>这是因为虽然两个listener对象不同，但是他们底层的Binder对象是同一个，在RemoteCallbackList中有一个以Binder对象为KEY的map来存放这些listener对象，当要注销时，只需要按当前待注销的listener的Binder对象找到已经注册了的listener并删除掉即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;IBinder, Callback&gt; mCallbacks</span><br><span class="line">        = <span class="keyword">new</span> ArrayMap&lt;IBinder, Callback&gt;()</span><br></pre></td></tr></table></figure><p>此外，RemoteCallbackList可以在客户端死亡的时候自动注销掉对应的listener，这是因为他在注册的同时也对Binder的死亡就行了监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">register</span><span class="params">(E callback, Object cookie)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mCallbacks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mKilled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Flag unusual case that could be caused by a leak. b/36778087</span></span><br><span class="line">        logExcessiveCallbacks();</span><br><span class="line">        IBinder binder = callback.asBinder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callback cb = <span class="keyword">new</span> Callback(callback, cookie);</span><br><span class="line">            binder.linkToDeath(cb, <span class="number">0</span>);<span class="comment">//监听binder的死亡事件</span></span><br><span class="line">            mCallbacks.put(binder, cb);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//当binder死亡时，会主动移除其注册的listener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mCallbacks) &#123;</span><br><span class="line">                mCallbacks.remove(mCallback.asBinder());</span><br><span class="line">            &#125;</span><br><span class="line">            onCallbackDied(mCallback, mCookie);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>方法运行的线程</p><p><strong>如果客户端和服务端运行在同一进程</strong>：客户端调用服务端和服务端回调客户端方法（RemoteCallbackList，下同）都会运行在同一线程，即客户端调用服务端时所在的线程，默认为主线程</p><p><strong>如果客户端和服务端运行在不同进程</strong>：客户端调用服务端方法，客户端会被挂起，直到服务端方法在Binder线程池中运行完毕,这种情况下服务端可以执行耗时操作而无需另建线程；服务端回调客户端方法运行在客户端主线程(与客户端调用服务端方法在同一线程)</p><p>通过上述分析，可以注意到一个细节：<strong>虽然在服务端中回调客户端的方法是在服务端的Binder线程，但是在客户端中被回调的方法却是和客户端中主动调用服务端方法的线程一致</strong>。</p></li></ol><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PeopleManager.init(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务连接成功后，可以开始调用服务的一系列方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(PeopleManager peopleManager)</span> </span>&#123;</span><br><span class="line">    mPeopleManager = peopleManager;</span><br><span class="line">    peopleList = peopleManager.getPeopleList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; peopleList.size(); i++) &#123;</span><br><span class="line">        Log.d(<span class="string">"tag"</span>, <span class="string">"people list is "</span> + peopleList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他回调方法，等服务端回调时会执行对应方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeopleListChange</span><span class="params">(List&lt;People&gt; peoples)</span> </span>&#123;</span><br><span class="line">    Log.d(<span class="string">"TAG"</span>, <span class="string">"demo2 people变化了"</span> + peoples.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听并处理Binder死亡事件"><a href="#监听并处理Binder死亡事件" class="headerlink" title="监听并处理Binder死亡事件"></a>监听并处理Binder死亡事件</h2><p>当服务端进程意外死亡时，我们可以选择重新连接服务，一般有两种方式：</p><ol><li>binderDied 在客户端的Binder线程池中</li><li>onServiceDisconnected 在客户端UI线程</li></ol><h2 id="AIDL的权限验证"><a href="#AIDL的权限验证" class="headerlink" title="AIDL的权限验证"></a>AIDL的权限验证</h2><p>可以在服务的onBind(Intent intent)或者onTransact()方法中做验证</p><p>做验证的手段有：1.permission验证；2.Uid，Pid等做验证</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Android开发艺术探索》</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android中AIDL的使用.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> aidl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android事件分发</title>
      <link href="/blog/posts/c0fefed0/"/>
      <url>/blog/posts/c0fefed0/</url>
      
        <content type="html"><![CDATA[<p>Android事件分发，指手指点击屏幕后，从Activity、ViewGroup到View的一系列过程。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Android系统的窗口机制如下图：</p><p>Activity内有一个Window对象，其实现类是PhoneWindow；</p><p>DecorView为顶层View，DecorView是一个FrameLayout，其中有TitleView和ContentView；</p><p><img src="https://github.com/jixiaoyong/jixiaoyong.github.io/blob/master/images/blog/2018-04/AndroidDispatchTouchEvent.png?raw=true" alt="Android系统窗口管理机制"></p><p>TitleView为标题栏，ContentView就是平时在Activity的onCreate()方法中设置的视图，TitleView可以用<code>this.requestWindowFeature(Window.FEATURE_NO_TITLE);</code>隐藏掉，但是必须注意要在setContentView()之前，原因如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(view);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="点击事件-Activity-–-gt-ViewGroup"><a href="#点击事件-Activity-–-gt-ViewGroup" class="headerlink" title="点击事件 Activity –&gt; ViewGroup"></a>点击事件 Activity –&gt; ViewGroup</h1><p>点击事件发生后，首先被调用的是<code>Activity.dispatchTouchEvent()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其内部先调用了<code>getWindow().superDispatchTouchEvent(ev)</code>这个方法，getWindow()返回的mWindow是PhoneWindow的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br></pre></td></tr></table></figure><p>再看看PhoneWindow.superDispatchTouchEvent()方法，显然又调用了DecorView的superDispatchTouchEvent()方法,在该方法中，调用了FrameLayout.dispatchKeyEvent(event)，此时<strong>点击事件从Activity转到了ViewGroup中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhoneWindow</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchKeyEvent(event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DecorView extends FrameLayout</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Give priority to closing action modes if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">        <span class="comment">// Back cancels action modes first.</span></span><br><span class="line">        <span class="keyword">if</span> (mPrimaryActionMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                mPrimaryActionMode.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="点击事件-ViewGroup-–-gt-View"><a href="#点击事件-ViewGroup-–-gt-View" class="headerlink" title="点击事件 ViewGroup –&gt; View"></a>点击事件 ViewGroup –&gt; View</h1><p>ViewGroup与事件分发的方法有三个：</p><ul><li><code>dispatchTouchEvent()</code>  分发事件，每次都会被调用</li><li><code>onInterceptTouchEvent()</code>  拦截事件，如果当前ViewGroup已经决定拦截事件，那么不会再调用</li><li><code>onTouchEvent()</code>  处理点击事件,如果设置了<code>mOnTouchListener</code>的话，则不会回调本方法</li></ul><p>这三个主要方法关系如下（伪代码，来自《Android开发艺术探索》）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次点击事件回调该方法</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;<span class="comment">//viewGroup会回调该方法，确认是否拦截点击事件</span></span><br><span class="line">        result = onTouchEvent(event)<span class="comment">//对点击事件进行处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = child.dispatchTouchEvent(event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当ViewGroup.dispatchTouchEvent()被调用后，会通过一系列条件判断是由ViewGroup拦截该事件，还是由子View消耗该事件。</p><p>主要流程分为两部分</p><p><strong>1.检查是否需要拦截</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/view/ViewGroup.java line2567-2582</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">            <span class="comment">// Check for interception.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);<span class="comment">//在这里调用了onInterceptTouchEvent()方法，如果已经拦截了</span></span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">                <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">     ...</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>每次ACTION_DOWN事件都需要调用<code>onInterceptTouchEvent()</code>方法判断是否需要拦截</li><li>其他MotionEvent事件，如果有能处理点击事件的子View（<code>mFirstTouchTarget != null</code>）且<code>disallowIntercept</code>为false也需要调用<code>onInterceptTouchEvent()</code>方法判断是否需要拦截，否则不需要拦截</li><li>其余情况都需要拦截（没有可以处理点击事件的子View，并且不是ACTION_DOWN事件）</li></ul><p>如果ViewGroup判断要拦截该事件，则会调用<code>dispatchTransformedTouchEvent()</code>（后面会再讲到）通过他调用继承自View的<code>dispatchTouchEvent(MotionEvent event)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">           <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                       TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p><p>否则就需要遍历其子View</p><p><strong>2.遍历ViewGroup的所有子View，寻找一个可以处理点击事件的子View</strong></p><ul><li><code>dispatchTransformedTouchEvent()</code>   调用了子View的<code>dispatchTouchEvent()</code></li><li><code>addTouchTarget()</code>   对<code>mFirstTouchTarget</code>进行更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1. Check for interception.判断是否需要拦截</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;<span class="comment">//mFirstTouchTarget表示能处理点击事件的子View</span></span><br><span class="line">            <span class="comment">//FLAG_DISALLOW_INTERCEPT每次ACTION_DOWN都会被重置</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);<span class="comment">//调用拦截方法</span></span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.遍历子View，寻找可以处理点击事件的子View</span></span><br><span class="line">    <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                     <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                     ...</span><br><span class="line">                     newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                     alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchTransformedTouchEvent()方法如下，由于<code>child != null</code>其内部调用<code>child.dispatchTouchEvent(event)</code>方法，如此循环直到子View是一个View（单就ViewGroup和View而论）即<strong>将点击事件从ViewGroup分发到了View</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有子View可以处理点击事件，在<code>addTouchTarget()</code>方法内部对<code>mFirstTouchTarget</code>进行更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="点击事件-View内部"><a href="#点击事件-View内部" class="headerlink" title="点击事件 View内部"></a>点击事件 View内部</h1><p>View的点击事件分发主要涉及到两个方法：</p><ul><li><code>dispatchTouchEvent()</code></li><li><code>onTouchEvent()</code></li></ul><p>其点击事件分发用伪代码表示如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mListenerInfo.mOnTouchListener.onTouch(<span class="keyword">this</span>, event))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见View的dispatchTouchEvent()方法中，如果View注册了OnTouchListener则会先执行<code>mOnTouchListener.onTouch()</code>方法,如果该方法返回false才会执行<code>onTouchEvent()</code>。</p><p>在看onTouchEvent()方法：</p><ul><li>如果View处于<strong>不可用状态</strong>下，也会消耗点击事件，只不过没有反应</li><li>如果注册了OnClickListener会在ACTION_UP的时候调用<code>mOnClickListener.onClick(this)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(CLICKABLE&amp;&amp;LONG_CLICKABLE)&#123;<span class="comment">//LONG_CLICKABLE默认为false，CLICKABLE、LONG_CLICKABLE会在设置点击事件时被设置为true</span></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:&#123;</span><br><span class="line">                ...</span><br><span class="line">                performClick();<span class="comment">//如果注册了OnClickListener则会调用其onClick()方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mListenerInfo.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个Android的时间分发始于Activity,经过PhoneWindow、DecorView到达ViewGroup，再逐层分发到View中。</p><p>如果底层没有处理点击事件，则又一层层向上返回，直到最顶层消耗掉点击事件。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Android开发艺术探索》</p><p><a href="http://androidxref.com" target="_blank" rel="noopener">Android源代码</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/AndroidDispatchTouchEvent.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AsyncTask源码解析</title>
      <link href="/blog/posts/7ee9086b/"/>
      <url>/blog/posts/7ee9086b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是AsyncTask源码的简单分析，主要基于《Android开发艺术探索》一书的内容。</p></blockquote><p>AsyncTask是Android中多线程处理方式之一（其余为1.HandlerThread、2.IntentService以及普通的线程Thread）。</p><p>AsyncTask本质是线程池和Handler的包装类，适合实时更新后台任务进度的工作，特别耗时的工作应当交给线程池处理。</p><p>AsyncTask常用方法：</p><ul><li>onPreExecute()</li><li>doInBackground()</li><li>onProgressUpdate()</li><li>onPostExecute()</li></ul><p>AsyncTask有一下限制：</p><ol><li>AsyncTask对象必须在主线程（UI线程，下同）创建</li><li>AsyncTask的execute()必须在主线程调用，且只能被调用一次</li><li>不能<strong>直接调用</strong>其4种常用方法（见上）</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>继承自AsyncTask，重写对应方法。（注意如果需要更新进度，要在doInBackground()方法中调用publishProgress()方法）</li><li>在<strong>UI线程</strong> 实例化AsyncTask对象，并调用其execute()方法，传入参数开始执行。</li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>在execute(params)执行后，将参数params传入mWorker.call()方法</strong></p><p>{调用doInBackground(params)后台执行任务，同时通过postResult()方法发送执行结果，由InternalHandler.handleMessage()判断该执行finish()还是onProgressUpdate()}</p><p>{将mWorker传入mFuture中作为其callable在runAndReset()方法中执行c.call()方法。}</p><p><strong>通过exec.execute(mFuture)将其压入SerialExecutor线程池中排队，并在THREAD_POOL_EXECUTOR.execute(mActive)真正执行。</strong></p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>创建对象（代码有节略，下同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment">//注意这里的要求，必须在ui线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()<span class="comment">//此处创建InternalHandler用于在UI线程处理消息</span></span><br><span class="line">        : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = doInBackground(mParams);<span class="comment">//注意这里会调用doInBackground()方法，后台线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> tr;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postResult(result);<span class="comment">//此处发送msg到mHandler那里接受处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;<span class="comment">//这里将mWorker传了进去</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看FutureTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable; <span class="comment">//将mWorker当做了他的callable</span></span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                 result = c.call(); <span class="comment">//会在这里回调mWorker的call()方法，即前文所说的doInBackgroud()之类的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在主线程调用execute()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123; <span class="comment">//此处限制execute()只能被执行一次</span></span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task is already running."</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                        + <span class="string">" the task has already been executed "</span></span><br><span class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    onPreExecute(); <span class="comment">//开始前准备工作</span></span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params; <span class="comment">//将参数传入mWorker，并一并传入mFuture中</span></span><br><span class="line">    exec.execute(mFuture);<span class="comment">//将准备好参数、执行时间的mFuture排队放入串行线程池中，等待执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了常用方法之一onPreExecute();</p><p>mWorker和mFuture的关系前文已经描述了，在看一下exec.execute(mFuture)执行了什么：</p><p>exec是execute()传入的，对应于sDefaultExecutor，再查下去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An &#123;<span class="doctag">@link</span> Executor&#125; that executes tasks one at a time in serial</span></span><br><span class="line"><span class="comment">     * order.  This serialization is global to a particular process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br></pre></td></tr></table></figure><p>再看看SerialExecutor这个线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SerialExecutor主要的作用是将这些线程放到线程池中，并按照串行的顺序依次调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//offer() Inserts the specified element at the end of this deque.</span></span><br><span class="line">        <span class="comment">//将r插入到线程池中</span></span><br><span class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//等到当前的执行完了，就调用下一个</span></span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);<span class="comment">//在这里面才是真正的执行线程的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再仔细看一下THREAD_POOL_EXECUTOR</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">        sPoolWorkQueue, sThreadFactory);</span><br><span class="line">threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Executes the given task sometime in the future.  The task</span></span><br><span class="line"> <span class="comment">//may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line">ThreadPoolExector.executr()</span><br></pre></td></tr></table></figure><p>以上介绍了线程和线程池部分的内容，接下来看一下在主线程和后台线程之间是如何依靠handler机制来传递消息的。</p><p>关于构造函数，由于我们开发者只能接触到AsyncTask()这个构造函数，所以<code>mHandler=getMainHandler()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((Looper) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@hide，普通开发者不可见</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">        mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getMainHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sHandler = <span class="keyword">new</span> InternalHandler(Looper.getMainLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sHandler;<span class="comment">//sHandler是一个类变量，取的是主线程的looper,所以限制了AsyncTask只能在主线程实例化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再看一下InternalHandler类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123; <span class="comment">//在这里处理后台线程发过来的消息，UI线程</span></span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在doInBackground()方法中可以使用publishProgress()在后台更新进度，即是使用了handler发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，AsyncTask的finish()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可见，最后会根据情况调用onCancelled()或者onPostExecute()</span></span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/AsyncTaskSourceIndex.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加载已安装应用、未安装apk中的资源</title>
      <link href="/blog/posts/8d60b485/"/>
      <url>/blog/posts/8d60b485/</url>
      
        <content type="html"><![CDATA[<p> 加载已安装应用、未安装apk中的资源，其思路主要是获取到对应的ClassLoader/Context，通过ClassLoader加载R.java等类，再通过反射获取对应的资源id及资源。</p><h1 id="加载已安装应用资源"><a href="#加载已安装应用资源" class="headerlink" title="加载已安装应用资源"></a>加载已安装应用资源</h1><h2 id="sharedUserId"><a href="#sharedUserId" class="headerlink" title="sharedUserId"></a>sharedUserId</h2><p>在当前应用中加载已安装的其他应用资源，需要二者有相同的<code>sharedUserId</code>，这样Android系统为二者分配同一个Linux用户ID，两个App可以相互访问代码、资源等。</p><blockquote><p>通过Shared User id,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是可以互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件.就像访问本程序的数据一样。</p><p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/51316688" target="_blank" rel="noopener">Android逆向之旅—Android中的sharedUserId属性详解 - CSDN博客</a></p></blockquote><p>具体设置方法如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"cf.android666.dynamicloadapk"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:sharedUserId</span>=<span class="string">"cf.android666.dynamic"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="筛选所有已安装应用信息"><a href="#筛选所有已安装应用信息" class="headerlink" title="筛选所有已安装应用信息"></a>筛选所有已安装应用信息</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> packageBeanList: ArrayList&lt;PackageInfoBean&gt; = arrayListOf()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> packageInfoList: ArrayList&lt;PackageInfo&gt; = arrayListOf()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> packageInfoList = packageManager.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES) <span class="keyword">as</span> ArrayList&lt;PackageInfo&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (packageInfoList.isNotEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> packageInfoList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.sharedUserId != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; x.sharedUserId.equals(sharedUid)</span><br><span class="line">            &amp;&amp; !x.packageName.equals(packageName)) &#123;</span><br><span class="line">            <span class="comment">//sharedUserId与当前App相同，且packageName和当前App不同的App信息，即插件App</span></span><br><span class="line">            packageBeanList.add(PackageInfoBean(packageManager</span><br><span class="line">                                                .getApplicationLabel(x.applicationInfo).toString(), x.packageName))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="生成插件App的Context"><a href="#生成插件App的Context" class="headerlink" title="生成插件App的Context"></a>生成插件App的Context</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activity.createPackageContext(<span class="string">"cf.android666.pluginapp"</span>,</span><br><span class="line">        Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY)</span><br></pre></td></tr></table></figure><h2 id="通过Context反射获取插件App中的资源"><a href="#通过Context反射获取插件App中的资源" class="headerlink" title="通过Context反射获取插件App中的资源"></a>通过Context反射获取插件App中的资源</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ClassLoader</span></span><br><span class="line"><span class="keyword">var</span> pClassLoader = PathClassLoader(pluginContext.packageResourcePath</span><br><span class="line">                , ClassLoader.getSystemClassLoader())</span><br><span class="line"><span class="comment">//反射获取该类及其资源</span></span><br><span class="line"><span class="keyword">var</span> clazz = pluginContext.classLoader</span><br><span class="line">        .loadClass(pluginContext.packageName + <span class="string">".R\$mipmap"</span>)</span><br><span class="line"><span class="keyword">var</span> abc = clazz.getField(s)</span><br><span class="line"><span class="keyword">var</span> id = abc.getInt(R.mipmap::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="comment">//调用插件App的Context获取其资源</span></span><br><span class="line"><span class="keyword">var</span> bg = pluginContext.resources.getDrawable(id)</span><br></pre></td></tr></table></figure><h1 id="加载未安装Apk内资源"><a href="#加载未安装Apk内资源" class="headerlink" title="加载未安装Apk内资源"></a>加载未安装Apk内资源</h1><h2 id="获取apk信息"><a href="#获取apk信息" class="headerlink" title="获取apk信息"></a>获取apk信息</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sdPath = Environment.getExternalStorageDirectory().absolutePath</span><br><span class="line"><span class="keyword">val</span> apkPath = <span class="string">"<span class="variable">$sdPath</span>/plugin/plugin.apk"</span></span><br><span class="line"><span class="keyword">var</span> info = packageManager.getPackageArchiveInfo(apkPath, PackageManager.GET_ACTIVITIES)<span class="comment">//获取未安装apk的packageInfo</span></span><br></pre></td></tr></table></figure><h2 id="获取ClassLoader"><a href="#获取ClassLoader" class="headerlink" title="获取ClassLoader"></a>获取ClassLoader</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = getDir(<span class="string">"dex"</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">var</span> dexClassLoader = DexClassLoader(apkPath, file.absolutePath, <span class="literal">null</span>, ClassLoader.getSystemClassLoader())</span><br></pre></td></tr></table></figure><blockquote><p>getDir()调用了Context的getDir()</p><p>Retrieve, creating if needed, a new directory in which the application can place its own custom data files.  You can use the returned File object to create and access files in this directory.  Note that files created through a File object will only be accessible by your own application; you can only set the mode of the entire directory, not of individual files.</p></blockquote><h2 id="通过反射加载类，获取资源"><a href="#通过反射加载类，获取资源" class="headerlink" title="通过反射加载类，获取资源"></a>通过反射加载类，获取资源</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawableClazz = dexClassLoader.loadClass(<span class="string">"cf.android666.pluginapp.R\$drawable"</span>)</span><br><span class="line"><span class="keyword">var</span> onePng = drawableClazz.getDeclaredField(<span class="string">"abc"</span>)</span><br><span class="line"><span class="keyword">var</span> onId = onePng.getInt(R.id::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)//反射获取资源<span class="title">id</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resources = getUninstallApkResource()<span class="comment">//resource也是通过反射获取到</span></span><br><span class="line"><span class="keyword">var</span> drawable = resources.getDrawable(onId)</span><br></pre></td></tr></table></figure><p><code>AssetManager.addAssetPath()</code>方法是用来将apk等中的资源添加到<code>AssetManager</code>中，再通过其获取到<code>Resources对象</code>，这样就获取到未安装apk中的资源了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUninstallApkResource</span><span class="params">()</span></span>: Resources &#123;</span><br><span class="line">    <span class="keyword">var</span> assetManager = AssetManager::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">newInstance</span></span>()</span><br><span class="line">    <span class="keyword">var</span> addAssetPath = assetManager.javaClass.getMethod(<span class="string">"addAssetPath"</span>,String::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    addAssetPath.invoke(assetManager, apkPath)<span class="comment">//设置了apkPath</span></span><br><span class="line">    <span class="keyword">return</span> Resources(assetManager, resources.displayMetrics, resources.configuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a href="https://www.cnblogs.com/lee0oo0/p/3665066.html" target="_blank" rel="noopener">Android之Android apk动态加载机制的研究（二）：资源加载和activity生命周期管理 - lee0oo0 - 博客园  </a></p><p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/51316688" target="_blank" rel="noopener">Android逆向之旅—Android中的sharedUserId属性详解 - CSDN博客</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/加载已安装应用、未安装apk中的资源.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制之ClassLoader</title>
      <link href="/blog/posts/b3994218/"/>
      <url>/blog/posts/b3994218/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文为<a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">《一看你就懂，超详细java中的ClassLoader详解 - CSDN博客》</a>阅读笔记</p></blockquote><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>JVM有三种类加载器：</p><ol><li><strong>BootStrap ClassLoader</strong> 启动类加载器，加载核心类库，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。</li><li><strong>Extention ClassLoader</strong> 扩展类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。</li><li><strong>App ClassLoader</strong> 应用程序加载器，加载当前应用的classpath的所有类。</li></ol><p>除以上三种外，还有用户自定义的类加载器。</p><p>每个类由加载它的类加载器和类本身确定其唯一性。也就是说，类加载器不同，类肯定不同。</p><h1 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h1><p>在加载类时，通过<strong>“双亲委托”</strong>机制，依次从<strong>1</strong> -&gt; <strong>3</strong>向上查询，再从<strong>3</strong>-&gt;<strong>1</strong>依次返回结果：</p><ol><li>调用<code>findLoadedClass(className)</code>查询是否已经加载该类</li><li>调用父加载器的<code>loadClass(className,false)</code>，若父加载器为空，则调用<code>BootStrap ClassLoader</code></li><li>如果还是没有加载到该类，调用<code>findClass(className)</code></li></ol><p>这样子保证了每个类都是先经过最顶端的类加载器<code>BootStrap ClassLoader</code>，如果没有加载到再依次经过<code>Extention ClassLoader</code>、<code>App ClassLoader</code> 加载，确保如String等关键类不会被自定义的ClassLoader加载而导致异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检测是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//父加载器不为空则调用父加载器的loadClass</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//父加载器为空则调用Bootstrap Classloader</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//父加载器没有找到，则调用findclass</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                <span class="comment">//调用resolveClass()</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AppClassLoader</code>和<code>ExtClassLoader</code>都继承自<code>URLClassLoader</code></p><p><code>AppClassLoader</code>的父加载器是<code>ExtClassLoader</code>，<code>ExtClassLoader</code>的父加载器为<code>null</code>，故而会调用<code>BootStrap ClassLoader</code></p><p>ClassLoader如果没有指定父加载器，则默认的父加载器为<code>AppClassLoader</code>，自定义ClassLoader也是如此。</p><h1 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h1><p>自定义ClassLoader一般步骤：</p><ol><li>继承自<code>ClassLoader</code></li><li>重写<code>findClass()</code></li><li>在<code>findClass()</code>方法中调用并返回<code>defineClass()</code></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MClasLoader</span>:<span class="type">ClassLoader</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findClass</span><span class="params">(name: <span class="type">String</span>?)</span></span>: Class&lt;*&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sysDir = System.getProperty(<span class="string">"user.dir"</span>)</span><br><span class="line">        <span class="keyword">var</span> classPath = <span class="string">"<span class="variable">$sysDir</span>/src/main/res/<span class="variable">$name</span>.class"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> classFile = File(classPath)</span><br><span class="line">        <span class="comment">//【注意】这里一次只读取一个字节，否则会报错java.lang.ClassFormatError:</span></span><br><span class="line">        <span class="comment">// Extra bytes at the end of class file TestClass</span></span><br><span class="line">        <span class="keyword">var</span> bytes = ByteArray(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">var</span> fileInputStream = FileInputStream(classFile)</span><br><span class="line">        <span class="keyword">var</span> len = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> byteBuffer = ByteOutputStream()</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            len = fileInputStream.read(bytes)</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.write(bytes)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> byteArr = byteBuffer.toByteArray()</span><br><span class="line">        <span class="keyword">return</span> defineClass(name,byteArr,<span class="number">0</span>,byteArr.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clazz = MClasLoader().loadClass(<span class="string">"TestClass"</span>)</span><br><span class="line">    <span class="keyword">var</span> say = clazz.getDeclaredMethod(<span class="string">"say"</span>,String::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    say.invoke(clazz.newInstance(),<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">    print(MClasLoader().parent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>defineClass()</code>则将一个字节数组转化为一个类的实例（Converts an array of bytes into an instance of class with an optional ProtectionDomain）</p><h1 id="contextClassLoader"><a href="#contextClassLoader" class="headerlink" title="contextClassLoader"></a>contextClassLoader</h1><p>每个线程都有一个ClassLoader：<code>contextClassLoader</code>，通过将其设置为自定义的ClassLoader可以在加载类的时候做一些特殊的事情。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().contextClassLoader = MClasLoader()</span><br><span class="line"><span class="keyword">var</span> clazz = Class.forName(<span class="string">"TestClass"</span>,</span><br><span class="line">        <span class="literal">true</span>, Thread.currentThread().contextClassLoader)</span><br><span class="line"><span class="keyword">var</span> say = clazz.getDeclaredMethod(<span class="string">"say"</span>,String::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">say.invoke(clazz.newInstance(),<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">println(Thread.currentThread().contextClassLoader )</span><br><span class="line">println(Thread.currentThread().contextClassLoader.parent )</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">MClasLoader@1d44bcfa</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/JVM类加载机制之ClassLoader.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 异步消息机制 Handler、Message、Looper</title>
      <link href="/blog/posts/5962504e/"/>
      <url>/blog/posts/5962504e/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此文为鸿洋博客阅读笔记，配合原文食用口味更佳。</p><p><a href="https://blog.csdn.net/lmj623565791/article/details/38377229" target="_blank" rel="noopener">Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系 - CSDN博客</a></p></blockquote><h1 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h1><p><img src="https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/Handler_Message_Looper.png?raw=true" alt="android消息机制思维图"></p><h1 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h1><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><h3 id="Looper-perpare"><a href="#Looper-perpare" class="headerlink" title="Looper.perpare()"></a><strong>Looper.perpare()</strong></h3><p><code>Looper.perpare()</code>方法创建<code>Looper对象</code>（同时创建<code>MessageQueue对象</code>），并与当前线程关联保存在<code>sThreadLocal</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(<span class="keyword">true</span>));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;  </span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);  </span><br><span class="line">        mRun = <span class="keyword">true</span>;  </span><br><span class="line">        mThread = Thread.currentThread();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a><strong>Looper.loop()</strong></h3><p><code>Looper.loop()</code>方法获取保存的<code>Looper对象</code>并由此获取到<code>MessageQueue对象</code>。</p><p>通过<code>for循环</code>，不停的通过<code>mQueue</code>获取到<code>msg</code>，并调用<code>msg.target.dispatchMessage(msg)</code>执行msg对应的处理方法。</p><p>最后通过<code>msg.recycle()</code>回收使用完的msg。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block  </span></span><br><span class="line">        ...</span><br><span class="line">        msg.target.dispatchMessage(msg); </span><br><span class="line">        ...</span><br><span class="line">        msg.recycle();  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Looper-myLooper"><a href="#Looper-myLooper" class="headerlink" title="Looper.myLooper()"></a><strong>Looper.myLooper()</strong></h3><p><code>myLooper()</code>内部调用<code>sThreadLocal</code>获取已有的<code>Looper对象</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Android的Activity默认在UI线程调用了Looper的<code>prepare()</code>和<code>loop()</code>方法</strong></p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><h3 id="handler-sendMessage"><a href="#handler-sendMessage" class="headerlink" title="handler.sendMessage()"></a>handler.sendMessage()</h3><p>Handler构造方法会获取到<code>mLooper</code>和<code>mQueue</code>以及<code>mCallback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mLooper = Looper.myLooper();  </span><br><span class="line">mQueue = mLooper.mQueue;  </span><br><span class="line">mCallback = callback;  <span class="comment">// Handler()中此值为null</span></span><br></pre></td></tr></table></figure><p><code>sendMessage()</code>方法最终会调用<code>sendMessageAtTime()</code>方法,在其内部调用<code>enqueueMessage()</code>方法，将handler赋予msg.target，并将msg压入mQueue中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enqueueMessage方法</span></span><br><span class="line">msg.target = <span class="keyword">this</span>;</span><br><span class="line">queue.enqueueMessage(msg, uptimeMillis);<span class="comment">//将handler发送的msg压入到当前线程的Looper持有的MessageQueue中</span></span><br></pre></td></tr></table></figure><h3 id="handler-dispatchMessage"><a href="#handler-dispatchMessage" class="headerlink" title="handler.dispatchMessage()"></a>handler.dispatchMessage()</h3><p>Handler的<code>dispatchMessage()</code>方法会在<code>Looper.loop()</code>中被调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;  <span class="comment">//msg自带的回调方法</span></span><br><span class="line">            handleCallback(msg);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;  <span class="comment">//handler指定的回调方法</span></span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            handleMessage(msg);  <span class="comment">//handler的handleMessage()方法</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中执行顺序是：<code>msg.callback</code> &gt; <code>mCallback</code> &gt; <code>handleMessage()</code></p><h3 id="handler-post"><a href="#handler-post" class="headerlink" title="handler.post()"></a>handler.post()</h3><p><code>handler.post(new Runnable())</code>调用了<code>getPostMessage(r)</code>方法将r赋予msg.callback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span>  </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;  </span><br><span class="line">      Message m = Message.obtain();  </span><br><span class="line">      m.callback = r;  </span><br><span class="line">      <span class="keyword">return</span> m;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后也是在<code>sendMessageDelayed方法</code>中调用<code>sendMessageAtTime()方法</code>将msg压入MessageQueue中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="msg的获取"><a href="#msg的获取" class="headerlink" title="msg的获取"></a>msg的获取</h2><ul><li><code>Message.obtain();</code> 复用MessageMessage池中已有的对象，避免出现分配内存 <strong>推荐</strong> </li><li><code>new Message();</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>Looper</strong>在<strong><code>perfare()</code></strong>方法中创建<code>Looper及MessageQueue对象</code>并保存在<code>sThreadLocal</code>中，</p><p>在<strong><code>loop()</code></strong>方法中通过<code>myLooper()</code>从<code>sThreadLocal</code>中取出<code>mLooper</code>，并由此获得<code>mQueue</code>，在for循环中通过<code>mQueue.next()</code>获取<code>msg</code>，用<code>msg.target.dispatchMessage()</code>方法回调<code>handler中的msg处理方法</code>。</p><p><strong>Handler</strong>在<strong><code>构造函数</code></strong>中通过<code>Looper.myLooper()</code>获取到<code>当前线程的Looper和MessageQueue</code>；</p><p><strong><code>sendMessage()</code></strong>方法最终通过<code>sendMessageAtTime()</code>调用<code>enqueueMessage()</code>方法<code>将msg压入到MessageQueue</code>中。</p><p>至此将<em>Looper和Handler通过MessageQueue联系在一起</em>，并共同参与处理Message。</p><p>此外<strong><code>handler.post(runnable)</code></strong>也是通过在<strong><code>post()</code></strong>内部调用<code>getPostMessage()</code>方法将<code>runnable赋予msg.callback</code>，并在<code>post()</code>中通过<code>sendMessageDelayed()</code>方法调用<code>sendMessageAtTime()方法</code>将<code>msg压入MessageQueue</code>中</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android_Handler_Message_Looper.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android多渠道打包知识</title>
      <link href="/blog/posts/a3a3dc4c/"/>
      <url>/blog/posts/a3a3dc4c/</url>
      
        <content type="html"><![CDATA[<p>国内Android应用常常要分发到多个应用商店，使用Android Studio正确配置build.gradle与AndroidManifest.xml文件可以<strong>一步打包多个渠道</strong>。</p><p>本文实现的多渠道打包可实现不同渠道：</p><ul><li>有不同的项目id（applicationId）</li><li>不同App名称（android:label）</li><li>不同App图标（android:icon）</li><li>等等</li></ul><h1 id="1-友盟配置"><a href="#1-友盟配置" class="headerlink" title="1.友盟配置"></a>1.友盟配置</h1><p>*具体配置请参考UMeng官方文档。</p><p>作为第三方统计平台，国内很多软件都使用的是Umeng的产品，故而大多数软件多渠道打包配置如下：</p><ul><li>添加依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">../app/build.gradle</span><br><span class="line">dependencies &#123;</span><br><span class="line"><span class="comment">//友盟sdk</span></span><br><span class="line">compile <span class="string">'com.umeng.sdk:common:latest.integration'</span></span><br><span class="line">compile <span class="string">'com.umeng.sdk:analytics:latest.integration'</span></span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure><ul><li>修改AndroidManifest.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!--友盟初始化appkey和channel--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:value</span>=<span class="string">"$&#123;APP_KEY&#125;"</span> <span class="attr">android:name</span>=<span class="string">"UMENG_APPKEY"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"UMENG_CHANNEL"</span> <span class="attr">android:value</span>=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改build.gradle</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line"> productFlavors &#123;</span><br><span class="line">        beta &#123;&#125;</span><br><span class="line">        baidu &#123;&#125;</span><br><span class="line">        zhushou91  &#123;&#125; <span class="comment">//不能以数字开头</span></span><br><span class="line">        anzhi &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors.all &#123;</span><br><span class="line"></span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name</span><br><span class="line">                                                 ,APP_KEY:umenInfo[<span class="string">'APP_KEY'</span>]]</span><br><span class="line">            <span class="comment">//这里有一个知识点，用build.gradle读取properties文件信息，用于将部分信息统一放置在本地配置文件中，避免泄漏，若无此类要求可直接使用 APP_KEY:'da15d26d1a'等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决flavor Dimensions问题  http://blog.csdn.net/syif88/article/details/75009663</span></span><br><span class="line">    flavorDimensions <span class="string">"versionCode"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他umeng要求的配置</span></span><br></pre></td></tr></table></figure><p>这样编译完之后，通过通过build&gt;Generate Signed APK…便可以打包不同渠道的apk，在友盟统计平台上统计各个渠道的App信息了。</p><h1 id="2-Android-Studio实现多渠道打包"><a href="#2-Android-Studio实现多渠道打包" class="headerlink" title="2.Android Studio实现多渠道打包"></a>2.Android Studio实现多渠道打包</h1><p>方法1要求依赖umeng模块，使用场景难免有些受限，其实我们也可以自己实现多渠道打包，方法1使用的应该也是此原理。</p><ul><li>AndroidManifest.xml</li></ul><p>在需要根据渠道不同而变化的地方使用<code>${KEY}</code>形式替换掉原先的值。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:label</span>=<span class="string">"$&#123;APP_NAME&#125;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"APP_TEXT"</span> <span class="attr">android:value</span>=<span class="string">"$&#123;APP_TEXT&#125;"</span>/&gt;</span>//可以在java文件中获取到</span><br></pre></td></tr></table></figure><ul><li>app/build.gradle</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">    beta &#123;applicationId = <span class="string">"cf.android666.mykotlin.beta"</span><span class="comment">//每个渠道有不同的包名</span></span><br><span class="line">        manifestPlaceholders = [APP_NAME : name ,APP_TEXT:<span class="string">'beta'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    baidu &#123;applicationId = <span class="string">"cf.android666.mykotlin.baidu"</span></span><br><span class="line">        manifestPlaceholders = [APP_NAME:<span class="string">'A APP'</span>,APP_TEXT:<span class="string">'baidu'</span>]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在java中获取<code>meta-data</code>（非必须）</li></ul><blockquote><p>Android获取Manifest中<meta-data>元素的值 - CSDN博客  <a href="https://blog.csdn.net/zhang31jian/article/details/29868235" target="_blank" rel="noopener">https://blog.csdn.net/zhang31jian/article/details/29868235</a></meta-data></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//application中的meta-data</span></span><br><span class="line"><span class="keyword">var</span> appInfo = context.packageManager.getApplicationInfo(context.packageName,</span><br><span class="line">        PackageManager.GET_META_DATA)</span><br><span class="line"><span class="comment">//service、receiver中的meta-data</span></span><br><span class="line"><span class="keyword">var</span> appInfo = context.packageManager.getServiceInfo(ComponentName(context,MService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>),<span class="type"></span></span></span><br><span class="line">                PackageManager.GET_META_DATA)</span><br><span class="line"><span class="keyword">var</span> appName = appInfo.metaData.getString(<span class="string">"APP_NAME"</span>)</span><br></pre></td></tr></table></figure><h1 id="3-生成多个渠道文件夹"><a href="#3-生成多个渠道文件夹" class="headerlink" title="3.生成多个渠道文件夹"></a>3.生成多个渠道文件夹</h1><p>还有一种方法，通过在项目中生成多个渠道的文件夹，在里面替换对应的资源文件，从而实现多渠道打包不同项目名，不同icon等等</p><ul><li><p>在../app/src/目录下新建对应渠道文件夹，和main同级</p></li><li><p>在该渠道目录下新建对应的资源目录，在打包时自动替换对应资源</p><p>​</p><p>目录树如下</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line"></span><br><span class="line">--baidu</span><br><span class="line"></span><br><span class="line">----res/drawable</span><br><span class="line"></span><br><span class="line">--beta</span><br><span class="line"></span><br><span class="line">--main</span><br><span class="line"></span><br><span class="line">----res/drawable</span><br></pre></td></tr></table></figure><h1 id="4-More"><a href="#4-More" class="headerlink" title="4.More"></a>4.More</h1><p>此外还有美团的多渠道打包技术等</p><p>具体可参考文章：<a href="https://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="noopener">美团Android自动化之旅—生成渠道包</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android多渠道打包知识.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus3简介</title>
      <link href="/blog/posts/c1d65822/"/>
      <url>/blog/posts/c1d65822/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>EventBus is a publish/subscribe event bus for Android and Java.</p><p>若无特殊说明，英文注释引自官方源码或文档，后同</p></blockquote><p>EventBus在android中可以用于组件间，组件和后台线程间的通信，他基于订阅、发布的机制，将事件的收/发解耦，开销小。</p><p>其流程如下（示意图来自官方github库）：</p><p><img src="https://github.com/greenrobot/EventBus/raw/master/EventBus-Publish-Subscribe.png" alt="EventBus-Publish-Subscribe"></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="EventBus的三个要素"><a href="#EventBus的三个要素" class="headerlink" title="EventBus的三个要素"></a>EventBus的三个要素</h2><ul><li><p>Event</p><p>事件，要传递的事件（一个类），EventBus传递该事件的对象，要传递的信息包含在该对象的属性中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Subscriber</p><p>订阅者，当事件发生时要对事件执行的操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span>  <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Publisher</p><p>发布者，在合适的时候发布事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(Event())</span><br></pre></td></tr></table></figure><p>此外还需要注册、注销EventBus以便订阅者能够正常接收消息</p></li></ul><h2 id="Subscriber的5个线程模式（ThreadMode）"><a href="#Subscriber的5个线程模式（ThreadMode）" class="headerlink" title="Subscriber的5个线程模式（ThreadMode）"></a>Subscriber的5个线程模式（ThreadMode）</h2><ul><li><p>POSTING</p><p>默认的，订阅者和发布者在同一个线程（Subscriber will be called directly in the same thread, which is posting the event）。因为有可能是在主线程，所以不要耗时操作，以免ANR。</p></li><li><p>MAIN</p><p>Android中，订阅者会在UI线程被唤起，同样不能耗时操作</p><blockquote><p>If the posting thread is the main thread, subscriber methods will be called directly, blocking the posting thread. Otherwise the event is queued for delivery (non-blocking). </p></blockquote></li><li><p>MAIN_ORDERED</p><p>Android，订阅者会在UI线程被唤起，不能耗时操作。</p><blockquote><p>Different from MAIN, the event will always be queued for delivery. This ensures that the post call is non-blocking.</p></blockquote></li><li><p>BACKGROUND</p><p>Android中，如果post在主线程，那么订阅者在新开的后台线程，否则在post的线程被唤起。</p><p>在如果不是在Android中，则都在后台线程唤起。</p></li><li><p>ASYNC</p><p>订阅者在新的子线程中运行，独立于UI线程和post线程</p></li></ul><h1 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h1><h2 id="普通事件"><a href="#普通事件" class="headerlink" title="普通事件"></a>普通事件</h2><ol><li><p>定义事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span>(s: String)&#123;</span><br><span class="line">    <span class="keyword">var</span> string : String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        string = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(context)</span><br></pre></td></tr></table></figure></li><li><p>设置订阅者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">      Log.d(<span class="string">"tag"</span>,event.string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发布</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(Event(<span class="string">"hello"</span>))</span><br></pre></td></tr></table></figure></li><li><p>注销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(context)</span><br></pre></td></tr></table></figure></li></ol><h2 id="粘性事件"><a href="#粘性事件" class="headerlink" title="粘性事件"></a>粘性事件</h2><p>粘性事件即事件发生（<code>postSticky()</code>）之后，再订阅，也可对事件进行处理</p><p>发布（<code>postSticky()</code>）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(Event(<span class="string">"粘性事件"</span>))</span><br></pre></td></tr></table></figure><p>订阅者（<code>sticky = true</code>）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true)</span><span class="comment">//sticky默认为false，可以不写</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">"tag"</span>,event.string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上修改<code>发布</code>和<code>订阅者</code> 之后，当<code>postSticky()</code>之后，只有下次<code>注册事件</code>时，<code>订阅者</code>才会对事件进行反应。</p><p>如下代码就只会在点击事件之后，<code>订阅者</code>才会对<code>postSticky()</code>事件做反应</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span>&#123;</span><br><span class="line">    EventBus.getDefault().register(context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">greenrobot/EventBus: Event bus for Android and Java that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality.</a></p><p><a href="http://blog.csdn.net/itachi85/article/details/52205464" target="_blank" rel="noopener">Android事件总线（一）EventBus3.0用法全解析 - CSDN博客</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/TheUseOfEventBus.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制解析</title>
      <link href="/blog/posts/cf83ef31/"/>
      <url>/blog/posts/cf83ef31/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文介绍了java虚拟机类加载机制。</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>JVM类加载一共7步，前五步是类加载机制，各个步骤按照顺序进行，但是并非固定的1,2,3步，在实际中有可能从其中间某一步开始。</p><p>类加载机制一般分为三部分：<strong>加载Loading -&gt; 连接Linking -&gt; 初始化Initializing</strong></p><p><img src="https://github.com/jixiaoyong/Notes-Files/blob/master/draw-io/png/JVMClassLoader.png?raw=true" alt="JVM Class Loader"></p><p>其中<strong>加载、验证、准备和初始化</strong>发生的顺序是确定的，但<strong>解析</strong>可以在初始化之后开始（java动态绑定）</p><blockquote><p>java绑定分为静态绑定和动态绑定：</p><ul><li><strong>静态绑定</strong>：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</li><li><strong>动态绑定</strong>：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</li></ul><p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/17881581</a></p></blockquote><h1 id="类加载机制具体过程"><a href="#类加载机制具体过程" class="headerlink" title="类加载机制具体过程"></a>类加载机制具体过程</h1><h2 id="I-Loading"><a href="#I-Loading" class="headerlink" title="I.Loading "></a><strong>I.Loading </strong></h2><p><strong>加载</strong>，JVM将文件（class，jar，zip，网络等）中的二进制字节流保存到虚拟机方法区和堆中,并用该二进制表示形式创建类或者接口的过程。</p><blockquote><p>Loading is the process of finding the binary representation of a class or interface type with a particular name and <em>creating</em> a class or interface from that binary representation</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html</a> (<em>英文文档若无特殊说明都是引用官方文档，下同</em>)</p></blockquote><ol><li><p>用<strong>类全限定名</strong>获取类的二进制字节流</p></li><li><p>将字节流中<strong>静态存储结构</strong>转化为<strong>方法区</strong>的运行时数据结构</p></li><li><p><u><em>在<strong>堆</strong>中生成一个代表该类的java.lang.Class对象，作为方法区数据的访问入口。</em></u></p><p>（<del><strong>这句话存疑</strong> ，有人说<a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">在堆中</a> ,也有人说在<a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener">方法区</a> ,官方文档未相关描述</del> </p><p><code>2019/01/12 更新</code> Class对象没有明确规定实在<strong>JAVA堆</strong>中，对应HotSpot虚拟机来说，该对象在<strong>方法区</strong>中）</p></li></ol><p>类加载的地方是开发人员可控性最强的地方。除了可以使用系统的ClassLoader外还可以自定义ClassLoader（后文详述）。</p><p>类加载根据加载的类不同分为两种：</p><ul><li>非数组类 使用系统/自定义的类加载器完成加载</li><li>数组类 数组类不通过类加载器创建，而是通过JVM直接创建，但是数组类的元素类型要通过类加载器创建</li></ul><p>数组类的元素加载，根据数组元素的类型不同，分为两类：</p><ul><li>引用类 通过普通类加载器加载，并将数组用该类加载器标识</li><li>非引用类 将数组与引导类加载器标识</li></ul><p>数组类的可见性与其元素类的可见性一致。</p><hr><h2 id="II-Linking"><a href="#II-Linking" class="headerlink" title="II.Linking "></a><strong>II.Linking </strong></h2><p><strong>连接</strong>，是将类或者接口组合到java虚拟机运行状态的过程，这样他就可以被运行。</p><blockquote><p>Linking is the process of taking a class or interface and combining(组合) it into the run-time state of the Java Virtual Machine so that it can be executed(运行)</p></blockquote><p>连接一般分为3部分：验证Verification 、准备Preparation 、解析Resolution 。</p><blockquote><p>Linking a class or interface involves(包括) verifying and preparing(验证和准备) that class or interface, its direct(直接) superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.</p></blockquote><h3 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a><strong>Verification</strong></h3><p><strong>验证</strong>，保证class文件中的字节流信息符合虚拟机的要求。</p><blockquote><p>Verification(<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.10" target="_blank" rel="noopener">§4.10</a>) ensures that the binary representation(二进制格式) of a class or interface is structurally correct(结构正确) (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.9" target="_blank" rel="noopener">§4.9</a>). Verification may cause additional classes and interfaces to be loaded (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.3" target="_blank" rel="noopener">§5.3</a>) but need not cause them to be verified or prepared.</p></blockquote><p>验证内容包括：</p><ol><li>文件格式验证，验证字节流符合class文件格式规范；</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation "></a><strong>Preparation </strong></h3><p><strong>准备</strong>，在方法区对类变量分配内存，<strong>初始化为默认值</strong>（“零值”）。</p><p>比如：<code>static int i = 5；</code>在这一步只会进行到<code>i = 0</code> ，而<code>i = 5</code>要在初始化那一步才进行；</p><p>但是如果是final修饰的<strong>常量</strong>，则在此分配具体值。</p><blockquote><p><em>Preparation</em> involves creating the static fields for a class or interface and initializing such fields to their default values (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.3" target="_blank" rel="noopener">§2.3</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.4" target="_blank" rel="noopener">§2.4</a>). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">§5.5</a>), not preparation.</p></blockquote><p>准备工作可能在创建之后的任何时候发生，但是必须在初始化之前完成。</p><h3 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a><strong>Resolution</strong></h3><p><strong>解析</strong>，是在运行时常量池中动态确定符号引用的具体值的过程。</p><p>每个栈帧frame都有一个<code>当前方法</code>到<code>运行时常量池</code> 的引用，用来支持方法代码(method code)的<strong>动态链接（dynamic linking）</strong>。</p><p>method code：要被执行的方法以及通过符号引用的变量。</p><blockquote><p>Each frame (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">§2.6</a>) contains a reference to the run-time constant pool (<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.5" target="_blank" rel="noopener">§2.5.5</a>) for the type of the current method to support <em>dynamic linking</em> of the method code.</p></blockquote><p>动态链接将符号引用（symbolic references）转化为具体方法的调用（concrete method references）即直接引用，根据需要加载类来解析未定义的符号，将变量访问转化为运行时内存（runtime location）。</p><blockquote><p>This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.</p><p><em>方法和变量的这种后期绑定,使得方法使用的其他类的更改不太可能破坏这个代码。</em></p><p>直接引用可以直接定位到内存中某一段地址；符号引用则与JVM内存无管</p></blockquote><p>解析分为：</p><ol><li>类，接口解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><hr><h2 id="III-Initialization"><a href="#III-Initialization" class="headerlink" title="III.Initialization"></a><strong>III.Initialization</strong></h2><p><strong>初始化</strong> ，<em>Initialization</em> of a class or interface consists of executing its class or interface initialization method（执行类，接口的构造方法<code>clinit()</code>）</p><p>类或接口在被初始化之前，必须先被连接linked（ verified, prepared, and optionally（可选） resolved.）。</p><p>初始化有且只有以下五种情况：</p><ul><li><code>new</code>、读取/设置类（只有直接定义其的类才会，子类等不受影响）的静态变量（final修饰的常量除外）、执行静态方法</li><li><code>java.lang.reflect</code>反射调用类</li><li>初始化时，如果父类未初始化，先触发父类的初始化（接口类除外）</li><li>虚拟机等启动时执行主类的<code>main()</code>方法时，需要先初始化主类</li><li>JDK1.7 动态支持时，如果<code>java.lang.invoke.MethodHandle</code>实例最后解析结果<code>REF_get/put/invokeStatic的方法句柄对应的类未被初始化时，需要先初始化对应的类</code></li></ul><p>以上5种称为对一个类的<strong>主动引用</strong>，其余不会触发初始化，称为<strong>被动引用</strong></p><p><code>clinit()</code> ,有<strong>类变量赋值，静态语句块</strong>会由编译器合并为<code>clinit()</code>方法,分为两种：</p><ol><li>类 父类的<code>clinit()</code>方法会先于子类执行</li><li>接口  接口<code>clinit()</code>方法无需调用父类接口的<code>clinit()</code>方法；接口的实现类也无需执行接口的<code>clinit()</code>方法</li></ol><p><code>clinit()</code> 是线程安全的，在同一个类加载器中，多个线程的中只会有<strong>一个线程执行一次<code>clinit()</code></strong>，其余线程阻塞等待</p><p><code>clinit()</code>和<code>init()</code>不同如下：</p><blockquote><p><strong>init</strong>是对象构造器方法，也就是说在程序执行 new 一个对象调用该对象类的 constructor 方法时才会执行init方法<u>（是在<strong>new对象</strong>的时候<strong>初始化非静态变量</strong>）</u>；</p><p>而clinit是类构造器方法，也就是在jvm进行类<strong>加载—–验证—-解析—–初始化</strong>，中的初始化阶段jvm会调用clinit方法<u>（是在<strong>JVM初始化类</strong>的时候<strong>初始化静态变量</strong>）</u>。</p><p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener">http://blog.csdn.net/u013309870/article/details/72975536</a></p></blockquote><p>如果类没有静态赋值、静态语句块等则不会有<code>clinit()</code>方法。</p><p><code>clinit()</code>先于<code>init()</code>执行。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-5.html" target="_blank" rel="noopener">Java Virtual Machine Specification Chapter 5. Loading, Linking, and Initializing</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5.2" target="_blank" rel="noopener">Chapter 2. The Structure of the Java Virtual Machine</a></p><p><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">【深入Java虚拟机】之四：类加载机制</a></p><p><a href="http://blog.csdn.net/zhangliangzi/article/details/51319033" target="_blank" rel="noopener">JVM类加载机制详解（一）JVM类加载过程</a></p><p><a href="http://gityuan.com/2015/10/25/jvm-class-loading/" target="_blank" rel="noopener">Jvm系列3—类的加载 - Gityuan博客 | 袁辉辉博客  </a></p><p><a href="http://wiki.jikexueyuan.com/project/java-vm/class-loading-mechanism.html" target="_blank" rel="noopener">类加载机制 - 深入理解 Java 虚拟机 - 极客学院Wiki </a></p><p><a href="http://blog.csdn.net/javazejian/article/details/70768369" target="_blank" rel="noopener">深入理解Java类型信息(Class对象)与反射机制 - CSDN博客</a></p><p><a href="http://blog.csdn.net/u013309870/article/details/72975536" target="_blank" rel="noopener">深入理解jvm–Java中init和clinit区别完全解析 - CSDN博客</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/JVM类加载机制解析.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存分配</title>
      <link href="/blog/posts/f31c11c5/"/>
      <url>/blog/posts/f31c11c5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于《深入理解Java虚拟机：JVM高级特性与最佳实践》及部分在线博客整理。</p></blockquote><p>JVM：java virtual machine，一个java程序（进程）拥有一个jvm实例</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>JVM区域总体分两类，heap区和非heap区:</p><p><strong>heap区</strong>：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。<br><strong>非heap区</strong>：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(Java虚拟机栈)、Local Method Statck(本地方 法栈)。</p><h1 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h1><h2 id="1-head"><a href="#1-head" class="headerlink" title="1.head"></a>1.head</h2><p>堆，所有线程共享，存放所有对象实例、数组，GC主要场所，会OOM</p><p>分类</p><p><strong>1.新生代</strong></p><ul><li>eden  刚刚创建的对象优先</li></ul><ul><li>s1  经历几次GC</li></ul><ul><li>s2  经历几次GC</li></ul><p><strong>2.老年代</strong></p><ul><li>存活时间长的老年对象</li></ul><ul><li>大对象，如数组，大String…</li></ul><h2 id="2-stack"><a href="#2-stack" class="headerlink" title="2.stack"></a>2.stack</h2><p>栈，线程私有，存放基本数据和对象的引用，LIFO，会OOM，StackOverflow</p><h3 id="java-virtual-machine-stack"><a href="#java-virtual-machine-stack" class="headerlink" title="java virtual machine stack"></a>java virtual machine stack</h3><p>线程请求的栈深度大于JVM允许的深度会导致Stack Overflow<br>在编译期完成内存分配，如果虚拟机栈可以动态扩展，但是当拓展时无法申请到足够内存时会导致OutOfMemory</p><p><strong>stack  frame</strong></p><p>stack frame：栈帧，每执行一个方法就会产生一个栈帧并压入栈中</p><ul><li><p>局部变量表</p><ul><li>基本数据类型</li><li>对象引用</li><li>returnAddress 类型,指向了一条字节码指令的位置</li></ul></li><li><p>操作数栈</p></li><li>动态链接</li><li>方法出口等</li></ul><h3 id="native-method-stack"><a href="#native-method-stack" class="headerlink" title="native method stack"></a>native method stack</h3><p>与java虚拟机栈作用类似，不过native method stack是为native方法服务。<br>jvm可以自由实现它，甚至在sun HotSpot VM中将他与虚拟机栈合并<br>会OOM，stackOverflow</p><h2 id="3-method-area"><a href="#3-method-area" class="headerlink" title="3.method area"></a>3.method area</h2><p>方法区，线程共享，存放类信息，常量，静态变量，即时编译器编译后的代码，会OOM</p><p><strong>运行时常量池</strong></p><p>类加载后，编译器生成的各种字面量和符号引用会放到方法区的运行时常量池中，会OOM<br><code>String.intern()</code>，有该string对象则返回，无则创建并返回</p><blockquote><p><code>String.intern()</code>方法的注意事项：</p><p>JDK1.6及以下：将首次出现的对象实例<strong>复制</strong>到永久代，返回其引用</p><p>JDK1.7及以上：只会<strong>记录</strong>下首次出现的实例的引用，返回其引用</p><p>所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; String s2 = <span class="string">"java"</span>;</span><br><span class="line">&gt; System.out.println(s2.intern() == s2);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在JDK1.6及以下输出<code>false</code>，在JDK1.7及以上输出<code>true</code></p><p>此外，由于<code>String</code>类是<code>final</code>的，每次<code>new String(&quot;str&quot;)</code>会产生两个对象：一个是字符串<code>str</code>本身，一个是值为<code>str</code>的字符串。</p></blockquote><p>以<code>String s = &quot;Hello&quot;;</code>为例，解释几个概念：</p><p><strong>字面量</strong> 源码中表示具体的值，如<code>Hello</code></p><p><strong>符号引用</strong> 用来指代某种值得符号，如<code>s</code></p><p><strong>直接引用</strong> 可以定位到内存中的（类、对象、方法、变量）等的具体地址</p><h2 id="4-program-count"><a href="#4-program-count" class="headerlink" title="4.program count"></a>4.program count</h2><p><strong>程序计数器</strong>，线程私有，占用内存小，当做当前线程执行字节码的行号指示器。</p><p>若执行java方法，计数器记录的是正在执行的虚拟机字节码指令的位置</p><p>若执行的是native方法，则计数器为空undefined。</p><p>此内存区域是唯一一个在java虚拟机规范字没有规定任何OOMError的区域</p><h1 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h1><blockquote><p>以Sun HotSpot VM 为例</p></blockquote><h2 id="1-java堆溢出"><a href="#1-java堆溢出" class="headerlink" title="1.java堆溢出"></a>1.java堆溢出</h2><p>对象过多导致head内存溢出</p><ol><li>是内存泄漏memory leak，定位泄露对象</li><li>是内存溢出memory overflow，检查虚拟机堆参数是否可以调大；去除非必须的生命周期长的对象</li></ol><h2 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.虚拟机栈和本地方法栈溢出"></a>2.虚拟机栈和本地方法栈溢出</h2><ol><li><p>单线程，Stack Overflow</p><p>单线程下，栈帧过大或者虚拟机栈容量太小，当内存无法分配时都会导致Stack Overflow异常</p></li><li><p>多线程，</p><p>多线程时，每个线程栈分配的内存越大，越容易尝试内存溢出OOM</p><p>原因：虚拟机最大内存一定的情况下，去掉共享的Head和MethodArea占的内存，剩下的内存/单个线程最大栈内存=最大线程数量，当单个线程最大栈内存增加时，可以产生的线程数就会越少</p></li></ol><h2 id="3-运行时常量池溢出"><a href="#3-运行时常量池溢出" class="headerlink" title="3.运行时常量池溢出"></a>3.运行时常量池溢出</h2><p>运行时常量池属于方法区，当常量过多时会导致OOM，可以用String.intern()方法尝试</p><h2 id="4-方法区溢出"><a href="#4-方法区溢出" class="headerlink" title="4.方法区溢出"></a>4.方法区溢出</h2><p>经常动态生成大量Class的应用，如Spring等框架，需要注意OOM</p><h2 id="5-本地直接内存溢出"><a href="#5-本地直接内存溢出" class="headerlink" title="5.本地直接内存溢出"></a>5.本地直接内存溢出</h2><p>原生方法直接操作物理内存时导致物理内存不够，产生OOM</p><h1 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h1><p>JVM中GC会根据不同情况采取以下一系列算法组合进行内存回收</p><h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1.复制算法"></a>1.复制算法</h3><p><strong>原理</strong>：内存一分为二，只使用一半；GC时将存活对象复制到另一半内存，剩下的则清空</p><p><strong>优缺点</strong>：1.无STW，但不适合对象过多的情况；2.内存利用效率低</p><h3 id="2-标记清除法"><a href="#2-标记清除法" class="headerlink" title="2.标记清除法"></a>2.标记清除法</h3><p><strong>原理</strong>：从GC Roots开始遍历，可达标记存活，不可达则未标记</p><p>java中，GC Roots可以是以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul><p><strong>优缺点</strong>：1.要StopTheWorld防止标记的时候新new的对象未被标记而出错；</p><p>2.清除对象后内存不连续，会有一定的浪费</p><h3 id="3-标记压缩法"><a href="#3-标记压缩法" class="headerlink" title="3.标记压缩法"></a>3.标记压缩法</h3><p><strong>原理</strong>：类似【标记清除法】，但会对标记进行压缩，如a-&gt;b-&gt;c，会被压缩为a-&gt;c，具体试讲所有存活的对象都向一端移动，直接清理掉端边界外的内存</p><p><strong>优缺点</strong>：1.也要StopTheWorld</p><h3 id="4-引用计数算法"><a href="#4-引用计数算法" class="headerlink" title="4.引用计数算法"></a>4.引用计数算法</h3><p><strong>原理</strong>：引用+1，不引用-1，为0则删除，但是会有相互循环引用的问题，java未使用</p><p><strong>优缺点</strong>：相互循环使用：<br>a = b<br>b = a<br>除此之外再没有用到a，b的地方，但是由于a，b的引用不为0所以无法被回收，导致内存浪费</p><h2 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h2><p>一个不可达对象在“死缓”到“执行死刑”前至少经历两个标记过程</p><ol><li><p>第一次标记，筛选：是否有必要执行finalize()方法，若是则放到F-Queue队列中【触发】该方法，但不保证执行完该方法。</p><p>可以在finlize()方法中<strong>自救一次</strong>：在该方法中将<em>自身this</em>赋值给其他变量，这样在第二次标记时会被移出<em>即将回收</em>集合；但是由于finlize()方法只会被调用一次，所以只能自救一次。并<em>不推荐该方法</em>，该方法所有可以做的工作，可以用<strong>try…finally</strong>或者其他方法更好的实现</p></li><li><p>第二次标记，若finalize()方法以及调用过，或者为重写该方法，则“没必要执行”，可以回收</p></li></ol><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><h3 id="强引用StrongReference"><a href="#强引用StrongReference" class="headerlink" title="强引用StrongReference"></a>强引用StrongReference</h3><p>People p = new People();哪怕抛出OOM也不会被GC回收的对象</p><h3 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h3><p>SoftReference sf = new SoftReference(p);只要有足够内存就不会被GC回收，若内存不够则会被GC回收，常用作服务器缓存</p><h3 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a>弱引用WeakReference</h3><p>在下次GC回收之前都存在，用作android等内存紧张的设备中的缓存</p><h3 id="虚引用PhantomReference"><a href="#虚引用PhantomReference" class="headerlink" title="虚引用PhantomReference"></a>虚引用PhantomReference</h3><p>无法影响其生存时间，也无法通过虚引用获取其实例，设置虚引用只是为了在对象被GC回收时获取系统通知</p><h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/JVMMemory.png" alt=""></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/JVM内存知识整理.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android系统架构简介</title>
      <link href="/blog/posts/e3bb9a54/"/>
      <url>/blog/posts/e3bb9a54/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说明：本文基于<a href="http://gityuan.com/android/" target="_blank" rel="noopener">Android系统开篇 - Gityuan博客 | 袁辉辉博客 </a> 的学习笔记整理</p></blockquote><p>Android系统大体分为4个模块，从底层开始依次是1.linux内核、2.系统库+Android运行时、3.框架层、4.应用层。</p><p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/AndroidSystemArchitecture.png" alt=""></p><p>下图描述了Android系统从开机到Apk运行的整个流程。</p><p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/androidBoot.jpg" alt="系统启动框架图，来自gityuan.com"></p><p>流程如下：<code>Loader</code> -&gt; <code>Kernel</code> -&gt; <code>Native</code>-&gt; <code>Framework</code> -&gt; <code>App</code></p><p><strong>Loader层</strong></p><ol><li>Boot ROM ：开机时，引导芯片从ROM读取读取初始化代码，加载引导程序到RAM中。</li><li>Boot Loader：是启动Android系统之前的引导程序，检查RAM、初始化硬件参数等。</li></ol><p><strong>Kernel层</strong>（即Android内核层，进入Android系统）</p><ol><li>swapper进程（pid=0）：Boot Loader启动swapper（idle）进程，是由内核创建的第一个进程，用来初始化进程管理、内存管理、驱动等等。</li><li>kthreadd进程（pid=2）：是Linux系统的内核进程，<strong>是所有内核进程的鼻祖</strong>。</li></ol><hr><p><strong>Syscall</strong>，在Native和Kernel之间的系统调用层。</p><hr><p><strong>Native层</strong></p><ol><li>init进程（pid=1）：由swapper进程创建，<strong>是所有用户进程鼻祖</strong></li><li>init进程孵化出用户守护进程、启动ServiceManager管理系统服务，启动开机动画Bootnaim。</li></ol><hr><p><strong>JNI</strong>，Java层和Native（C/C++）层之间。</p><hr><p><strong>Framework层</strong></p><ol><li>Zygote进程：由init进程fork生成，是<strong>Android系统第一个java进程，是所有java进程的父进程</strong></li><li>SystemServer进程：由Zygote进程fork而来，<strong>是Zygote孵化的第一个进程</strong>，负责启动和管理整个<strong>java framework</strong>，如ActivityManager、PowerManager…</li><li>MediaServer进程：由init进程fork而来，负责启动和管理整个<strong>C++ framework</strong></li></ol><p><strong>APP层</strong></p><ol><li>Launcher：<strong>Zygote进程孵化的第一个App进程</strong>，桌面App。</li><li>其他由Zygote进程孵化的系统进程（Browser、Phone…）和非系统app进程。</li></ol><p>扼要内容如图：</p><p><img src="https://raw.githubusercontent.com/jixiaoyong/jixiaoyong.github.io/master/images/blog/2018-02/AndroidBootImg.png" alt="系统启动示意图"></p><p>Android常用的通信方式</p><ol><li>Binder</li><li>Socket</li><li>Handler</li></ol><p><strong>Binder/Socket用于进程间（都具有独立的地址空间）通信，而Handler消息机制用于同进程的线程间（共享内存空间）通信</strong></p><p>在Android系统中：</p><ul><li>Zygote进程  –&gt;  Socket机制</li><li>SystemServer、MediaServer、App之间  –&gt;  Binder IPC</li><li>同一进程不同线程间 –&gt;  Handler</li></ul><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android系统架构简介.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android阅读笔记</title>
      <link href="/blog/posts/aacd75ab/"/>
      <url>/blog/posts/aacd75ab/</url>
      
        <content type="html"><![CDATA[<h2 id="layout-weight"><a href="#layout-weight" class="headerlink" title="layout_weight"></a>layout_weight</h2><p>layout_weight 重要性，默认的是0,0等级最高，要显示，数字越大重要性越低。</p><p>例：a，b的宽度为0，layout_weight分别为1、2，则a，b宽度分别为父容器的2/3、1/3。</p><h2 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h2><p>PendingIntent是封装后的intent，有intent执行所需的context，所以即使要执行intent的activity已经消失或者还没生成，其他activity依然可以通过PendingIntent执行intent。</p><blockquote><p>PendingIntent is a description of an Intent and target action to perform with it. Instances of this class are created with <code>getActivity(Context, int, Intent, int)</code>, <code>getActivities(Context, int, Intent[], int)</code>, <code>getBroadcast(Context, int, Intent, int)</code>, and <code>getService(Context, int, Intent, int)</code>; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.</p></blockquote><p>也就是把自己要执行的intent和执行所需的context封装后给别人，请别人在适当的时候执行。</p><h2 id="android模拟器访问电脑localhost"><a href="#android模拟器访问电脑localhost" class="headerlink" title="android模拟器访问电脑localhost"></a>android模拟器访问电脑localhost</h2><p>电脑<code>localhost</code>或者<code>127.0.0.1</code>访问本地网址。</p><p>模拟器访问<code>localhost</code>会默认访问手机的本地网址，要访问电脑的本地网址则需要访问<code>10.0.2.2:8080</code>，记得加上对应的端口。</p><h2 id="获取屏幕画面"><a href="#获取屏幕画面" class="headerlink" title="获取屏幕画面"></a>获取屏幕画面</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">View decor = MainActivity.<span class="keyword">this</span>.getWindow().getDecorView();</span><br><span class="line">decor.setDrawingCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">imageView.setImageBitmap(decor.getDrawingCache());</span><br></pre></td></tr></table></figure><h2 id="获取网络信息，请求网络"><a href="#获取网络信息，请求网络" class="headerlink" title="获取网络信息，请求网络"></a>获取网络信息，请求网络</h2><p>需要请求权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">chackNetWork</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isNetAvailable = <span class="keyword">false</span>;</span><br><span class="line">    ConnectivityManager manager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (manager.getActiveNetworkInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        isNetAvailable = manager.getActiveNetworkInfo().isAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isNetAvailable) &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"open network"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setAction(Settings.ACTION_NETWORK_OPERATOR_SETTINGS);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android阅读笔记.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android实现可折叠toolbar</title>
      <link href="/blog/posts/b4832cd1/"/>
      <url>/blog/posts/b4832cd1/</url>
      
        <content type="html"><![CDATA[<p>使用到的类有：</p><ul><li>android.support.design.widget.CoordinatorLayout</li><li>android.support.design.widget.AppBarLayout</li><li>android.support.design.widget.CollapsingToolbarLayout</li><li>android.support.v7.widget.Toolbar</li></ul><h1 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h1><p>如图：</p><p><img src="http://jixiaoyong.github.io/blog/images/default/2018-02-22/coordinatorlayout.gif" alt=""></p><h1 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h1><p>CoordinatorLayout类，协调者布局，通过Behavior将一个子view（<code>child</code>）的行为和另一个子view（<code>dependency</code>）的活动联结起来，从而实现子view之间的联动。</p><p>AppBarLayout类，是一个实现了材料设计的默认垂直布局的ViewGroup，当其是CoordinatorLayout类的直接子view时,另外一个CoordinatorLayout的子view指定了behavior为AppBarLayout.ScrollingViewBehavior的实例（<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>）,且该子view需要是NestedScrollingChild的实现类。</p><p>CollapsingToolbarLayout类，提供一个可以折叠的toolbar布局，可以在这个布局里面，设置toolbar以及和toolbar一起联动的子view，本案例中是一张图片。</p><p>Toolbar类，实现toolbar的效果。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>源码：<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-02-22" target="_blank" rel="noopener">github</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">              <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">app:layout_collapseMode</span>=<span class="string">"parallax"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">app:layout_collapseMode</span>=<span class="string">"pin"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>CoordinatorLayout在最外层，注意其直接子view必须就是要实现联动的view，否则联动失效。</li><li>CollapsingToolbarLayout必须设置layout_scrollFlags，其余属性可选。</li></ol><blockquote><p>layout_scrollFlags说明如下：</p><p><strong>scroll</strong>：所有想滚动出屏幕的view都需要设置这个flag， 没有设置这个flag的view将被固定在屏幕顶部。</p><p><strong>enterAlways</strong>：这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。</p><p><strong>enterAlwaysCollapsed</strong>：假设你定义了一个最小高度（minHeight）同时enterAlways也定义了，那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。</p><p><strong>exitUntilCollapsed</strong>：当你定义了一个minHeight，此布局将在滚动到达这个最小高度的时候折叠。</p><p><strong>snap</strong>：当一个滚动事件结束，如果视图是部分可见的，那么它将被滚动到收缩或展开。例如，如果视图只有底部25%显示，它将折叠。相反，如果它的底部75%可见，那么它将完全展开。</p><p>作者：尹star</p><p>链接：<a href="https://www.jianshu.com/p/5287d090e777" target="_blank" rel="noopener">https://www.jianshu.com/p/5287d090e777</a></p></blockquote><ol><li>CollapsingToolbarLayout的子view需要指定layout_collapseMode，还有一点需注意：<strong>和toolbar联动的子view高度需大于toolbar高度，否则无效果。</strong></li><li>ViewPager就是本案例中触发子view联动效果的<code>dependency</code>，需要指定其behavior：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_behavior="@string/appbar_scrolling_view_behavior"</span><br></pre></td></tr></table></figure><p>其实际对应于android.support.design.widget.AppBarLayout$ScrollingViewBehavior ，这个是系统实现的一个behavior，用于和嵌套滑动事件绑定，<strong>指定该behavior的子view需要是NestedScrollingChild的实现类</strong>（系统提供了4个实现类：NavigationMenuView、NestedScrollView、RecyclerView、SwipleRefreshLayout），所以viewPager中页面有上述4个类或其子类时，才能实现绑定效果。</p><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p><strong>自定义Behavior</strong></p><p>自定义Behavior有两个目的：</p><ol><li>将两个或多个子view绑定；</li><li>将一个子view与另一个子view的滑动事件绑定在一起</li></ol><p>两者的差异在于在实现<code>CoordinatorLayout.Behavior&lt;T&gt;</code> 类时候具体重写的方法不一样。</p><p><strong>目的1</strong>：需要重写的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, T child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果dependency是要依赖的子view（此处是TempView类）的实例，说明它就是我们所需要的Dependency</span></span><br><span class="line">    <span class="keyword">return</span> dependency <span class="keyword">instanceof</span> TempView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次dependency位置发生变化，都会执行onDependentViewChanged方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, T child, View dependency)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据dependency的位置，设置child的位置,对child进行想要实现的变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//返回true表示改变了child 的尺寸和位置参数，否则返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>目的2</strong>：需要重写的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否要开始根据dependency子view的行为改变child的状态</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(@NonNull CoordinatorLayout coordinatorLayout, @NonNull ImageView child,@NonNull View directTargetChild, @NonNull View target, <span class="keyword">int</span> axes, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child <span class="keyword">instanceof</span> ImageView &amp;&amp; axes == View.SCROLL_AXIS_VERTICAL;<span class="comment">//子view是ImageView，并且滑动的方向是垂直的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当dependency子view滑动时，对child进行相应处理</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(@NonNull CoordinatorLayout coordinatorLayout, @NonNull ImageView child, @NonNull View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @NonNull <span class="keyword">int</span>[] consumed, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed, type);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="自定义-Behavior-的总结"><a href="#自定义-Behavior-的总结" class="headerlink" title="自定义 Behavior 的总结"></a>自定义 Behavior 的总结</h1><ol><li>确定 CoordinatorLayout 中 View 与 View 之间的依赖关系，通过 layoutDependsOn() 方法，返回值为 true 则依赖，否则不依赖。</li><li>当一个被依赖项 dependency 尺寸或者位置发生变化时，依赖方会通过 Byhavior 获取到，然后在 onDependentViewChanged 中处理。如果在这个方法中 child 尺寸或者位置发生了变化，则需要 return true。</li><li>当 Behavior 中的 View 准备响应嵌套滑动时，它不需要通过 layoutDependsOn() 来进行依赖绑定。只需要在 onStartNestedScroll() 方法中通过返回值告知 ViewParent，它是否对嵌套滑动感兴趣。返回值为 true 时，后续的滑动事件才能被响应。</li><li>嵌套滑动包括滑动(scroll) 和 快速滑动(fling) 两种情况。开发者根据实际情况运用就好了。</li><li>Behavior 通过 3 种方式绑定：1. xml 布局文件。2. 代码设置 layoutparam。3. 自定义 View 的注解。</li></ol><p>来源 ：<a href="http://blog.csdn.net/briblue/article/details/73076458" target="_blank" rel="noopener">针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN博客</a></p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://blog.csdn.net/briblue/article/details/73076458" target="_blank" rel="noopener">针对 CoordinatorLayout 及 Behavior 的一次细节较真 - frank 的专栏 - CSDN博客</a>  </li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0824/6565.html" target="_blank" rel="noopener">CoordinatorLayout 自定义Behavior并不难，由简到难手把手带你撸三款！ - 泡在网上的日子</a></li><li><a href="https://www.jianshu.com/p/8c92d0a1e591" target="_blank" rel="noopener">一步一步深入理解CoordinatorLayout - 简书</a></li><li><a href="https://www.jianshu.com/p/5287d090e777" target="_blank" rel="noopener">使用CoordinatorLayout打造一个炫酷的详情页 - 简书</a></li></ul><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android实现可折叠toolbar.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android自定义view的一些知识点</title>
      <link href="/blog/posts/e41787ec/"/>
      <url>/blog/posts/e41787ec/</url>
      
        <content type="html"><![CDATA[<h1 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h1><p>View的绘制分为3部分：</p><ol><li><p>measure</p><p>测量，决定了View的测量宽、高。几乎所有情况下都等同于View的最终宽、高（如果View需要多次measure才能确定大小，或者重写了<code>layout()</code>方法，并修改了传入的值的话则不会相等）。</p></li><li><p>layout</p><p>布局，决定View的四个顶点坐标和实际的宽、高。</p></li><li><p>draw</p><p>绘制，决定了View的具体显示内容。</p></li></ol><p>其中通过ViewRootImpl类的<code>performTraversals()</code>依次调用<code>performXXX()</code>方法。</p><h1 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h1><p>MeasureSpec是一个32位int值，高2位表示SpecMode，低30位表示SpecSize。</p><p>SpecMode有3种可能值：</p><ul><li>UNSPECIFIED 父容器没有限定View大小，可以是任意需要的大小</li><li>EXACTLY 父类指定了View的具体大小，View的最终大小就是这个值(match_parent或者具体数值)</li><li>AT_MOST View可以是这个值以内的任意大小(wrap_content)</li></ul><p>我们指定的View的LayoutParams和父容器（DecorView则是窗口的尺寸，普通View是父容器的MeasureSpec）一起决定了View的MeasureSpec，进而决定了View的宽高。</p><p>SpecSize决定于父容器的尺寸、以及View的margin和padding。</p><h1 id="View绘制流程"><a href="#View绘制流程" class="headerlink" title="View绘制流程"></a>View绘制流程</h1><p>final类型的<code>measure()</code>方法调用<code>onMeasure()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">            <span class="keyword">int</span> cacheIndex = forceLayout ? -<span class="number">1</span> : mMeasureCache.indexOfKey(key);</span><br><span class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">            &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onMeasure()</code>调用了<code>setMeasuredDimension()</code>方法设置了View宽、高的测量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = size;</span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;<span class="comment">//返回getSuggestedMinimumWidth/Height的大小</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;<span class="comment">//返回测量大小</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSuggestedMinimumXXX()</code>的值：</p><p>如果View没有背景，则返回的是View的<code>android:miniWidth</code>指定的值；</p><p>如果View有背景，则返回的是背景的<code>minimumWidth</code>的值和<code>android:miniWidth</code>指定的值中最大的一个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此，我们知道，如果直接继承自View的控件必须重写<code>onMeasure()</code>方法，设置wrap_content时候控件的大小。这是因为：</p><p>wrap_content对应的specMode是AT_MOST模式，其宽高等于<code>specSize</code>。</p><p>根据ViewGroup的<code>getChildMeasureSpec()</code>方法，我们知道此时的<code>specSize</code>是父容器目前可以用的大小，即这种情况下wrap_content的效果和match_parent的效果是一样的。</p><p>要避免这种情况，就需要重写<code>onMeasure()</code>方法，在里面专门指定wrap_content时View对应的大小。</p><h1 id="获取View的宽高"><a href="#获取View的宽高" class="headerlink" title="获取View的宽高"></a>获取View的宽高</h1><p>由于View的绘制和Activity的生命周期不同步，所以在<code>onCreate()/onStart()/onResume()</code>中都无法有效获取View的宽高。使用以下方式则可以正常获取View的宽高：</p><ol><li><p>Activity/View#onWindowFocusChanged()</p><p>当前的Window获取或失去焦点的时候调用，此时View已经初始化完毕，可以获取宽、高。</p><p>Activity窗口焦点变化(onPause/onResume)时会被调用多次。</p></li><li><p>View#post(runnable)</p><p>该runnable在view的消息队列尾部，被执行时View已经初始化好了，可以在这里获取宽高。</p></li><li><p>ViewTreeObserver</p><p>注册onGlobalLayoutListener，当View树的状态变更，或者View树内部View可见性发生变化就会被回调。</p><p>当View树的状态变更可能被调用多次。</p></li><li><p>View#measure()</p><p>手动调用<code>measure()</code>方法获取宽高。</p></li></ol><h1 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a>draw过程</h1><p>绘制过程分为以下几步：</p><ol><li>绘制背景 <code>background.draw(canvas);</code></li><li>绘制自身 <code>onDraw(canvas);</code></li><li>绘制children <code>dispatchDraw(canvas);</code></li><li>绘制装饰 <code>onDrawForeground(canvas);</code></li></ol><p><code>setWillNotDraw()</code>表示当前的ViewGroup不需要绘制任何内容，系统会对此进行优化（默认启用）。如果ViewGroup需要绘制内容时，则需要手动关闭这个标志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="绘制两个图形重叠部分"><a href="#绘制两个图形重叠部分" class="headerlink" title="绘制两个图形重叠部分"></a>绘制两个图形重叠部分</h1><p>android自定义view时两个图形重叠部分的绘制方式,一定要调用<code>canvas.saveLayer()</code> ，否则不生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个步骤十分重要，将当前画布保存为新的一层</span></span><br><span class="line"><span class="keyword">int</span> save = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,mWidth,mHeight,<span class="keyword">null</span>,Canvas.ALL_SAVE_FLAG);</span><br><span class="line"></span><br><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">paint.setColor(mBackgroundColor);</span><br><span class="line"></span><br><span class="line">RectF backgroundRectF = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight);</span><br><span class="line">canvas.drawRoundRect(backgroundRectF, mRadius, mRadius, paint);</span><br><span class="line"></span><br><span class="line">paint.setColor(mForwardColor);</span><br><span class="line"><span class="comment">//设置二者重叠部分的绘制方式</span></span><br><span class="line">paint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</span><br><span class="line">RectF progressRectF = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, mWidth * mProgress, mHeight);</span><br><span class="line">canvas.drawRect(progressRectF,paint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//restore to canvas</span></span><br><span class="line">canvas.restoreToCount(save);</span><br></pre></td></tr></table></figure><p><code>paint.setXfermode()</code>可以设置的值参考下图：</p><p><img src="http://jixiaoyong.github.io/images/20190408175100.png" alt=""></p><p>参考自<a href="https://www.cnblogs.com/DarkMaster/p/4618872.html" target="_blank" rel="noopener">【原】使用Xfermode正确的绘制出遮罩效果 - sky0014 - 博客园  </a></p><h1 id="适配自定义view宽高，设置默认值"><a href="#适配自定义view宽高，设置默认值" class="headerlink" title="适配自定义view宽高，设置默认值"></a>适配自定义view宽高，设置默认值</h1><p>以其宽度为例，在<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">    mWidth = widthSize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mWidth = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        mWidth = Math.min(mWidth, widthSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Android开发艺术探索》</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android自定义view的一些知识点.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java创建线程安全的单例Singleton</title>
      <link href="/blog/posts/36721083/"/>
      <url>/blog/posts/36721083/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在编码中常常会用到单例，来确保类有一个唯一的对象，一般情况下将构造方法私有化既可以实现，但当考虑到多线程时事情会变得有些复杂，本文讨论的正是几种多线程的情况下实现单例的方法。</p><h1 id="1-普通单例"><a href="#1-普通单例" class="headerlink" title="1.普通单例"></a>1.普通单例</h1><p>私有化构造方法，对外提供一个公有、静态的方法，在其内部判断类对象是否已经存在，否的话生成类对象再返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASingleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ASingleton as;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ASinleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"ASingleton init!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(as == <span class="keyword">null</span>) &#123;              <span class="comment">//tag1</span></span><br><span class="line">as = <span class="keyword">new</span> ASingleton();    <span class="comment">//tag2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在考虑多线程时，由于java代码是一行行进行的，假设有两个线程t1、t2，当as为null的时候t1执行到tag1位置，判断为true，于是准备执行tag2，就在此时，cup调度t2开始执行tag1，此时t1尚未执行tag2，所以在t2中tag1判断为true,t2也开始执行tag2生成一个新对象,这样当t1再次执行tag2时就会再生成一个新对象，这样就同时存在多个类的对象。</p><h1 id="2-同步锁"><a href="#2-同步锁" class="headerlink" title="2.同步锁"></a>2.同步锁</h1><p>对上面的代码稍作优化,可以看到使用了synchronized，对判断是否需要初始化进行了同步锁，这样当线程t1访问时，语句被锁定，t2运行到这里时，只能等t1运行完这段语句并释放之后，才能继续访问，此时as已经被赋予了对象，所以不会再继续新建，这样就保证了单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ASingleton as;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ASinleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"ASingleton init!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ASingleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (as == <span class="keyword">null</span>) &#123;</span><br><span class="line">as = <span class="keyword">new</span> ASingleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样也存在一个问题，每个线程每次获取单例都要进入同步锁，这样累计下来必然影响效率。</p><h1 id="3-双重检查锁定"><a href="#3-双重检查锁定" class="headerlink" title="3.双重检查锁定"></a>3.双重检查锁定</h1><p>那么在判断as为null后，对as的初始化进行同步锁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (as == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ASingleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (as == <span class="keyword">null</span>) &#123;           <span class="comment">//tag1</span></span><br><span class="line">as = <span class="keyword">new</span> ASingleton();  <span class="comment">//tag2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，当判断as为null时，才会进行初始化，同时由于初始化过程加锁，所以t1和t2无法同时访问初始化语句tag2，也保证了只能创建一个单例。</p><p>看起来很完美，但是由于java语言的特性，在该段代码编译为汇编语言时，上述方法会被编译为类似下面的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>判断as是否为null</span><br><span class="line"><span class="number">2.</span>令as = ASingleton() <span class="comment">//注意此时只是为as分配了内存，并未执行ASingleton的构造方法</span></span><br><span class="line"><span class="number">3.</span>开始执行ASingleton构造方法，as有了初始化的值</span><br><span class="line"><span class="number">4.</span>返回as</span><br></pre></td></tr></table></figure><p>那么，当t1执行到语句2，而t2开始执行语句1时，此时由于as已经分配了内存不为null，所以t2直接执行语句4，此时t2获取到的是一个没有执行构造方法的ASingleton对象，显然这样十分危险。在线程复杂的情况下很容易出现问题。</p><p>下面提供了两个结局思路，为简便起见，将其简单分为“饿汉模式”和“懒汉模式”（其实上述方法也可分为这两个模式，but，who cares…）。</p><h1 id="4-饿汉模式实现单例"><a href="#4-饿汉模式实现单例" class="headerlink" title="4.饿汉模式实现单例"></a>4.饿汉模式实现单例</h1><p>饿汉模式，即在声明的时候就将对象初始化。</p><p>这样实现单例的原理是类的静态变量全局唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ASingleton as = <span class="keyword">new</span> ASingleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ASinleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"ASingleton init!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> as;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样仍然有个问题，可能在用到ASingleton类的时候，并不需要立即获取到其单例，在这种情况下，饿汉模式仍然有浪费资源的嫌疑。</p><h1 id="5-懒汉模式实现单例"><a href="#5-懒汉模式实现单例" class="headerlink" title="5.懒汉模式实现单例"></a>5.懒汉模式实现单例</h1><p>懒汉模式，只有要用到该实例时，才获取该单例。</p><p>这次我们用到的时静态内部类，静态内部类与类的静态变量不同，只有明确调用静态内部类的时候才会初始化静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASingletonFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ASingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton as = <span class="keyword">new</span> ASingleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ASinleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"ASingleton init!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ASingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ASingleton.as;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，至此已经完成了java实现单例的绝大部分方法，但其实还有一张更加简洁的方法，那就是用enmu实现。</p><h1 id="6-enmu实现单例"><a href="#6-enmu实现单例" class="headerlink" title="6.enmu实现单例"></a>6.enmu实现单例</h1><p>由于枚举类型的对象是唯一的，所以是实现单例的较优选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> SingletonEnum&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，android开发者要注意，枚举占用的内存是普通单例的两倍多，所以，并不推荐在android中使用。</p><p>关于枚举的更详细资料，参阅(深入理解Java枚举类型(enum))[<a href="http://blog.csdn.net/javazejian/article/details/71333103#t7]" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/71333103#t7]</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Java创建线程安全的单例Singleton.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin学习笔记2</title>
      <link href="/blog/posts/8a52763a/"/>
      <url>/blog/posts/8a52763a/</url>
      
        <content type="html"><![CDATA[<ul><li><p>尾递归优化</p><p>把递归通过编译器转化为迭代，从而避免Stack Overflow</p><p>“以时间换取空间”</p><p>普通递归：</p><p>调用函数之后，还需要使用其返回值供自己使用，即自身返回值依赖于下一级函数，一般是调用自身的代码后面，还有其他的代码要执行。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(n: <span class="type">Int</span>)</span></span>: BigInteger &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> BigInteger.valueOf(<span class="number">1L</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n.toBigInteger().times(fun1(n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    尾递归：</p><p>​    调用自身之后，无需再返回当前函数,将处理结果以其他形式返回。</p><p>​    普通递归和尾递归都存在栈溢出风险（未优化前，例子中的函数计算10000到100000的阶乘时会溢出），kotlin提供了一种尾递归优化的方法——<code>tailrec</code>，使得编译器在编译时将递归转化为迭代，从而避免栈溢出。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>(<span class="keyword">var</span> value: BigInteger = BigInteger.valueOf(<span class="number">1L</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾递归，tailrec为kotlin中优化关键字</span></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">(n: <span class="type">Int</span>, m: <span class="type">Result</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        m.value = m.value.times(BigInteger.valueOf(<span class="number">1L</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m.value = m.value.times(n.toBigInteger())</span><br><span class="line">        fun2(n-<span class="number">1</span>,m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    本例中传入<code>fun2()</code>的<code>Result</code>实例保存了计算结果</p><ul><li><p>sealed class 密封类</p><p>密封类的所有子类必须在一个文件(xx.kt)中，他的子类是有限的，所以当<code>when()</code>的时候不需要<code>else</code>。</p><p>某种意义上他们像是一种<code>enum class</code>，只不过他的子类可以有多个实例。</p><blockquote><p>Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.</p></blockquote></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sealed class</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Play</span></span>(<span class="keyword">var</span> arg:String) : Player()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> Stop : Player()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">p2</span></span>():Player()</span><br></pre></td></tr></table></figure><ul><li>kotlin抛出异常</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getBookList</span><span class="params">()</span></span>:List&lt;Book&gt;</span><br></pre></td></tr></table></figure><ul><li><p>kotlin中的泛型</p><p><code>out</code> 协变，使用子类泛型的对象可以赋值给使用父类泛型的对象，相当于<code>extend</code>，用于方法的返回值（生产者）时使用</p><p><code>in</code> 逆变，使用父类泛型的对象可以赋值给使用子类泛型的对象，相当于<code>super</code>，用于方法的参数（消费者）时使用</p><p>不变，当泛型即当消费者，又当生产者时，不用<code>in</code>或者<code>out</code></p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> from = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> to = arrayOf(Any())</span><br><span class="line"></span><br><span class="line">    copyArray(from,to)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copyArray</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里的from被out修饰，只能作为生产者调用get之类的方法，不能作为消费者调用set之类的方法</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Kotlin学习笔记2.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin学习笔记1</title>
      <link href="/blog/posts/135b2780/"/>
      <url>/blog/posts/135b2780/</url>
      
        <content type="html"><![CDATA[<p>这是我在学习Bennyhuo（ <a href="https://github.com/enbandari/Kotlin-Tutorials" target="_blank" rel="noopener">github</a> ）的kotlin入门视频时的一些笔记，比较偏基础，用于查缺补漏。</p><ul><li><p>xx.map() &amp; xx.flatMap()</p><p>xx.flatMap()用于返回<strong>可迭代</strong>的数组，而xx.map()则是任何<strong>可迭代</strong>数据都有的用来遍历的方法。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = arrayListOf&lt;String&gt;(<span class="string">"a c v de  fb s e  gf d"</span>)</span><br><span class="line">arr.flatMap &#123;</span><br><span class="line">    it.split(<span class="string">" "</span>)</span><br><span class="line">&#125;.map&#123; </span><br><span class="line">    print(<span class="string">"<span class="subst">$&#123;it.toUpperCase()&#125;</span>"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>enum class 枚举类型</p><p>分为有参和无参，枚举变量以<code>,</code>分隔，如果enum还有方法或者伴生对象，则最后一个变量后为<code>;</code>，否则可为<code>,</code>、<code>;</code>或者没有。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    UK,USA,EU;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下为非必须代码，仅表示可以有这些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(s:<span class="type">String</span>)</span></span>:City&#123;</span><br><span class="line">            <span class="keyword">return</span> valueOf(s.toUpperCase())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        有参的情况如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span></span>(<span class="keyword">val</span> aName:String)&#123;</span><br><span class="line">    CHINA(<span class="string">"中国"</span>),</span><br><span class="line">    JAPAN(<span class="string">"日本"</span>),</span><br><span class="line">    USA(<span class="string">"美国"</span>),</span><br><span class="line">    UK(<span class="string">"英国"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        使用：通过enum的valueOf()方法获取枚举对象实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;uk&quot;</span><br><span class="line">var city = City.valueOf(s.toUpperCase())</span><br><span class="line">//或者通过伴生对象：</span><br><span class="line">var city = City.fun1(s)</span><br></pre></td></tr></table></figure><ul><li><p>companion object伴生对象</p><p>在类的定义，可以直接用<code>类名.方法名()</code>调用，相当于java中的静态方法</p><p>一个类中只能有一个伴生对象</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxx</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">(x: <span class="type">String</span>)</span></span>: Country &#123;</span><br><span class="line">            <span class="keyword">return</span> valueOf(x.toUpperCase())</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>object修饰的类</p><p>等同于只有一个实例的类，相当于java中的静态类，所有方法可以直接用类名调用</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ClassName&#123;</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>fun ClassName.funName()为类添加新的方法</p><p>对于不能直接修改的类，有需要对其增加一个方法，可以自定义一个<code>ClassName.funName()</code>的方法来达到这个目的。</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Country.<span class="title">sayNum</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this引用的是country对象</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        CHINA -&gt; <span class="number">1</span></span><br><span class="line">        JAPAN -&gt; <span class="number">2</span></span><br><span class="line">        USA -&gt; <span class="number">3</span></span><br><span class="line">        UK -&gt; <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在使用时可以通过<code>Country</code>的对象调用<code>syaNum()</code>方法</p><ul><li><p>data class 数据类</p><p>可以有方法，方便复制。</p><p>必须至少有一个参数，并且参数都需要用var/val修饰</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">dataClass</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">val</span> age :<span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><ul><li>文件读取<ul><li>resource目录下的文件读取</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = File(ClassLoader.getSystemResource(<span class="string">"input"</span>).path).readText()</span><br></pre></td></tr></table></figure><ul><li><p>与RxJava结合</p><p>统计文本中字母个数，基于RxJava 1.2.1</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(input.toCharArray().asIterable())</span><br><span class="line">        .filter &#123; !it.isWhitespace() &#125;</span><br><span class="line">        .groupBy &#123; it &#125;</span><br><span class="line">        .map&#123;</span><br><span class="line">            o -&gt;o.count().subscribe&#123;</span><br><span class="line">                print(<span class="string">"<span class="subst">$&#123;o.key&#125;</span>-&gt; <span class="variable">$it</span>  ,"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe()</span><br></pre></td></tr></table></figure><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Kotlin学习笔记1.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式在kotlin中的应用</title>
      <link href="/blog/posts/53875104/"/>
      <url>/blog/posts/53875104/</url>
      
        <content type="html"><![CDATA[<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p><strong>普通写法</strong>：</p><ol><li>定义一个接口OnClickListener</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义方法SetOnClickListener</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnCLickListener</span><span class="params">(listener: <span class="type">ClickListener</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的方法和Java中写法类似，在使用该方法时也类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testInterface = TestInterface()</span><br><span class="line"></span><br><span class="line">testInterface.setOnCLickListener(<span class="keyword">object</span> : TestInterface.ClickListener&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">            TODO(<span class="string">"not implemented"</span>) <span class="comment">//To change body of created functions use File | Settings | File Templates.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><strong>lambda写法</strong>：</p><p>定义只需要一步：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在初始化的时初始化listener</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span></span>(<span class="keyword">var</span> listener : (uri:String) -&gt; <span class="built_in">Unit</span>)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者直接定义这个变量</span></span><br><span class="line">listener:((uri : String)-&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在需要用到方法时，listener的方法，比如onClickListener()&#123;&#125;</span></span><br><span class="line">listener.invoke(agrs)</span><br></pre></td></tr></table></figure><p>使用起来也更加简洁：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = TestInterface&#123; uri: String -&gt; print(uri) &#125;<span class="comment">//获取对象的同时初始化listener</span></span><br></pre></td></tr></table></figure><blockquote><p>方法最后一个参数是lambda表达式时，lambda表达式的方法<code>{}</code>可以放到<code>()</code>的后面，如果只有这一个参数时，<code>()</code>也可以省略</p></blockquote><p>当方法只有一个参数时，可以省略参数，还用<code>it</code>代替：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testInterface.setNewOnClickListener &#123; print(it) &#125;</span><br></pre></td></tr></table></figure><p>甚至更加简洁，如果要执行的方法和listener定义的方法返回值类型相同，可以直接引用该方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testInterface.setNewOnClickListener(::print)</span><br></pre></td></tr></table></figure><h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><p>lambda在Java8中引进，可以很好的替代匿名内部类，使代码更加简洁。</p><p>lambda表达式形式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br></pre></td></tr></table></figure><blockquote><p>lambda 表达式总是被大括号括着， 完整语法形式的参数声明放在大括号内，并有可选的类型标注， 函数体跟在一个 <code>-&gt;</code> 符号之后。如果推断出的该 lambda 的返回类型不是 <code>Unit</code>，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。</p><p>kotlincn.net <a href="http://www.kotlincn.net/docs/reference/lambdas.html#高阶函数和-lambda-表达式" target="_blank" rel="noopener">高阶函数和lambda表达式</a></p></blockquote><p>使用lambda的形式如下<code>() -&gt; {}</code>,<code>()</code>内是参数，<code>{}</code>是函数具体的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java 8方式：</span></span><br><span class="line"><span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">"In Java8, Lambda expression rocks !!"</span>) ).start();</span><br></pre></td></tr></table></figure><p>这个例子来自importNew.com,<a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">Java8 lambda表达式10个示例</a></p><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><ul><li>xx.map()</li></ul><p>凡是<strong>可迭代</strong>的数据都可以使用<code>map()</code>函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args: Array&lt;String&gt; = arrayOf()</span><br><span class="line">args.map &#123;</span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以更简洁：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args.map(::print)</span><br><span class="line"><span class="comment">//::print表示引用该方法</span></span><br></pre></td></tr></table></figure><ul><li>xx.flatMap()</li></ul><p>返回<strong>可迭代</strong>的数组，可以和<code>xx.map()</code>一起使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">args.flatMap &#123;</span><br><span class="line">    it.split(<span class="string">" "</span>) <span class="comment">//把字符串按照" "切割</span></span><br><span class="line">&#125;.map&#123; </span><br><span class="line">    print(<span class="string">"<span class="subst">$&#123;it.toUpperCase()&#125;</span>"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Lambda表达式在kotlin中的应用.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中WebView使用的一些问题</title>
      <link href="/blog/posts/b35fe0f7/"/>
      <url>/blog/posts/b35fe0f7/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述：WebView在fragment中不显示"><a href="#问题描述：WebView在fragment中不显示" class="headerlink" title="问题描述：WebView在fragment中不显示"></a>问题描述：WebView在fragment中不显示</h1><p>解决代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kotlin 代码</span></span><br><span class="line">webView.webViewClient = <span class="keyword">object</span> : WebViewClient() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(view: <span class="type">WebView</span>?, url: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">                view!!.loadUrl(url)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此代码同样强制在webview中打开对应的网页</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android中WebView使用的一些问题.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python自动创建发布hexo文章并同步github</title>
      <link href="/blog/posts/d9a2e1ba/"/>
      <url>/blog/posts/d9a2e1ba/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>环境 linux(deepin)</p><p>python 2.7</p></blockquote><p>这是一个Python脚本，用于实现hexo文章创建、生成网页并预览、发布到对应xxx.github.io博客的全过程。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="使用时需要根据自己的项目更新main-py的一下变量："><a href="#使用时需要根据自己的项目更新main-py的一下变量：" class="headerlink" title="使用时需要根据自己的项目更新main.py的一下变量："></a>使用时需要根据自己的项目更新main.py的一下变量：</h2><ul><li><p>hexo_url = ‘your_path/hexo/blog’</p><p>【必需】本地hexo博客路径</p></li><li><p>hexo_public_dir = ‘your_path/hexo/blog/public’</p><p>【必需】本地hexo博客输出路径</p></li><li><p>hexo_post_dir = ‘your_path/hexo/blog/source/_posts’</p><p>【可选】本地hexo博客文章源文件路径</p></li><li><p>git_dir = ‘your_path/xxx.github.io’</p><p>【必需】博客要同步的git工程路径</p></li><li><p>git_backup_dir = ‘your_path/xxx.github.io/blog/backup/sources/_posts’</p><p>【可选】本路径用于备份post源文件到github</p></li><li><p>hexo.py 中的<code>post()</code>方法中<code>webbrowser.open(&#39;http://jixiaoyong.github.io/blog/&#39;)</code>中的博客地址，发布完后默认打开该网页。（后期也可以改为<code>post()</code>参数传入，这样只需要更改<code>main.py</code>就行）</p></li></ul><h2 id="运行main-py文件"><a href="#运行main-py文件" class="headerlink" title="运行main.py文件"></a>运行<code>main.py</code>文件</h2><ul><li>在Linux命令行输入如下命令，并回车，根据提示操作即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><p>​    Windows下可以运行<code>start.cmd</code>脚本（待实现）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//start.cmd脚本内容</span><br><span class="line">python main.py</span><br><span class="line">cmd</span><br></pre></td></tr></table></figure><ul><li><p>操作过程提示及说明如下：（渣英语请忽略…）</p><ul><li><p>input yout file name 输入要发布的文章名称xxx（当前版本暂不支持中文）</p><p>输入回车会自动创建xxx.md文件并打开（需要系统支持该格式）</p></li><li><p>are you finish your post 输入y或n，选择是否用hexo编译文章</p><p>y:编译文章  n:不编译文章，退出命令行</p></li><li><p>post or not  输入y或n，选择是否发布文章到网站,可以在打开的页面预览后做决定</p><p>y:发布文章  n:不发布文章，退出命令行</p></li><li><p>update post  《xxx》 提示开始发布文章，自动打开网页，并保存源文件</p></li></ul></li></ul><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>源代码已经上传<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-31/python%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%96%87%E7%AB%A0" target="_blank" rel="noopener">github</a></p><h1 id="后期计划"><a href="#后期计划" class="headerlink" title="后期计划"></a>后期计划</h1><ul><li>增加文件名中文支持</li><li><del>增加图片自动上传、替换为github链接</del>(2018/2/2已实现)</li></ul><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/PythonPostHexoToGithub.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python自动化部署文章</title>
      <link href="/blog/posts/af2aa19e/"/>
      <url>/blog/posts/af2aa19e/</url>
      
        <content type="html"><![CDATA[<p>python脚本实现一键自动新建文章，编译，预览，发布github.</p><p>just test</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬取gityuan所有文章列表</title>
      <link href="/blog/posts/6e070881/"/>
      <url>/blog/posts/6e070881/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>更新内容：</p><ul><li>爬取gityuan.com网站所有文章列表并输出json</li><li>汇总信息输出config.json为后面的客户端做准备</li></ul><p>更新文件：</p><ul><li>spider_main.py</li><li>html_output.py</li><li><strong>gityuan_urls.py</strong></li><li><strong>html_downloader.py</strong></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li><strong>spider_main.py</strong></li></ul><p>作为入口类，主要增加了初始化所有URL，以及便利这些URL的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp = SpiderMain()</span><br><span class="line"></span><br><span class="line">gityuan = gityuan_urls.GitYuanUrls()</span><br><span class="line"></span><br><span class="line">gityuan_urls = gityuan.get_urls(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">'gityuan_page_'</span></span><br><span class="line"></span><br><span class="line">sp.craw(gityuan_urls,file_name)</span><br></pre></td></tr></table></figure><p>其<code>craw()</code>方法修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">craw</span><span class="params">(self, root_urls, file_name)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#将所有有效链接全部加入</span></span><br><span class="line">        self.urls.add_new_urls(root_urls)</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#循环遍历这些链接</span></span><br><span class="line">        <span class="keyword">while</span> self.urls.has_next():</span><br><span class="line"></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            new_url = self.urls.get_new_url()</span><br><span class="line"></span><br><span class="line">            html_cont = self.downloader.download(new_url)</span><br><span class="line"></span><br><span class="line">            new_url, new_data = self.parser.parse(new_url, html_cont)</span><br><span class="line"></span><br><span class="line">            self.output.collect_data(new_data)</span><br><span class="line"></span><br><span class="line">            new_file_name = file_name + (<span class="string">'%d.json'</span>%i)</span><br><span class="line"></span><br><span class="line">            self.output.output_html(new_file_name)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#等待3s，防止太频繁访问被识别</span></span><br><span class="line">            sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#结束遍历，输出汇总信息</span></span><br><span class="line">        self.output.end(file_name,root_urls[<span class="number">0</span>],i)</span><br></pre></td></tr></table></figure><ul><li><strong>html_output.py</strong></li></ul><p>主要改动如下：</p><ol><li><code>output_html(self,file_name)</code>方法增加一个<code>file_name</code>的参数，并在内部调用<code>self.mkdir()</code>方法生成output目录，方便同时输出多个文档</li><li><code>mkdir()</code>方法，创建文件</li><li><code>end(self,file_name_start, url, num)</code>方法，输出汇总文档，代码如下</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">end</span><span class="params">(self,file_name_start, url, num)</span>:</span></span><br><span class="line"></span><br><span class="line">    self.mkdir()</span><br><span class="line"></span><br><span class="line">    file_name = self.output_dir + <span class="string">'config.json'</span></span><br><span class="line"></span><br><span class="line">    file_out = open(file_name,<span class="string">'w'</span>)</span><br><span class="line">    </span><br><span class="line">    current_time = time.time()</span><br><span class="line"></span><br><span class="line">    config_str = (<span class="string">'&#123;"url":"%s","total":"%d","update_time":"%d","file_name":"%s"&#125;'</span> % (url,num,current_time,file_name_start))</span><br><span class="line"></span><br><span class="line">    file_out.write(config_str)</span><br></pre></td></tr></table></figure><ul><li><strong>gityuan_urls.py</strong></li></ul><p>主要代码如下，通过循环遍历获取所有文章列表信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitYuanUrls</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="string">"""docstring for GitYuanUrls"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_urls</span><span class="params">(self, num)</span>:</span></span><br><span class="line"></span><br><span class="line">urls = []</span><br><span class="line"></span><br><span class="line">urls.append(<span class="string">'http://www.gityuan.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>,num):</span><br><span class="line">url_ = (<span class="string">'http://www.gityuan.com/page%d/'</span>%x)</span><br><span class="line">urls.append(url_)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> urls</span><br></pre></td></tr></table></figure><ul><li><strong>html_downloader.py</strong></li></ul><p>就在本文编辑的过程中，爬虫被识别，并且限制访问文件数量，所以对下载功能做了简单的伪装、增加超时处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download2</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="comment">#升级版</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#伪装为浏览器</span></span><br><span class="line">        req_header = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            request = urllib2.Request(url,<span class="keyword">None</span>,req_header)</span><br><span class="line"></span><br><span class="line">            response = urllib2.urlopen(request,<span class="keyword">None</span>,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response.read()</span><br><span class="line">        <span class="keyword">except</span> socket.timeout <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment">#超时处理</span></span><br><span class="line">            print(type(e))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当前爬虫主体功能以及实现，可以爬取gityuan.com所有有效文章列表，可以满足客户端需求。但仍然存在以下问题：</p><ol><li>没有伪装，爬虫<strong>很容易</strong>被识别并被拒绝服务（<del>就在刚刚写下这句话的时候，就发生了被限制访问，真*乌鸦嘴</del>）。</li><li>由于原网站特性，其置顶文章每页都有，会导致部分数据重复。</li><li>未爬取具体文章内容。</li></ol><blockquote><p><strong>说明</strong></p><p>本文只为学术研究，其中涉及到的第三方网站及其所有资源均属原主所有。向gityuan大神致敬，欢迎访问其<a href="http://gityuan.com/" target="_blank" rel="noopener">blog</a>。</p></blockquote><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/gityuan_spider" target="_blank" rel="noopener">github链接</a></p><p><code>tag</code>为<code>gityuan_spider1.5</code></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Python爬取gityuan所有文章列表.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫爬取gityuan.com数据并输出json</title>
      <link href="/blog/posts/9c0ccf0d/"/>
      <url>/blog/posts/9c0ccf0d/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>本文基于Python2.7</p></blockquote><p>这篇文章基于我在<a href="www.imooc.com">慕课网</a>上面学习Python简单爬虫写的内容，教程内容是爬取1000条百度百科的数据，但是教程中爬虫截止2018-01-27已经失效，刚好看到大神gityuan.com的内容，于是用Python实现爬取其网页内容并生成json数据。</p><p>本文即上述过程整理。</p><p>本文涉及源代码已上传github（<a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/gityuan_spider" target="_blank" rel="noopener">点这里查看</a>）。</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>爬虫主要活动是：</p><ol><li>爬取目标网页内容</li><li>对获取到的内容进行分析，获取有用数据</li><li>将处理好的数据按格式输出</li></ol><p>此外还需要有一个专门管理爬虫活动的主类，故而文件结构如下：</p><ol><li>spider_main.py             入口类</li><li>url_manager.py             管理要下载的链接</li><li>html_downloader.py    下载网页内容</li><li>html_paeser.py              对获取到的数据进行解析、加工</li><li>html_out.py                     输出格式化的数据</li></ol><p>目前只实现了爬取gityuan.com第一页内容并输出json，所以暂时不需要实现url_manager.py</p><h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><p><strong>spider_main.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入用到的各个类</span></span><br><span class="line"><span class="keyword">import</span> html_downloader</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义入口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderMain</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#初始化各个变量downloader、parser、output...</span></span><br><span class="line">    self.downloader = html_downloader.HtmlDownloader()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#略</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">craw</span><span class="params">(self,root_url)</span>:</span></span><br><span class="line">    </span><br><span class="line">    html_cont = self.downloader.download(root_url)</span><br><span class="line">    </span><br><span class="line">    new_data = self.parser.parse(html_cont)</span><br><span class="line">    </span><br><span class="line">    self.output.collect_data(new_data)</span><br><span class="line">    </span><br><span class="line">    self.output.output_json()</span><br><span class="line">    </span><br><span class="line">root_url = <span class="string">'http://www.gityuan.com/'</span></span><br><span class="line">sp = SpiderMain()</span><br><span class="line">sp.craw(root_url)</span><br></pre></td></tr></table></figure><ul><li>在<code>__init__()</code> 方法初始化各个变量；</li><li>在<code>craw()</code>中分别实现下载、解析网页内容、输出加工数据</li></ul><p><strong>html_download.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlDownLoader</span><span class="params">(object)</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self,url)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    respone = urllib2.urlopen(url,timeout=<span class="number">300</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> respone.getcode() != <span class="number">200</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> respone.read()</span><br></pre></td></tr></table></figure><p>下载并返回网页内容，比较简单</p><p><strong>html_parser.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="comment">#第三方包，需要单独下载</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlParser</span><span class="params">(object)</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self,html_cont)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> html_cont <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#用BeautifulSoup解析文档内容</span></span><br><span class="line">    soup = BeautifulSoup(html_cont,<span class="string">'html.parser'</span>)</span><br><span class="line">    </span><br><span class="line">    res_data = [] <span class="comment">#数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取所有的文章节点nodes</span></span><br><span class="line">    post_div_nodes = soup.find_all(<span class="string">'div'</span>,class_=<span class="string">'post-preview'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#遍历nodes，读取每一项内容并保存</span></span><br><span class="line">    <span class="keyword">for</span> post_div_node <span class="keyword">in</span> post_div_nodes:</span><br><span class="line">      post_div_soup = BeautifulSoup(str(post_div_node))</span><br><span class="line">      </span><br><span class="line">      post_info = &#123;&#125; <span class="comment">#字典dict</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">#判断URL是否是完整</span></span><br><span class="line">      url_ = post_div_soup.a[<span class="string">'href'</span>]</span><br><span class="line">      <span class="keyword">if</span> <span class="string">'http://'</span> <span class="keyword">not</span> <span class="keyword">in</span> url_:</span><br><span class="line">        url_ = <span class="string">"http://gityuan.com"</span> + url_</span><br><span class="line">       </span><br><span class="line">      <span class="comment">#保存数据</span></span><br><span class="line">      post_info[<span class="string">'url'</span>] = url_</span><br><span class="line">      post_info[<span class="string">'title'</span>] = post_div_soup.find(<span class="string">'h2'</span>).get_text()</span><br><span class="line">      post_info[<span class="string">'summary'</span>] = post_div_soup.find(<span class="string">'div'</span>,class_=<span class="string">'post-content-preview'</span>).get_text()</span><br><span class="line">       </span><br><span class="line">      res_data.append(post_info)</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">return</span> res_data</span><br></pre></td></tr></table></figure><p>这是爬虫功能的重点之一：对网页数据进行解析，由此数据才变为可用数据</p><p>主要是通过第三方插件<code>BeautifulSoup</code>解析数据，并保存到数组<code>res_data</code>中，具体见代码中实现</p><p><strong>html_output.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#下面两行代码解决编码问题，强制使用utf-8，而非默认的unicode编码</span></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonOutput</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.datas = []</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">collect_data</span><span class="params">(self,new_data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> new_data <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">      self.datas.append(new_data)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output_json</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment">#打开文件，并以json格式输出</span></span><br><span class="line">    fout = open(<span class="string">'output.json'</span>,<span class="string">'w'</span>)</span><br><span class="line">    </span><br><span class="line">    fout.write(<span class="string">'&#123;'</span>)</span><br><span class="line">    fout.write(<span class="string">r'"data":['</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> self.datas:</span><br><span class="line">      <span class="keyword">for</span> post_info <span class="keyword">in</span> data:</span><br><span class="line">        </span><br><span class="line">        fout.write(<span class="string">'&#123;'</span>)</span><br><span class="line">        fout.write(<span class="string">'"url":"%",'</span> % post_info[<span class="string">'url'</span>])</span><br><span class="line">        fout.write(<span class="string">'"title":"%",'</span> % post_info[<span class="string">'title'</span>])</span><br><span class="line">        fout.write(<span class="string">'"summary":"%",'</span> % post_info[<span class="string">'summary'</span>])</span><br><span class="line">        fout.write(<span class="string">'&#125;,'</span>)</span><br><span class="line">    <span class="comment">#为了符合json规范，最后一个输入空数据，无末尾逗号</span></span><br><span class="line">    fout.write(<span class="string">r'&#123;&#125;'</span>)</span><br><span class="line">    </span><br><span class="line">    fout.write(<span class="string">']&#125;'</span>)</span><br></pre></td></tr></table></figure><p>本类也很重要，主要是数据存取，以及将解析好的数据格式化输出</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文中代码经二次处理，不一定与源代码一致，但思路如此，以供参考。</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Python爬虫爬取gityuan-com数据并输出json.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android自定义透明背景的Dialog</title>
      <link href="/blog/posts/f20627c9/"/>
      <url>/blog/posts/f20627c9/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>通过自定义Dialog类，使用Style、AnimationDrawable等实现一个透明背景的、带进度更新的弹窗。</p><p>主要涉及Style自定义以及AnimationDrawable的使用。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li><strong>布局文件</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/dialog_bg"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/image"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"250dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"250dp"</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>资源文件</strong></li></ul><p>1）下载对应进度条的图片资源，放到drawable目录下</p><p>2）在drawable下新建dialog_progress.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/progress_1"</span> //资源文件</span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"300"</span> /&gt;</span> //持续时间ms</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@drawable/progress_2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）dialog圆角背景（非必须）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#6fb6d4"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"500dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4）自定义dialog的style</p><p><code>windowBackground</code>使背景透明</p><p><code>backgroundDimEnabled</code>则可以去除半透明遮罩效果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"diyDialogStyle"</span> <span class="attr">parent</span>=<span class="string">"@android:style/Theme.Dialog"</span> &gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span><span class="comment">&lt;!--背景透明--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:backgroundDimEnabled"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span><span class="comment">&lt;!--半透明，模糊--&gt;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>DIYDialog.java</strong></li></ul><p>继承自<code>Dialog.java</code> ，并用构造函数调用<code>initView()</code>方法初始化dialog样式，有其他需求可以再自己实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化view、控件</span></span><br><span class="line">View view = View.inflate(context, R.layout.layout_dialog, <span class="keyword">null</span>);</span><br><span class="line">ImageView imageView = view.findViewById(R.id.image);</span><br><span class="line">imageView.setBackgroundResource(R.drawable.dialog_progress);</span><br><span class="line"><span class="comment">//填充布局</span></span><br><span class="line">setContentView(view);</span><br><span class="line"><span class="comment">//实现动画</span></span><br><span class="line">AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getBackground();</span><br><span class="line">animationDrawable.run();</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-26/DIY_Dialog" target="_blank" rel="noopener">github源码路径</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android自定义透明背景的Dialog.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现AES加密解密应用</title>
      <link href="/blog/posts/375fcf66/"/>
      <url>/blog/posts/375fcf66/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近手机中涉及到用户账户密码保存的问题，选用AES加密算法进行加密后，再通过SharedPreferences保存在手机端。</p><p>本文主要介绍AES的加密、解密用法。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>初始化秘钥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AES = <span class="string">"AES"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWPRD = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKeySpec <span class="title">initKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SecretKeySpec key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        KeyGenerator kg = KeyGenerator.getInstance(AES);</span><br><span class="line">        kg.init(<span class="number">128</span>,<span class="keyword">new</span> SecureRandom(PASSWPRD.getBytes()));<span class="comment">//通过这种算法，每次生成的key都是一样的</span></span><br><span class="line">      <span class="comment">//也可以kg.init(128),这样每次生成的key都不一样</span></span><br><span class="line">        SecretKey securityKey = kg.generateKey();</span><br><span class="line">        <span class="keyword">byte</span>[] encodedKey = securityKey.getEncoded();</span><br><span class="line">        key = <span class="keyword">new</span> SecretKeySpec(encodedKey, AES);<span class="comment">//AES也可以替换为"AES/CBC/PKCS5PADDING"</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line"><span class="comment">//source是要加密的内容</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(AES);<span class="comment">//创建密码器</span></span><br><span class="line"><span class="keyword">byte</span>[] byteContent = source.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);<span class="comment">//创建密码器</span></span><br><span class="line"><span class="keyword">byte</span>[] result = cipher.doFinal(byteContent);<span class="comment">//加密</span></span><br></pre></td></tr></table></figure><p>解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(AES);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] result = cipher.doFinal(source);</span><br></pre></td></tr></table></figure><p>加密和解密的结果都是二进制的，无法直接转化为字符串，所以还需要将二进制与十六进制互转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseByte2HexStr</span><span class="params">(<span class="keyword">byte</span> buf[])</span> </span>&#123;</span><br><span class="line">    StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class="line">        String hex = Integer.toHexString(buf[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            hex = <span class="string">'0'</span> + hex;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuffer.append(hex.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] parseHexStr2Byte(String hexStr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (hexStr.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[hexStr.length() / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hexStr.length() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> high = Integer.parseInt(hexStr.substring(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">1</span>), <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> low = Integer.parseInt(hexStr.substring(i * <span class="number">2</span> + <span class="number">1</span>, i * <span class="number">2</span> + <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">        result[i] = (<span class="keyword">byte</span>) (high * <span class="number">16</span> + low);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在初始化一个key后，对文本进行加密和解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化key</span></span><br><span class="line">SecretKeySpec key = initKey();</span><br><span class="line"><span class="comment">//加密文本并转化为16进制，方便保存</span></span><br><span class="line">String eStr = parseByte2HexStr(encrypt(resource,key));</span><br><span class="line"><span class="comment">//将加密16进制文本转为二进制，进行解密</span></span><br><span class="line">String dStr = decrypt(parseHexStr2Byte(estr));</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://blog.csdn.net/hbcui1984/article/details/5201247" target="_blank" rel="noopener">JAVA实现AES加密 - CSDN博客</a></p><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/2018-1-22/encryption" target="_blank" rel="noopener">源码github链接</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Java实现AES加密解密.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解</title>
      <link href="/blog/posts/3f6454bb/"/>
      <url>/blog/posts/3f6454bb/</url>
      
        <content type="html"><![CDATA[<p>注解，<em>是描述Java代码的代码，它能够被编译器解析，向编译器、虚拟机说明一些事情，就像java中给程序员看的注释一样</em>。</p><p>Android应用开发这方面比较火的是<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">Butter Knife</a> ,本文讲述如何自定义注解替换findViewById()。</p><p>实现<strong>注解（annotation）</strong>的思路：通过<strong>反射</strong>获取到类中使用注解的变量，方法，再调用不同的方法对这些变量，方法进行处理以达到目的。</p><p>主要涉及三方面：</p><ul><li>定义一个注解类</li><li>定义一个注解帮助类</li><li>使用注解</li></ul><h1 id="java元注解"><a href="#java元注解" class="headerlink" title="java元注解"></a>java元注解</h1><p>java语言有四个预留的注解，用来生成其他自定义的注解：</p><ul><li>@Target</li></ul><p>说明注解所能修饰的范围。其值一般为ElementType.xxx，主要有：</p><ol><li>CONSTRUCTOR 描述构造器</li><li>FIELD 描述域</li><li>LOCAL_VARIABLE 描述局部变量</li><li>METHOD 描述方法</li><li>PACKAGE 描述包</li><li>PARAMETER 描述参数</li><li>TYPE 描述类，接口，enum声明</li></ol><ul><li>@Retention</li></ul><p>说明注解存活的生命周期,其值一般为RetentionPolicy.xxx，主要有</p><ol><li>SOURCE 仅源文件有效，被编译器丢弃</li><li>CLASS 在class文件中有效，可能被虚拟机忽略</li><li>RUNTIME 在运行时有效，在class被装载时被获取</li></ol><ul><li>@Documented</li></ul><blockquote><p>用于描述其它类型的annotation应该被作为被标注的程序成员的公共API</p></blockquote><p>表示是否将注解信息添加在java文档中。有该注解则会被Javadoc工具文档化</p><p>是一个标记注解，没有值</p><ul><li>@Inherited</li></ul><p>表示该标记会被标记的class的子类继承，在查找该注解时，如果当前类没有，会自动向上到其父类中查找，直到<em>该注解类型被找到或是查找完了Object类还未找到</em></p><p>是一个标记注解，没有值</p><p><strong>注解不能继承其他注解或接口</strong></p><h1 id="内建注解"><a href="#内建注解" class="headerlink" title="内建注解"></a>内建注解</h1><p>java中常见的内建注解：</p><ul><li><code>@Override</code> 重写父类方法</li><li><code>@Deprecated</code> 不赞成使用的api</li><li><code>@SuppressWarnings()</code> 忽略指定警告</li></ul><p>参数如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>deprecation</td><td>使用了过时的类或方法时的警告</td></tr><tr><td>unchecked</td><td>执行了未检查的转换时的警告</td></tr><tr><td>fallthrough</td><td>当Switch程序块进入进入下一个case而没有Break时的警告</td></tr><tr><td>path</td><td>在类路径、源文件路径等有不存在路径时的警告</td></tr><tr><td>serial</td><td>当可序列化的类缺少serialVersionUID定义时的警告</td></tr><tr><td>finally</td><td>任意finally子句不能正常完成时的警告</td></tr><tr><td>all</td><td>以上所有情况的警告</td></tr></tbody></table><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><h2 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">    <span class="comment">//注解参数只可以为public或者默认</span></span><br><span class="line">    <span class="comment">//如果注解中的值不是value，那么在进行注解的时候，需要给出对应的值的名字</span></span><br><span class="line">    <span class="comment">//如@ViewInject(id = R.id.buy)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//注解元素必须有明确的值，要不在定义注解时指定默认值，要不在使用注解时指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;<span class="comment">//指定默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注解参数支持数据类型如下：</p><p>1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)<br>2.String类型<br>3.Class类型<br>4.enum类型<br>5.Annotation类型<br>6.以上所有类型的数组</p></blockquote><h2 id="注解帮助类"><a href="#注解帮助类" class="headerlink" title="注解帮助类"></a>注解帮助类</h2><p>主要提供使用注解的方法，代码中的注解替换为真正要实现的逻辑，为注解和使用注解的类搭建一个桥梁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心方法如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bindViews</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取到使用注解的类</span></span><br><span class="line">        Class&lt;? extends Activity&gt; clazz = activity.getClass();</span><br><span class="line">  <span class="comment">//获取该类中的所有域变量</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">  <span class="comment">//通过遍历，将使用到注解的变量初始化</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">          <span class="comment">//获取注解对象</span></span><br><span class="line">            BindView bindView = field.getAnnotation(BindView.class);</span><br><span class="line">            <span class="keyword">if</span> (bindView != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//获取注解的值</span></span><br><span class="line">                <span class="keyword">int</span> viewId = bindView.value();</span><br><span class="line">                <span class="keyword">if</span> (viewId != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">//注解要实现的逻辑，此处为替代clazz中的findViewById()方法，注意getMethod()是获取该类及其实现的接口中所有的public方法</span></span><br><span class="line">                        Method findViewById = clazz.getMethod(<span class="string">"findViewById"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">                        findViewById.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        Object o = findViewById.invoke(activity, viewId);</span><br><span class="line">                      <span class="comment">//修改要注解的类，到此注解目的达到</span></span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        field.set(activity,o);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>在类中通过<code>@xxx()</code> 使用注解，并通过帮助类真正实现注解逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记注解</span></span><br><span class="line"><span class="meta">@BindView</span>(R.id.text)</span><br><span class="line"><span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用帮助类方法</span></span><br><span class="line">AnnotationUtils.bindViews(ASampleActivity.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用初始化之后的变量</span></span><br><span class="line">textView.setText(<span class="string">"hello annotation"</span>);</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="http://www.importnew.com/23816.html" target="_blank" rel="noopener">Java核心技术点之注解 - ImportNew</a></li><li><a href="http://gityuan.com/2016/01/23/java-annotation/" target="_blank" rel="noopener">java注解–gityuan</a></li></ul><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Java注解.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python入门知识</title>
      <link href="/blog/posts/a8f97c56/"/>
      <url>/blog/posts/a8f97c56/</url>
      
        <content type="html"><![CDATA[<p>基于Python3.x</p><p>Python文件默认格式<code>.py</code></p><p>首行默认以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li><p><strong>数字</strong></p><p>整数int  1，2，3</p><p>长整数long  1112L</p><p>浮点数float （小数）1.23，3.14</p><p>复数complex  3.14j</p></li><li><p><strong>字符串</strong></p><p> ‘abc’，”abc”，’’’abc‘’‘</p><p>‘x’和”x” 区别不大</p><p>‘’’abc‘’‘ 文本可以跨行</p><p>字符串前面加r或者R表示字符串内部不需要转义，否则要用<code>\</code> 转义</p><p>支持<code>a[0]</code>取值</p></li><li><p><strong>布尔值</strong></p><p> <code>True</code> 和<code>False</code></p><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算</p></li><li><p><strong>空值</strong></p><p> <code>None</code></p></li><li><p><strong>变量</strong> </p><p>命名规则：开头<code>aA_</code>，其后可以包含<code>aA_1</code></p></li><li><p><strong>常量</strong></p><p> 不能变的变量</p></li></ul><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul><li><p><strong>列表list</strong></p><p> [1,2,3,3]</p><p>插入list.insert(1,’vaule’)</p><p>删除list.pop() / list.pop(1)</p></li><li><p><strong>元组tuple </strong></p><p>(1,2,3,3)</p><p>与列表类似，但是一旦初始化就不能再修改</p><hr></li><li><p><strong>字典dict</strong></p><p> {‘a’:1,’b’:’vaule’}</p><p>键值对，读取快，相当于java的map</p></li><li><p><strong>set</strong></p><p> set([1,2,3])</p><p>键的集合，不能有重复的，相当于java的set</p></li></ul><h1 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h1><ul><li>if … : … elif … : … else : …</li><li>for x in xs : …</li><li>while x : …</li></ul><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">n</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>return</strong></li></ul><p>可以没有return，默认返回None</p><p>可以return 多个值，实际上返回的是一个tuple</p><ul><li><p><strong>pass</strong></p><p>不想执行任何语句，但是为了符合语法规范，可以用pass当做占位符</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>抛出异常</strong> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> TypeError(<span class="string">'an error'</span>)</span><br></pre></td></tr></table></figure><p>其中TypeError需要继承自<code>error</code>或者<code>Exception</code></p><ul><li><strong>参数</strong></li></ul><p>位置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg)</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p>默认参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg0,arg1 = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p><strong>注意</strong> 默认参数必须是参数中后面的几位；默认值必须不可变，如int，string等</p><p>可变参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg,*args)</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p><code>*args</code> 表示参数个数可变，可以输入list/tuple等，或者依次输入多个参数，用逗号分隔</p><p>关键词参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg,**keywords)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> '<span class="title">city</span>' <span class="title">in</span> <span class="title">kw</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>**keywords</code> 表示接受关键词作为参数传入，可以传入dict，或者依次输入多个关键词参数</p><p>命名关键词参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun0</span><span class="params">(args,*，name,age)</span></span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">fun1</span><span class="params">(arg.*args,name,age)</span>#如果命名关键词前面有可变参数，则不用*分隔</span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p>限制输入的关键字，限制只有name和age作为关键词参数</p><h1 id="使用其他文件的函数"><a href="#使用其他文件的函数" class="headerlink" title="使用其他文件的函数"></a>使用其他文件的函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用时 sys.fun()</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#使用时直接fun()</span></span><br><span class="line"><span class="keyword">from</span> xxFile <span class="keyword">import</span> fun</span><br><span class="line">form sys <span class="keyword">import</span> *</span><br><span class="line">form sys <span class="keyword">import</span> fun</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul><li><strong>定义类</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="string">'''doc for AClass</span></span><br><span class="line"><span class="string">you can use this by</span></span><br><span class="line"><span class="string">AClass.__doc__'''</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment">#默认的初始化方法</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">aFun</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#创建类对象</span></span><br><span class="line">a = AClass()</span><br><span class="line"><span class="comment">#调用方法</span></span><br><span class="line">a.aFun()</span><br></pre></td></tr></table></figure><p>所有的类方法必须至少有一个参数，推荐命名为self，系统会自动传入类对象，无需手动传入。</p><ul><li><strong>继承</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"father"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"i am f"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Father)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment">#子类方法不会自己调用父类方法，需要手动调用</span></span><br><span class="line">    super(Child,self).__init__()</span><br><span class="line">    <span class="comment">#调用父类方法2：</span></span><br><span class="line">    <span class="comment">#Father.__init__(self)</span></span><br><span class="line">    print(<span class="string">"child"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'i am c'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(self,where)</span>:</span></span><br><span class="line">    print(<span class="string">'go to %s'</span>%where)</span><br><span class="line"></span><br><span class="line">c = Child() <span class="comment">#father child</span></span><br><span class="line">c.say() <span class="comment">#i am c</span></span><br><span class="line">c.go(<span class="string">'home'</span>) <span class="comment">#go ro home</span></span><br></pre></td></tr></table></figure><p>子类继承父类，则需要在子类定义时传入父类</p><p>子类如果有与父类同名方法，则优先调用子类方法，除非子类特别调用父类的方法</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Python入门知识.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射简单应用</title>
      <link href="/blog/posts/3e9e8cb1/"/>
      <url>/blog/posts/3e9e8cb1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>反射，用来在运行时获取给定类的构造函数，变量，方法，并对其作以修改，而不必在编译时获取该类。</p><blockquote><p>Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.</p><p>–<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html</a></p></blockquote><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>定义一个待反射的类ATestClass.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cf.android666.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATestClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ATestClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">" age: "</span> + age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在TestReflect.java中反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//注意这里需要是完整的类名，包括包名</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"cf.android666.reflect.ATestClass"</span>);</span><br><span class="line">ATestClass aTestClsObj=(ATestClass) clazz.newInstance();</span><br><span class="line">  </span><br><span class="line"><span class="comment">//反射获取变量</span></span><br><span class="line">Field mName = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">mName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">mName.set(aTestClsObj, <span class="string">"aReflect"</span>);</span><br><span class="line">System.out.println(aTestClsObj.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射获取方法</span></span><br><span class="line">Method mInit= clazz.getDeclaredMethod(<span class="string">"init"</span>, String.class,<span class="keyword">int</span>.class);</span><br><span class="line">mInit.setAccessible(<span class="keyword">true</span>);<span class="comment">//解除私有限定，让我们在用反射时访问私有变量</span></span><br><span class="line">mInit.invoke(aTestClsObj, <span class="string">"aInitName"</span>,<span class="number">66</span>);</span><br><span class="line">System.out.println(aTestClsObj.name + aTestClsObj.getAge());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>反射的用法较为简单</p><ul><li>通过<code>Class.froName()</code> 获取Class对象<code>clazz</code> ，获取要反射的Class对象<code>aTestClsObj</code> </li><li>通过<code>clazz</code> 获取要反射Class的变量、方法</li><li>通过<code>aTestClsObj</code> 操作这些变量，方法</li></ul><p>其中需要注意的有</p><ul><li><code>f.setAccessible(true);</code> 方法可以解除<code>private</code> 限制，进而可以操作类的私有变量，方法</li><li><code>clazz.getXXX()</code> 方法获取<strong>全部公有</strong>变量、方法 ，<strong>包括父类或接口</strong>的xx，<code>clazz.getDeclaredXXX()</code> 方法获取<strong>全部</strong> 变量、方法，包括私有的，实现接口的方法，<strong>但是不包括父类的</strong></li></ul><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Java反射简单应用.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android通过Hook启动未注册Activity</title>
      <link href="/blog/posts/26eab50a/"/>
      <url>/blog/posts/26eab50a/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hook是钩子的意思，hook的过程是通过反射、代理等改变系统原有的行为以达到自己的目的。</p><p>本文主要是通过hook android 中的ActivityManagerService和Handler.CallBack，欺骗系统调起activity的过程，在调用startActivity时将targetIntent通过proxy伪装为proxyIntent，等到通过系统验证，正式启动activity时，再讲proxyIntent恢复为targetIntent，从而实现调用未在AndroidManifest.xml中注册的activity。</p><blockquote><p>需要注意，本方法只在Api&lt;26下有效。具体原因见后面。</p></blockquote><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="1-新建Activity等"><a href="#1-新建Activity等" class="headerlink" title="1.新建Activity等"></a>1.新建Activity等</h2><p><code>IndexActivity.java</code>用于启动<code>targetIntent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((Button)findViewById(R.id.btn1)).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">               <span class="comment">//启动未在AndroidManifest.xml注册的activity</span></span><br><span class="line">               mContext.startActivity(<span class="keyword">new</span> Intent(mContext,TargetActivity.class));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><code>TargetActivity.java</code> 和<code>ProxyActivity.java</code> 分别设置对应页面布局<code>setContentView(R.layout.activity_xxx);</code></p><p><code>HookApplication.java</code> 用于调用hook方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Utils.hookAms(<span class="keyword">this</span>);</span><br><span class="line">        Utils.hookHandle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AndroidManifest.xml</code>中注册<code>IndexActivity</code>和<code>ProxyActivity</code>，Application使用<code>HookApplication</code>。</p><h2 id="2-Utils-java实现hook具体逻辑"><a href="#2-Utils-java实现hook具体逻辑" class="headerlink" title="2.Utils.java实现hook具体逻辑"></a>2.Utils.java实现hook具体逻辑</h2><p><code>Utils.hookAms()</code> 实现拦截targetIntent并发起proxyIntent，欺骗系统对activity是否已注册的验证，其中proxyIntent通过<code>proxyIntent.putExtra(TARGET_KEY, targetIntent);</code> 方法携带targetIntent。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hookAms()核心代码</span></span><br><span class="line">Class hookActivityManagerNative = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line">            <span class="comment">//在api&gt;26时无此变量：gDefault，该方法失效</span></span><br><span class="line">            Field gDefault = hookActivityManagerNative.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">            gDefault.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object object = gDefault.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Class hookSingleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">            Field mInstance = hookSingleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">            mInstance.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            Object oldAms = mInstance.get(object);</span><br><span class="line"></span><br><span class="line">            Class hookIActivityManagerService = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                    <span class="keyword">new</span> Class&lt;?&gt;[]&#123;hookIActivityManagerService&#125;,</span><br><span class="line">                    <span class="keyword">new</span> MAmsInvocationHandler(context,oldAms));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将原有的ActivityManagerService替换为我们自定义的</span></span><br><span class="line">            mInstance.set(object,proxy);</span><br></pre></td></tr></table></figure><p>在<code>MAmsInvocationHandler</code> 里面实现targetIntent和proxy的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MAmsInvocationHandler核心代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MAmsInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TARGET_KEY = <span class="string">"targetIntent"</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            Intent targetIntent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    targetIntent = (Intent) args[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Intent proxyIntent = <span class="keyword">new</span> Intent(mContext, ProxyActivity.class);</span><br><span class="line">                proxyIntent.putExtra(TARGET_KEY, targetIntent);</span><br><span class="line">                args[index] = proxyIntent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mOldAms,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，已经对activity.startActivity做了拦截，所有的targetIntent都会被拦截，存储在proxyIntent中，以通过系统的检查。</p><p>接下来，通过系统检查后，<code>hookHandle()</code>通过重写Handler.CallBack，对启动proxyIntent事件做拦截，使之启动targetIntent对应的Activity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hookHandle()核心代码</span></span><br><span class="line">Class activityThreadCls = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThread = activityThreadCls.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThread.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object activityThread = currentActivityThread.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Field mH = activityThreadCls.getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mH.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Handler handler = (Handler) mH.get(activityThread);</span><br><span class="line">Field callBack = Handler.class.getDeclaredField(<span class="string">"mCallback"</span>);</span><br><span class="line">callBack.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">callBack.set(handler, <span class="keyword">new</span> ActivityThreadHandlerCallBack(handler));</span><br></pre></td></tr></table></figure><p>其中<code>ActivityThreadHandlerCallBack</code> 将返回我们自定义的CallBack以替换系统的，实现启动targetIntent而非proxyIntent。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThreadHandlerCallBack核心代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThreadHandlerCallBack</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.what == <span class="number">100</span>) &#123;</span><br><span class="line">            handleLaunchActivity(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.handleMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//主要代码，在这里将proxyIntent转化为targetIntent</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        Object object = msg.obj;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field intent = object.getClass().getDeclaredField(<span class="string">"intent"</span>);</span><br><span class="line">            intent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Intent proxyIntent = (Intent) intent.get(object);</span><br><span class="line">            Intent targetIntent = proxyIntent.getParcelableExtra(MAmsInvocationHandler.TARGET_KEY);</span><br><span class="line">            <span class="keyword">if</span> (targetIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyIntent.setComponent(targetIntent.getComponent());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，就实现了启动通过已经注册了的ProxyActivity启动未注册TargetActivity的全过程。</p><p>主要思想是找到系统实现该过程的逻辑，在对应地方通过反射获取到对应变量，插入自己的逻辑，从而达到目的。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>上面涉及到的代码路径：</p><p><a href="https://github.com/jixiaoyong/AndroidNote/tree/master/code/AndroidHook/20180116" target="_blank" rel="noopener">github源代码路径</a></p><p>参考了几篇文章，其中较为完整的一篇如下：</p><p><a href="https://www.jianshu.com/p/69bfbda302df" target="_blank" rel="noopener">Android插件化系列第（一）篇—Hook技术之Activity的启动过程拦截</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android通过Hook启动未注册Activity.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidService相关知识</title>
      <link href="/blog/posts/ad4c562c/"/>
      <url>/blog/posts/ad4c562c/</url>
      
        <content type="html"><![CDATA[<h2 id="启动一个Service"><a href="#启动一个Service" class="headerlink" title="启动一个Service"></a>启动一个Service</h2><ul><li><p>MyServices.java</p><p>必须继承自Service，或者如IntentService本身就是等其子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServices</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"TAG"</span>,<span class="string">"onBind"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Log.d(<span class="string">"TAG"</span>,<span class="string">"onCreate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.d(<span class="string">"TAG"</span>, <span class="string">"onDestroy: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>AndroidManifest.xml</p><p>注册MyServices</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyServices"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"cf.android666.myservices"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>MainActivity.java</p><p>在java中调用Service，需要<code>ServiceConnection</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onServiceConnected: 服务绑定"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onServiceDisconnected: 服务解绑"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, MyServices.class);</span><br><span class="line">bindService(intent, mConnection, Service.BIND_AUTO_CREATE);<span class="comment">//绑定Service</span></span><br><span class="line"><span class="comment">//startService(intent); 启动service</span></span><br><span class="line">unbindService(mConnection);<span class="comment">//解绑Service</span></span><br></pre></td></tr></table></figure><p><code>bindService()</code>和<code>startService()</code>的区别在于：</p><p>** <code>bindService()</code>将service和当前的activity绑定在一起，activity销毁时，service也会被销毁；</p><p>** <code>startService()</code>则只是“启动”service，在此后service的活动和activity无关，并一直存活。</p></li></ul><h1 id="Service具体分析"><a href="#Service具体分析" class="headerlink" title="Service具体分析"></a>Service具体分析</h1><p>Service在AndroidManifest.xml中的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android:name=<span class="string">".MyService"</span><span class="comment">//必须被指定</span></span><br><span class="line">android:exported=<span class="keyword">true</span>/<span class="keyword">false</span> <span class="comment">//是否能被其他应用隐式调用</span></span><br><span class="line"><span class="comment">//有intent-filter则默认为true，否则默认false；若手动指定为false则即使有intent-filter也无法隐式调用</span></span><br><span class="line">android:process=<span class="string">"remote"</span>/<span class="string">":remote"</span><span class="comment">//前者在共有的进程中进行，后者在名字为&#123;packageName&#125;:remote 的私有进程中进行，其他进行不可访问；如果不设置该属性，则service在应用自己的进程里面运行</span></span><br></pre></td></tr></table></figure><p>Service默认运行在创建他的线程中，要是进行耗时操作，最好在service中单独创建一个线程，这样子可以在子线程工作，在主线程中更新工作进度。</p><p>Service中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在初次创建服务时调用，并且直至服务死亡，只会被调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//在绑定服务是才会被调用，必须实现该方法</span></span></span><br><span class="line"><span class="function">IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//每一次通过startService()方法启动Service的时候都会被调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></span></span><br><span class="line"><span class="function">  <span class="comment">//1.intent 启动时，启动组件传递过来的Intent</span></span></span><br><span class="line"><span class="function">  <span class="comment">//2.flags 表示启动请求时是否有额外数据，可以是：</span></span></span><br><span class="line"><span class="function">  <span class="comment">//  0：无</span></span></span><br><span class="line"><span class="function">  <span class="comment">//  START_FLAG_REDELIVERY：表示该方法返回值为START_REDELIVER_INTENT，在上个服务被杀死之前调用stopSelf()停止服务</span></span></span><br><span class="line"><span class="function">  <span class="comment">//  START_FLAG_RETRY：在onStartCommand()被调用后一直无返回值时，会尝试重新调用onStartCommand()</span></span></span><br><span class="line"><span class="function">  <span class="comment">//3.当前服务id</span></span></span><br></pre></td></tr></table></figure><p>其中<code>onStartCommand()</code>方法的返回值意义如下：</p><p><code>START_STICKY</code>:service在内存不足被杀死后，内存空闲时系统会重新创建service，一旦成功创建会回调<code>onStartCommand()</code>方法，此时intent是null，除非是挂起的intent如pendingintent，无限期运行</p><p><code>START_NOT_STICKY</code>：service因内存不足被杀死，内存再次空闲系统也不会再重新创建服务，最安全</p><p><code>START_REDELIVER_INTENT</code>：service因内存不足被杀死，会重建服务并传递给最后一个intent（最后一次调用<code>startService()</code> 时的intent），用于连续作业，如下载等</p><h2 id="Service绑定服务的三种方式"><a href="#Service绑定服务的三种方式" class="headerlink" title="Service绑定服务的三种方式"></a>Service绑定服务的三种方式</h2><h3 id="1-拓展Binder类"><a href="#1-拓展Binder类" class="headerlink" title="1.拓展Binder类"></a>1.拓展Binder类</h3><p><strong>要求客户端和服务在同一应用的同一进程内</strong>。客户端通过其访问service中的公共方法。</p><p>步骤如下：</p><ol><li>创建BindService服务端，在类中创建一个实现了IBinder接口的实力对象并提供公共方法给客户端使用</li><li>在onBind()回调方法返回此Binder实例</li><li>在客户端的onServiceConnected()方法接收Binder，使用提供的方法绑定服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//service服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">  LocalService mService;</span><br><span class="line">  <span class="keyword">private</span> LocalBinder binder = <span class="keyword">new</span> LocalBinder();</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binder;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//服务中公共方法，可以被客户端通过IBInder获取实例调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</span><br><span class="line">    <span class="function">LocalService <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ServiceConnection conn = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">      <span class="comment">//绑定服务时被调用，实现客户端和服务端交互（IBinder）</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span></span>&#123;</span><br><span class="line">        LocalService.LocalBinder binder = (LocalService.LocalBinder)service;<span class="comment">//获取服务端IBinder</span></span><br><span class="line">        mService = binder.getService();<span class="comment">//获取服务实例，以调用服务的公共方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//取消绑定时回调，多数时候是service被意外销毁，如内存不足</span></span><br><span class="line">      <span class="comment">//当客户端取消绑定时，系统“绝对不会”调用该方法。</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span></span>&#123;</span><br><span class="line">        mService = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//创建绑定对象</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,LocalService.class);</span><br><span class="line">    <span class="comment">//绑定服务</span></span><br><span class="line">    <span class="comment">//参数3 flags则是指定绑定时是否自动创建Service。0代表不自动创建、BIND_AUTO_CREATE则代表自动创建</span></span><br><span class="line">    bindService(intent,conn,Service.BIND_AUTO_CREATE);</span><br><span class="line">    <span class="comment">//调用服务中的方法，最好先判断是否为null</span></span><br><span class="line">    mService.doSomeThing();</span><br><span class="line">    <span class="comment">//解除绑定</span></span><br><span class="line">    unbindService(conn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Messenger"><a href="#2-Messenger" class="headerlink" title="2.Messenger"></a>2.Messenger</h3><p><strong>service与不同进程通信（IPC）</strong> 。</p><p>步骤如下：</p><ol><li>Service实现一个Handler，接收客户端每个调用的回调</li><li>用Handler创建Messenger对象</li><li>用Messenger创建IBinder对象，并通过onBind()返回客户端</li><li>客户端使用IBinder实例化Messenger，用其将Message对象发送给Service</li><li>Service在Handler接收并处理Message</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MSG_WHAT = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//创建Handler接收、处理客户端msg</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">IncomingHanler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">      <span class="comment">//do sth with msg...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Messenger messenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> IncomingHanlder());</span><br><span class="line">  <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> messenger.getBinder();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="comment">//onCreate()方法中：</span></span><br><span class="line">mConnection = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span></span>&#123;</span><br><span class="line">    Messenger mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//给服务发消息</span></span><br><span class="line">Message msg = Message.obtain(<span class="keyword">null</span>,MessengerService.MSG_WHAT,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">mService.send(msg);</span><br></pre></td></tr></table></figure><p>注意service要在不同的进程中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AndroidMinafast.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".messenger.MessengerService"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">":remote"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务与客户端双向通信</strong></p><p>服务端，修改IncomingHandler，回复客户端消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncomingHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//回复消息</span></span><br><span class="line">    Messenger client = msg.replyTo;</span><br><span class="line">    Message replyMsg = Message.obtain(<span class="keyword">null</span>,MessengerService.MSG_WHAT);</span><br><span class="line">    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">    bundle.putString(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line">    replyMsg.setData(bundle);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      client.send(replyMsg);</span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端，增加Messenger和Handler处理服务端回复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerReplyMsgHandler</span> <span class="keyword">extends</span> <span class="title">Hanlder</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收服务端返回的msg</span></span><br><span class="line">  <span class="comment">//do sth ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Messenger mRecevierReplyMsg = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> RecyclerReplyMsgHandler());</span><br></pre></td></tr></table></figure><p>此外，在发送消息是需要将接收服务端回复的Messenger通过Message的replyTo传递给服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create msg...</span></span><br><span class="line">msg.replyTo = mRecevierReplyMsg;</span><br><span class="line"><span class="comment">//send msg...</span></span><br></pre></td></tr></table></figure><h3 id="3-AIDL"><a href="#3-AIDL" class="headerlink" title="3.AIDL"></a>3.AIDL</h3><p>一般不会使用，具体使用可以参考<a href="https://jixiaoyong.github.io/blog/posts/f931e8ae/">这篇文章</a></p><h1 id="绑定服务时的注意事项"><a href="#绑定服务时的注意事项" class="headerlink" title="绑定服务时的注意事项"></a>绑定服务时的注意事项</h1><ul><li>多个客户端可连接一个服务端，只有第一个客户端绑定时才会调用服务<code>onBind()</code>方法来检索IBinder，此后无需调用就可将同一个IBinder传递给其他客户端</li><li><code>bindService()</code> 绑定服务是异步进行的</li><li>一般在activity可见生命周期内绑定-取消服务，不要在<code>onResume()</code>、<code>onPause()</code>期间执行绑定/解绑</li></ul><h1 id="Service绑定和启动转换"><a href="#Service绑定和启动转换" class="headerlink" title="Service绑定和启动转换"></a>Service绑定和启动转换</h1><table><thead><tr><th>顺序</th><th>结果</th></tr></thead><tbody><tr><td>先绑定后启动service</td><td>启动service</td></tr><tr><td>先启动后绑定service</td><td>会绑定宿主，但是宿主死后仍按照启动service方式存活</td></tr></tbody></table><h1 id="前台服务和通知"><a href="#前台服务和通知" class="headerlink" title="前台服务和通知"></a>前台服务和通知</h1><blockquote><ul><li><strong>startForeground(int id, Notification notification)</strong><br>该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。</li><li><strong>stopForeground(boolean removeNotification)</strong><br>该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true为删除。 注意该方法并不会停止服务。 但是，如果在服务正在前台运行时将其停止，则通知也会被删除。</li></ul></blockquote><p>文章参考：</p><p><a href="http://blog.csdn.net/javazejian/article/details/52709857#t3" target="_blank" rel="noopener">关于Android Service真正的完全详解，你需要知道的一切 - CSDN博客</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/AndroidService相关知识.md</div>"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>之前发布的几个App</title>
      <link href="/blog/posts/1a589649/"/>
      <url>/blog/posts/1a589649/</url>
      
        <content type="html"><![CDATA[<p>在之前学习android的过程中，跟着教程做了几个app，虽然随着使用的api的失效，大多数应用如今已经不能正常使用了，但是作为初入编程的一点点小纪念，还是为他们写一个索引文章，至少能够晚一些消寂于这广阔的数据海洋中。</p><h1 id="NiceNews"><a href="#NiceNews" class="headerlink" title="NiceNews"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/05/NiceNews/">NiceNews</a></h1><p>Posted on 2016-05-30</p><p>NieceNews我制作的第二款APP，一个实时新闻软件。</p><p><img src="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/05/NiceNews/images/icon.png" alt="NiceNews"></p><h1 id="IWeather"><a href="#IWeather" class="headerlink" title="IWeather"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/IWeather/">IWeather</a></h1><p>Posted on 2016-07-16</p><p>IWeather，我的第三个Android应用，一个天气预报APP。</p><p><img src="http://jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/IWeather/images/1.png" alt="IWeather"></p><h1 id="2048"><a href="#2048" class="headerlink" title="2048"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/2048/">2048</a></h1><p>Posted on 2016-07-21</p><p>2048，我的第四个Android应用，同时也是我的第一款游戏APP。</p><p><img src="http://jixiaoyong.github.io/blogbackup/blog_2016To2017/2016/07/2048/images/1.png" alt="2048"></p><h1 id="I看知乎"><a href="#I看知乎" class="headerlink" title="I看知乎"></a><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/I%E7%9C%8B%E7%9F%A5%E4%B9%8E/">I看知乎</a></h1><p>Posted on 2016-07-24   | </p><p>i看知乎，我的第五个Android应用。</p><p><img src="http://jixiaoyong.github.io/blog/backup/blog_2016To2017/2016/07/I%E7%9C%8B%E7%9F%A5%E4%B9%8E/images/1.png" alt="logo"></p><p>学习的过程需要不断的重复，更需要有条理的总结，我会把平时学习的心得体会，经验，以及无聊时瞎琢磨得出来的稀奇古怪的想法放到这里，主要是为了自己能够在学习的过程中有计划的总结学习到的知识，同时也方便之后查阅。</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/之前发布的几个App.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android控件组</title>
      <link href="/blog/posts/3b69424a/"/>
      <url>/blog/posts/3b69424a/</url>
      
        <content type="html"><![CDATA[<p>这几天的工作中用到了控件组来实现复杂布局，效果不错，记录下来备用。</p><h1 id="1-定义控件组布局xxx-layout-xml"><a href="#1-定义控件组布局xxx-layout-xml" class="headerlink" title="1. 定义控件组布局xxx_layout.xml"></a>1. 定义控件组布局xxx_layout.xml</h1><p>在这里定义要使用的控件组布局，这里的布局决定了布局显示的样子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">"10dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-新建自定义属性文件attr-xml（可选）"><a href="#2-新建自定义属性文件attr-xml（可选）" class="headerlink" title="2.新建自定义属性文件attr.xml（可选）"></a>2.新建自定义属性文件attr.xml（可选）</h1><ul><li><p>在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- MSearchBar表明是给该控件使用的自定义属性 --&gt;</span><br><span class="line">    &lt;declare-styleable name=&quot;MSearchBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 以下为示例，可以根据需求增减 --&gt;</span><br><span class="line">        &lt;attr name=&quot;textColor&quot; format=&quot;color&quot; /&gt;</span><br><span class="line">        &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p></li><li><p>在该自定义控件的类xxx.java中，通过如下语句获取从用户使用时赋给这些属性的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar);</span><br><span class="line"><span class="keyword">float</span> textSize = array.getDimension(R.styleable.MSearchBar_textSize, <span class="number">13</span>);</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>用户动态给这些属性赋值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:textColor</span>=<span class="string">"@color/colorPrimaryDark"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，这里写的是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ​</span><br><span class="line"></span><br><span class="line"># 3. 新建组合控件的类XXX.java</span><br><span class="line"></span><br><span class="line">* 新建XXX.java，继承自布局文件的父布局LinearLayout</span><br><span class="line"></span><br><span class="line">* 更改参数少的构造方法的```super(a1,a2,a3)```为```this(a1,a2,a3)```，其中```this()```中的参数个数为参数最多的构造方法的参数数。</span><br><span class="line"></span><br><span class="line">  **注意** ：一定要做这一步，否则在使用该自定义控件组时，新建该类的对象会提示出错</span><br><span class="line"></span><br><span class="line">* 在最终会被调用的构造方法里面将xml里面定义的布局加载进来：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  //注意三个参数：布局文件：R.layout.weight_group_layout, root：this,是否依附到root：true</span><br><span class="line">  //必须有前两个参数，否则控件的宽高等会有异常</span><br><span class="line">  View view = LayoutInflater.from(context).inflate(R.layout.weight_group_layout, this,true);</span><br></pre></td></tr></table></figure></p></li><li><p>使用自定义属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MSearchBar</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//do sth</span></span><br><span class="line">  </span><br><span class="line">        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar);</span><br><span class="line">        <span class="keyword">float</span> textSize = array.getDimension(R.styleable.MSearchBar_textSize, <span class="number">13</span>);</span><br><span class="line">        editText.setTextSize(textSize);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>给控件组内部控件添加点击事件监听：</p><ul><li><p>xxx.java 要实现点击事件监听接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSearchBar</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义接口，供使用xxx.java类时实现对监听事件的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImgLeftOnClickListener</span><span class="params">(OnImgClickListener listener)</span></span>&#123;</span><br><span class="line">    listenerL = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnImgClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> OnImgClickListener listenerL;</span><br></pre></td></tr></table></figure></li><li><p>对要监听点击事件的控件设置监听，并调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">//在构造方法等地方设置监听事件</span><br><span class="line">imageViewLeft.setOnClickListener(this);</span><br><span class="line"></span><br><span class="line">//在xxx.java中重写onClick()方法</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        switch (view.getId()) &#123;</span><br><span class="line">            //ImageLeft</span><br><span class="line">            case R.id.imageView:</span><br><span class="line">                if (listenerL != null) &#123;</span><br><span class="line">                    listenerL.onClick();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            //imageRight</span><br><span class="line">            case R.id.imageView2:</span><br><span class="line">                if (listenerR != null) &#123;</span><br><span class="line">                    listenerR.onClick();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></li></ul></li></ul><h1 id="4-使用自定义控件组xxx-java"><a href="#4-使用自定义控件组xxx-java" class="headerlink" title="4. 使用自定义控件组xxx.java"></a>4. 使用自定义控件组xxx.java</h1><ul><li><p>在布局文件main_activity.xml中添加该控件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/search_bar"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:textColor</span>=<span class="string">"@color/colorPrimaryDark"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">cf.android666.jixiaoyong.weightgroup.weight.MSearchBar</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>在java中使用该控件，设置监听事件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MSearchBar searchBar = (MSearchBar) findViewById(R.id.search_bar);</span><br><span class="line">searchBar.setImgLeftOnClickListener(<span class="keyword">new</span> MSearchBar.OnImgClickListener() &#123;</span><br><span class="line">        <span class="meta">@SuppressLint</span>(<span class="string">"WrongConstant"</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Click on Left"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="5-效果预览"><a href="#5-效果预览" class="headerlink" title="5.效果预览"></a>5.效果预览</h1><p><img src="http://upload-images.jianshu.io/upload_images/120748-48d0cbbf03ded7f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果预览"></p><h1 id="6-源码"><a href="#6-源码" class="headerlink" title="6.源码"></a>6.源码</h1><p>demo的github链接:<a href="https://github.com/jixiaoyong/my_application_on_deepin/tree/master/weightgroup" target="_blank" rel="noopener">github</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android控件组.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android自定义View实现联系人列表</title>
      <link href="/blog/posts/a2c96aac/"/>
      <url>/blog/posts/a2c96aac/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义的view"><a href="#自定义的view" class="headerlink" title="自定义的view"></a>自定义的view</h1><ul><li>LetterIndex.java extends View</li><li>ContactsListView.java extends RecyclerView<br>#分析</li><li>联系人列表有两个要点<ul><li>字母导航栏<br>通过自定义View画出26个字母，设置滑动监听事件，根据上下滑动的距离判断当前选中的字母，并相应更新界面。</li><li>列表中的字母标题<br>针对item中的联系人姓名首字母对应的tag作比较，若与前一个相同则不显示title，否则显示。</li></ul></li><li>事件联动<ul><li>当滑动字母导航栏时，除了处理本身的变化外，还要留出接口，以便其他控件获取当前选中的字母。</li><li>联系人列表滑动时，除了处理本身变化外，同样要留出接口以便获取当前置顶的item对应的字母</li><li>字母导航栏要留出方法，以便其他控件指定选中的字母，并更新界面<h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><strong>ContactsListView.java</strong><br>重写该类主要是为了实现ItemDecoration根据不同的item变化，同时可以从xml布局文件中获取ItemDecoration的自定义属性。<br>主要代码：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ContactsListView(Context context) &#123;</span><br><span class="line">    this(context, null, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ContactsListView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ContactsListView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">    super(context, attrs, defStyle);</span><br><span class="line">    mTypeArray = context.obtainStyledAttributes(attrs, R.styleable.MyRecyclerDecoration);</span><br><span class="line">    mContext = context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故而在其内部自定义了一个继承自ItemDecoratio得静态内部类Decorationn类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public Decoration(List&lt;String&gt; data)&#123;</span><br><span class="line">//获取要显示的联系人数据对应的英文tag集合</span><br><span class="line">//初始化各种自定义属性</span><br><span class="line">//例如颜色：mColorLetterText = mTypeArray.getColor(R.styleable.MyRecyclerDecoration_color_letter_text, 0xff152648);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">        public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state)&#123;</span><br><span class="line">//画出各个导航title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">        public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">//画出置顶的导航title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State</span><br><span class="line">                state) &#123;</span><br><span class="line">//判断是否画出导航title</span><br><span class="line"> super.getItemOffsets(outRect, view, parent, state);</span><br><span class="line">            int position = ((RecyclerView.LayoutParams) (view.getLayoutParams())).getViewAdapterPosition();</span><br><span class="line"></span><br><span class="line">            if (position != -1) &#123;</span><br><span class="line">                String text = mDatas.get(position).substring(0, 1).toUpperCase();</span><br><span class="line">                if (position == 0) &#123;</span><br><span class="line">                    outRect.set(0, mTitleHeight, 0, 0);</span><br><span class="line">                &#125; else if (text != null &amp;&amp; !text.equals(mDatas.get(position - 1).substring(0, 1).toUpperCase())) &#123;</span><br><span class="line">                    outRect.set(0, mTitleHeight, 0, 0);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    outRect.set(0, 0, 0, 0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawText(Canvas canvas, float left, float right, View child, String text) &#123;</span><br><span class="line">//画出文字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LetterIndex.java</strong><br>该类用来画出字母导航栏，并且提供方法获取/设置当前选中的字母</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface onIndexClickListener &#123;</span><br><span class="line">       void onIndexClick(int chooseId);</span><br><span class="line">       void onActionUp();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setOnIndexClickListener(onIndexClickListener listener) &#123;</span><br><span class="line">       this.mClickListener = listener;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void setChooseId(int chooseId) &#123;</span><br><span class="line">       if (chooseId &gt;= 0 &amp;&amp; chooseId &lt; mIndexTexts.length) &#123;</span><br><span class="line">           mChooseId = chooseId;</span><br><span class="line">           invalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后重写<code>onTouchEvent(MotionEvent event)</code>方法，在ACTION_DOWN、ACTION_MOVE、ACTION_UP时调用对应的方法即可。</p><p>重写onDraw()方法，画出对应的界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">     super.onDraw(canvas);</span><br><span class="line">     int height = getHeight() - getPaddingTop() - getPaddingBottom();</span><br><span class="line">     float width = getWidth();</span><br><span class="line">     //childHeight 是每一个字母所在单元的高度</span><br><span class="line">     float childHeight = (float) height / mIndexTexts.length;</span><br><span class="line"></span><br><span class="line">     //如果被点击了，就画出背景</span><br><span class="line">     if (isClick) &#123;</span><br><span class="line">         mPaint.setColor(mColorIndexBg);</span><br><span class="line">         canvas.drawRect(0, 0, width, height, mPaint);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Rect bounds = new Rect();</span><br><span class="line">     mPaint.setTextSize(mSizeText);</span><br><span class="line">     mPaint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">     for (int i = 0; i &lt; mIndexTexts.length; i++) &#123;</span><br><span class="line">         String text = mIndexTexts[i];</span><br><span class="line">         mPaint.setColor(mColorText);</span><br><span class="line">         //在被选中的字后面画一个圆，并改变字的颜色</span><br><span class="line">         if (i == mChooseId) &#123;</span><br><span class="line">             mPaint.setColor(mColorChooseTextBg);</span><br><span class="line">             canvas.drawCircle(width / 2, childHeight / 2 + i * childHeight,</span><br><span class="line">                     mSizeText / 2 + 2, mPaint);</span><br><span class="line">             mPaint.setColor(mColorChooseText);</span><br><span class="line">         &#125;</span><br><span class="line">         mPaint.getTextBounds(text, 0, text.length(), bounds);</span><br><span class="line">         //bounds里面保存着要画的字的一些属性，如x，y，centerX，centerY等，</span><br><span class="line">         //要注意 canvas.drawText（text,x,y,mpaint）中y并不是text的最低端，而是baseline。</span><br><span class="line">         float x = width / 2;</span><br><span class="line">         float y = -bounds.centerY() + childHeight / 2 + i * childHeight;</span><br><span class="line">         canvas.drawText(text, x, y, mPaint);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源代码在我的Github，<a href="https://github.com/jixiaoyong/my_application_on_deepin/tree/master/contactsdemo/src/main" target="_blank" rel="noopener">点这里</a>可以找到。</p><h1 id="预览如下"><a href="#预览如下" class="headerlink" title="预览如下"></a>预览如下</h1><p><img src="http://upload-images.jianshu.io/upload_images/120748-183eea3cad2b42ac.gif?imageMogr2/auto-orient/strip" alt="预览.gif"></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android自定义View实现联系人列表.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android开发常用设置</title>
      <link href="/blog/posts/1c56d6b9/"/>
      <url>/blog/posts/1c56d6b9/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h1><ul><li>国内较快的仓库：</li></ul><pre><code>maven {url&apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;}</code></pre><ul><li>RecyclerView添加依赖<br>注意RecyclerView的版本号要和当前工程中其他android.support包版本保持一致，否则虽然导入了对应的包，但是仍然无法正常使用。</li></ul><pre><code>compile &apos;com.android.support:recyclerview-v7:26+&apos;</code></pre><ul><li>设置：<br>自动添加依赖：insert imports on paste: None<br>自动删除无用依赖：Optimize imports on the fly</li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul><li>设置ndk环境变量 /etc/profile</li></ul><pre><code>#set ndk envNDKROOT=/home/jixiaoyong/AndroidDev/Sdk/ndk-bundleexport PATH=$NDKROOT:$PATH</code></pre><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Android-开发常用设置.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中三种常用的排序方法</title>
      <link href="/blog/posts/1fd30f6e/"/>
      <url>/blog/posts/1fd30f6e/</url>
      
        <content type="html"><![CDATA[<p>今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。<br>以下示例皆为从小到大的排序</p><h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h1><p>每一次比较都可能要交换元素。<br>冒泡排序的思想是：<br>每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为m）放到后面，并将m与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。<br>在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。<br>依次类推，总共遍历n-1轮，即可完成排序。<br>具体代码如下：</p><pre><code> void bubble(int[] arr){    int temp;    for (int i = 0; i &lt; arr.length - 1; i++) {        for (int j = 0; j &lt; arr.length - i - 1; j++) {            if (arr[j] &gt; arr[j + 1]) {                temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            }        }    }    System.out.println(&quot;\n--bubble :&quot;);    for (int i = 0; i &lt; arr.length; i++) {        System.out.print(arr[i] + &quot; &quot;);    }}</code></pre><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h1><p>每次比较的时候不交换<br>选择排序的思想：<br>每次比较的时候找到的两个数中的较大值并记下其位置，等到当前一轮的遍历完成之后，将最后一个未排序元素与这一轮遍历找到的最大值交换<br>最多交换n-1次<br>代码如下：</p><pre><code>   void select(int[] arr){    for (int i = 0; i &lt; arr.length; i++) {        int maxIndex = 0;        int temp = 0;        for (int j = 1; j &lt; arr.length - i; j++) {            if (arr[maxIndex] &lt; arr[j]) {                maxIndex = j;            }        }        temp = arr[maxIndex];        arr[maxIndex] = arr[arr.length - i - 1];        arr[arr.length - i - 1] = temp;    }    System.out.println(&quot;\n--select :&quot;);    for (int i = 0; i &lt; arr.length; i++) {        System.out.print(arr[i] + &quot; &quot;);    }}</code></pre><h1 id="3-插入排序法"><a href="#3-插入排序法" class="headerlink" title="3.插入排序法"></a>3.插入排序法</h1><p>插入排序法思想：<br>将待排序的元素分为有序和无序两种，刚开始排序的时候假设只有第一个元素是有序的，其余n-1个元素都是无序的；<br>排序开始的时，将无序部分的一个元素（a）与有序部分的最后一个元素（b）进行比较，如果a&lt;b，则将a与b交换，再将a与下一个有序元素进行比较；否则，将a加到b后面，作为有序部分的最后一个元素。<br>接着再从无序部分取出一个元素与有序部分的元素依次比较，直达所有元素都为有序元素。<br>遍历n-1次<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> instertValue = arr[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (instertValue &lt; arr[j]) &#123;</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = instertValue;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第二种表示形式</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">int instertVal = arr[i];</span></span><br><span class="line"><span class="comment">int index = i - 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while (index &gt;= 0 &amp;&amp; instertVal &lt; arr[index]) &#123;</span></span><br><span class="line"><span class="comment">arr[index + 1] = arr[index];</span></span><br><span class="line"><span class="comment">index--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">arr[index + 1] = instertVal;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n--insertSort :"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Java中三种常用的排序方法.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下配置Git，使用AndroidStudio同步工程到Github</title>
      <link href="/blog/posts/25db0a11/"/>
      <url>/blog/posts/25db0a11/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍了如何在 linux 环境下安装和配置 git 与 github ，并且使用 Android Studio 将本地的项目同步到 github 上面。</p><h1 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-gat install git</span><br></pre></td></tr></table></figure><h1 id="配置-git-和-github"><a href="#配置-git-和-github" class="headerlink" title="配置 git 和 github"></a>配置 git 和 github</h1><ul><li><p>创建 Github 账号</p></li><li><p>生成 ssh key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@youremail.com</span><br></pre></td></tr></table></figure></li><li><p>在 github 上面添加 ssh key</p></li></ul><p>进入 Account Settings –&gt; SSH Keys –&gt; Add SSH Key 添加 SSH Keys ：<br>名字起一个容易识别的名字，key 是生成的 <code>/home/username/.ssh/id_rsa.pub.</code> 中的内容，直接粘贴到指定位置就行</p><ul><li><p>测试 ssh key 是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul><p>提示如<code>You’ve successfully authenticated, but GitHub does not provide shell access</code>则说明成功连接 github</p><ul><li><p>配置 Github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot; //配置用户名</span><br><span class="line">git config --global user.email &quot;your email&quot; //配置email</span><br></pre></td></tr></table></figure></li></ul><h1 id="用-Android-Studio-同步工程到-Github"><a href="#用-Android-Studio-同步工程到-Github" class="headerlink" title="用 Android Studio 同步工程到 Github"></a>用 Android Studio 同步工程到 Github</h1><ul><li><p>启动android studio</p><p>进入<code>android studio/bin</code>，终端输入<code>./studio.sh</code></p></li><li><p>选择 <code>VCS ---&gt; Import into Version Control --&gt; Share Project on Github</code></p></li></ul><p>第一次进入会要求输入 github 的账号和密码 按照要求输入即可<br>此后还会要求你输入一个本地密码，当下次同步的时候需要输入<br>之后就进入到选择同步的仓库，新建一个仓库，开始同步就可以了</p><p><strong>到这里就顺利的在 Android Studio 上面将工程同步到 Github 上面了</strong></p><hr><p><strong>以下为原文提到的其他方法，摘录如下，以备后用：</strong></p><h1 id="利用Git从本地上传到GitHub"><a href="#利用Git从本地上传到GitHub" class="headerlink" title="利用Git从本地上传到GitHub"></a>利用Git从本地上传到GitHub</h1><p>第一步： 进入要所要上传文件的目录</p><p>输入命令 <code>git init</code></p><p>第二步： 创建一个本地仓库 origin</p><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:yourName/yourRepo.git</span><br></pre></td></tr></table></figure><p><code>youname</code>是你的GitHub的用户名，<code>yourRepo</code>是你要上传到GitHub的仓库</p><p>第三步： 比如你要添加一个文件xxx到本地仓库，使用命令 <code>git add xxx</code>，可以使用 <code>git add .</code> 自动判断添加哪些文件</p><p>然后把这个添加提交到本地的仓库，使用命令 <code>git commit -m</code>说明这次的提交</p><p>最后把本地仓库origin提交到远程的GitHub仓库，使用命令 <code>git push origin master</code></p><h1 id="从GitHub克隆项目到本地"><a href="#从GitHub克隆项目到本地" class="headerlink" title="从GitHub克隆项目到本地"></a>从GitHub克隆项目到本地</h1><p>第一步： 到GitHub的某个仓库，然后复制右边的有个<code>HTTPS clone url</code></p><p>第二步： 回到要存放的目录下，使用命令 <code>git clone https://github.com/chenguolin/scrapy.git</code>，这里的url只是一个例子</p><p>第三步： 如果本地的版本不是最新的，可以使用命令 <code>git fetch origin</code>，origin是本地仓库</p><p>第四步： 把更新的内容合并到本地分支，可以使用命令 <code>git merge origin/master</code></p><p>如果你不想手动去合并，那么你可以使用：<br><code>git pull &lt;本地仓库&gt; master</code> // 这个命令可以拉去最新版本并自动合并</p><h1 id="GitHub的分支管理"><a href="#GitHub的分支管理" class="headerlink" title="GitHub的分支管理"></a>GitHub的分支管理</h1><ul><li>创建</li></ul><p>1 创建一个本地分支： <code>git branch &lt;新分支名字&gt;</code></p><p>2 将本地分支同步到GitHub上面： <code>git push &lt;本地仓库名&gt; &lt;新分支名&gt;</code></p><p>3 切换到新建立的分支： <code>git checkout &lt;新分支名&gt;</code></p><p>4 为你的分支加入一个新的远程端： <code>git remote add &lt;远程端名字&gt; &lt;地址&gt;</code></p><p>5 查看当前仓库有几个分支: <code>git branch</code></p><ul><li>删除</li></ul><p>1 从本地删除一个分支： <code>git branch -d &lt;分支名称&gt;</code></p><p>2 同步到GitHub上面删除这个分支： <code>git push &lt;本地仓库名&gt; :&lt;GitHub端分支&gt;</code></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这篇文章是我今天在 linux 下安装 git ，上传工程到 github 上面时的步骤的总结，大部分内容都参考/摘录自下面这篇文章，感谢原作者的分享，原文信息及链接如下：</p><blockquote><p>Linux下Git和GitHub使用方法总结<br>[日期：2014-03-07] 来源：Linux社区 作者：chenguolin<br><a href="http://www.linuxidc.com/Linux/2014-03/97821.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-03/97821.htm</a></p></blockquote><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Linux下配置Git，使用AndroidStudio同步工程到Github.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下配置JDK和AndroidStudio开发环境</title>
      <link href="/blog/posts/ca532ade/"/>
      <url>/blog/posts/ca532ade/</url>
      
        <content type="html"><![CDATA[<h1 id="下载-JDK-并解压"><a href="#下载-JDK-并解压" class="headerlink" title="下载 JDK 并解压"></a>下载 JDK 并解压</h1><ul><li>到官网下载 jdk</li><li>下载到的 JDK 文件解压</li></ul><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>管理员权限进入 etc/environment 写入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=&quot;JDK主目录的绝对路径&quot;</span><br></pre></td></tr></table></figure><h1 id="配置-alternatives"><a href="#配置-alternatives" class="headerlink" title="配置 alternatives"></a>配置 alternatives</h1><p>打开终端执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install  /usr/bin/java java  JDK主目录的绝对路径/bin/java 300</span><br><span class="line"></span><br><span class="line">sudo update-alternatives --install  /usr/bin/javac javac  JDK主目录的绝对路径/bin/javac 300</span><br></pre></td></tr></table></figure><p>到这里 JDK 的环境就配置好了</p><h1 id="运行-Android-Studio"><a href="#运行-Android-Studio" class="headerlink" title="运行 Android Studio"></a>运行 Android Studio</h1><p>进入 android studio/bin 目录下，打开终端，</p><p>输入 <code>./studio.sh</code></p><p>到这里，就可以正常运行 android studio 了</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/Linux下配置JDK和AndroidStudio开发环境.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AppWidget的使用之PendingIntent</title>
      <link href="/blog/posts/fcfc830b/"/>
      <url>/blog/posts/fcfc830b/</url>
      
        <content type="html"><![CDATA[<p>这几天学习 AppWidget ，很简单的组件却花费了不少功夫，今天对 PendingIntent 的用法做了一些简单的整理。</p><p><strong>PendingIntent</strong></p><blockquote><p>PandingIntent 就像是一个设计好的处理预案，当达到某个特定条件时，便会调用该 Intent 所指定动作（打开服务，Activity或者发送广播）。</p><p>这里使用该方法在 AppWidget 里面为按钮添加监听事件，当按钮被点击的时候触发相应的动作</p></blockquote><p>AppWidget 和应用程序不再同一个进程当中，而是在 HomeScreen 上面执行,所以不能直接为 AppWidget 中的 Button 添加监听事件，需要用 <code>remoteViews.setPendingIntent(R.id.widget_button,pendingIntent);</code>意思是当按下按钮的时候 pendingIntent 中的 Intent 就会执行</p><p>PendingIntent 当某个事件出现之后才会执行</p><p>RemoteViews对象 代表了一系列的 View 对象，和主程序不在同一个进程为 AppWidget 控件绑定处理器</p><p><strong>流程概述：</strong></p><ul><li><p>添加 appwidget_provider_info.xml 在 res/xml 下新建 appwidget_provider_info.xml</p><ul><li>描述 AppWidget 的基本信息如最小高度、宽度等，还有就是该挂件的布局文件</li></ul></li><li><p>在 res/layout 下面为该挂件设置具体的布局样式</p><ul><li>向 AppWidget 的布局文件中添加一个 Button</li><li>向 AppWidget 的布局文件中添加一个 TextView</li></ul></li><li><p>新建 MyAppWidget.java 继承自 AppWidgetProvider</p><p>在该类的 onUpdate() 方法中为 Button 设置、添加监听事件</p><ul><li>建立一个 Intent 对象</li><li>用该 Intent 对象创建一个 PendingIntent 对象</li><li>创建一个 RemoteViews 对象</li><li>用该 RemoveViews 对象为 按钮绑定事件处理器</li><li>更新按钮</li></ul></li><li><p>注册事件</p></li><li><p>备注：要是为 AppWidget 中的 Button 设置的事件是打开一个 TargetActivity ，还需要添加一个 TargetActivity 类和对应的布局文件</p></li></ul><p><strong>以下是代码</strong></p><ul><li>appwidget_provider_info.xml</li></ul><p>这个布局文件是 AppWidget 的信息</p><p>描述了 AppWidget 的最小高，最小宽以及它的布局文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;appwidget-provider</span><br><span class="line">    android:minHeight=&quot;200dp&quot;</span><br><span class="line">    android:minWidth=&quot;300dp&quot;</span><br><span class="line">    android:initialLayout=&quot;@layout/app_widget&quot;</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">&lt;/appwidget-provider&gt;</span><br></pre></td></tr></table></figure><ul><li>app_widget.xml</li></ul><p>这个布局文件是 Widget 在桌面上显示的样式</p><p>定义了 AppWidget 中各个组件及其样式</p><p>其中 Button 用来响应点击事件，加入 TargetActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;200dp&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;hello,world!&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">        android:id=&quot;@+id/app_widget_btn&quot;</span><br><span class="line">        android:layout_width=&quot;200dp&quot;</span><br><span class="line">        android:layout_height=&quot;150dp&quot;</span><br><span class="line">        android:background=&quot;#ff00ff&quot;</span><br><span class="line">        android:text=&quot;this is my app widget button&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><ul><li>target_activity.xml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:textSize=&quot;50sp&quot;</span><br><span class="line">        android:background=&quot;#00ff00&quot;</span><br><span class="line">        android:text=&quot;\n hello,welcome to target activity!&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><ul><li>MyAppWidget.java</li></ul><p>主要是修改了 update() 方法：</p><p>定义了一个预先设定的动作—- Intent 对象；</p><p>利用该 Intent 读写，创建一个 PendingIntent 对象；</p><p>创建一个 RemoteView 对象，并为按钮绑定监听事件</p><p>刷新 AppWidget。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class MyAppWidget extends AppWidgetProvider &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onReceive(context, intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onUpdate(Context context, AppWidgetManager appWidgetManager,</span><br><span class="line">                         int[] appWidgetIds) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onUpdate(context, appWidgetManager, appWidgetIds);</span><br><span class="line"></span><br><span class="line">        //appWidgetIds 每一次向屏幕添加 AppWidget 的时候都会增加一个唯一的 appWidget 的 Id</span><br><span class="line">        for(int i = 0; i &lt; appWidgetIds.length;i++)&#123;</span><br><span class="line">          //创建一个 Intent 对象</span><br><span class="line">            Intent intent = new Intent(context,TargetActivity.class);</span><br><span class="line">            //创建一个 PendingIntent 对象</span><br><span class="line">            PendingIntent pendingIntent = PendingIntent.getActivity(context,0,intent,0);</span><br><span class="line">            // remoteViews 代表 AppWidget 上所有的控件</span><br><span class="line">            RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget);</span><br><span class="line">            //为按钮绑定事件处理器</span><br><span class="line">            /*</span><br><span class="line">            * 参1，指定被绑定处理器的控件id</span><br><span class="line">            * 参2，指定事件发生时会被执行的 PendingIntent</span><br><span class="line">             */</span><br><span class="line">            remoteViews.setOnClickPendingIntent(R.id.app_widget_btn,pendingIntent);</span><br><span class="line">            //更新 AppWidget ，参1是用于指定被更新 appWidget 的ID</span><br><span class="line">            appWidgetManager.updateAppWidget(appWidgetIds[i],remoteViews);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDeleted(Context context, int[] appWidgetIds) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onDeleted(context, appWidgetIds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onEnabled(Context context) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onEnabled(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDisabled(Context context) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        super.onDisabled(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TargetActivity.java</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TargetActivity extends Activity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.target_activity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AndroidManifest.xml</li></ul><p>在 AndroidManifest.xml 中注册 TargetActivity 和 MyAppWidget</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".TargetActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里注册了一个 MyAppWidget 接收数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyAppWidget"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.appwidget.action.APPWIDGET_UPDATE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.appwidget.provider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:resource</span>=<span class="string">"@xml/appwidget_provider_info"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/AppWidget的使用之PendingIntent.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github=Blog</title>
      <link href="/blog/posts/f7965978/"/>
      <url>/blog/posts/f7965978/</url>
      
        <content type="html"><![CDATA[<p><code>Hello World！</code></p><p>一直以来，为了有一个合适的在线写字的地方，我尝试过许多种工具，从最初的 QQ 空间开始，到各种门户网站的博客，再到自己开始尝试搭建博客，一路奔忙，门户网站的限制太多，自己搭建的博客又时常由于空间提供商的各种问题而无法访问。许多时候一个平台只能使用一段时间，这样子颠颠撞撞大概也有五六年的时间了。</p><p>一直听说 github 这个平台的各种优点，尤其是可以作为稳定而免费的空间托管博客最令我心动，但是之前多次尝试不得其道，终以失败告终。最近在学习 Android 语言的时候，又再次用起了 github ，不过这次是用它来存储代码。不得不承认，使用 github 来控制程序版本真是一件令人愉悦的事件。</p><p>机缘巧合，因为需要将学习过程中的一些笔记，心得总结找个地方整理，显然单纯的使用 github 并不是一个好办法，而其他的平台的博客限制又太多，于是又尝试用 github 搭建一个博客，虽然对这些知识并不是很熟悉，但误打误撞竟然也成功的搭建好了博客。下面就把整个建站的过程大概梳理一下，以便以后查看。</p><h1 id="准备软件"><a href="#准备软件" class="headerlink" title="准备软件"></a>准备软件</h1><ul><li>下载软件：</li><li>node 客户端</li><li>git</li><li>github windows 客户端</li></ul><h1 id="装-git-和-github-windows-客户端"><a href="#装-git-和-github-windows-客户端" class="headerlink" title="装 git 和 github windows 客户端"></a>装 git 和 github windows 客户端</h1><ul><li>安装 git:<br>git 安装时按照默认的配置，一路点击确定就可以。</li><li>安装 github<br>github 安装分为两种：<br>一种是直接用官网的安装包，在安装的时候需要从网上下载资料，受网速限制，这种方法很慢，而且容易出错；<br>另一种直接找一份github离线安装包解压到本地即可使用，我就是使用后一种方法。</li></ul><h1 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h1><ul><li>安装 node 客户端<br>下载并安装 node ,我使用的版本是 node-v5.7.1-x64。</li></ul><p>在安装完 git, node 之后</p><ul><li>win 键 + R 输入cmd 打开 windows 自带命令行，<br>输入git /npm<br>之后，如果显示出帮助信息而非不是内部或外部命令，也不是可运行的程序或批处理文件这样的提示，就说明 git 和 node 已经配置好了环境变量，否则就需要手动配置。</li></ul><h1 id="配置环境变量方法："><a href="#配置环境变量方法：" class="headerlink" title="配置环境变量方法："></a>配置环境变量方法：</h1><ul><li>此电脑 –&gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量</li><li>找到用户环境变量 –&gt; path ，如下图<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/BaiduShurufa_2016-4-23_17-41-1.png"><img src="http://upload-images.jianshu.io/upload_images/120748-8aae916f0dfa3dd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改用户环境变量前"></a></li></ul><p>如下图修改<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/BaiduShurufa_2016-4-23_17-41-44.png"><img src="http://upload-images.jianshu.io/upload_images/120748-aa40a7e6049eeecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改系统环境变量后"></a></p><p>这样子 node 应该就可以正常使用了。</p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>打开命令行，全局安装 Hexo ,加 -g 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>查看 hexo 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blockquotehexo-cli: 1.0.1os: Windows_NT 10.0.14316 win32 x64http_parser: 2.6.2node: 5.7.1v8: 4.6.85.31uv: 1.8.0zlib: 1.2.8ares: 1.10.1-DEVicu: 56.1modules: 47openssl: 1.0.2g</span><br></pre></td></tr></table></figure><p>到这里 hexo 就在电脑上面安装好了。</p><h1 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h1><ul><li>进入存放 hexo 文件的目录下，创建一个文件夹blog存储 hexo 的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>然后进入这个文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure><p>启动 hexo 服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop</span><br></pre></td></tr></table></figure><p>打开本地地址：<a href="http://localhost:4000/，就可以看到本地搭建好的" target="_blank" rel="noopener">http://localhost:4000/，就可以看到本地搭建好的</a> hexo 博客了<br>这样子一个 hexo 博客就在本地搭建好了</p><h1 id="目录的解释："><a href="#目录的解释：" class="headerlink" title="目录的解释："></a>目录的解释：</h1><p>scaffolds 脚手架，也就是一个工具模板 scripts 写文件的js，扩展hexo的功能<br>source 存放博客正文内容<br>source/_drafts 草稿箱<br>source/_posts 文件箱<br>themes 存放皮肤的目录<br>themes/landscape默认的皮肤<br>_config.yml 全局的配置文件<br>db.json 静态常量</p><h1 id="一些-hexo-语句解释"><a href="#一些-hexo-语句解释" class="headerlink" title="一些 hexo 语句解释"></a>一些 hexo 语句解释</h1><p>help 查看帮助信息<br>init 创建一个hexo项目<br>migrate 从其他系统向hexo迁移<br>version 查看hexo的版本<br>–config参数，指定配置文件，代替默认的_config.yml<br>–debug参数，调试模式，输出所有日志信息<br>–safe参数，安全模式，禁用所有的插件和脚本<br>–silent参数，无日志输出模式</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p>命名为“新的文章”，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 新的文章</span><br></pre></td></tr></table></figure><p>hexo 默认生成 md 文件，新生成的文章在目录：.\blog\source_posts\新的文章.md ，对其进行相应的编辑即可<br>文章格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: 新的文章date: 2014-05-07 18:44:12updated : 2014-05-10 18:44:12permalink: abctags:- 开始- 我- 日记categories:- 日志- 第一天---</span><br></pre></td></tr></table></figure><h1 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h1><ul><li>注册并登录 github<br>进入 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> ，注册新账户，并且登录</li><li>新建 respositoy<br>在主页点击 New respositoy 新建一个名字为yourname.github.io<br> 的 respositoy；<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/1461473623662.jpg"><img src="http://upload-images.jianshu.io/upload_images/120748-fbb8934ceb25f0d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建 respositoy"></a></li><li>设置新建一个 github pages<br>进入仓库主页，选择settings –&gt; github pages –&gt; Launch automatic page generator ,按照默认的主题配置选择一个就好<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/BaiduShurufa_2016-4-24_12-59-58.png"><img src="http://upload-images.jianshu.io/upload_images/120748-c6e9742ee6120d8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Launch automatic page generator"></a></li><li>上传网站<br>对于 hexo 的相关配置：<br>打开_config.yml，修改以下部分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sitetitle: 季小勇的博客</span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">author: 季小勇</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone:# URL</span><br><span class="line">#If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; </span><br><span class="line">and root as &apos;/child/&apos;</span><br><span class="line">url: http://yoursite.github.io/</span><br><span class="line">root: http://yoursite.github.io/blog/</span><br></pre></td></tr></table></figure><p>此处由于我是将网站放在二级目录 ./blog/ 下面，所以 root 目录设置如此，使用的是绝对路径，否则在网页上显示的时候，css 等由于路径不对，加载可能会有问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deploy: type: git repo:https://github.com/yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure><p>这行语句是使用 hexo 自动 deploy 到 github 时的设置，如果正常的话，当用 hexo 对网站静态化处理后，再执行 hexo deploy 就可以自动部署到 github 上面了，但是我的电脑 git 或者 node 由于是不同时间装的期间还重装了几次系统，可能导致某些设置有误，所以在执行 hexo deploy 的时候一直提示有问题，故而采用另一种办法手动同步网站，这句话也可以不修改。</p><ul><li><p>用 hexo 对文章进行静态化处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li></ul><p>在blog\public目录下生成的 public 包含所有的静态化文件,此时，这个文件夹内所有的内容就是处理好的网站，将其发布到合适的空间就可以正常显示。<br>由于之前的 git 或者 node 配置有误，所以这时候采用手动同步网站:</p><ul><li>将上次在 github 上建立的项目yourname.github.io<br>同步到本地。<br>同步的方法很多，这里我选择的是使用 github 的 windows 客户端，比较方便：</li></ul><p>打开 github 客户端，找到项目，选择clone到本地即可。<br><img src="http://upload-images.jianshu.io/upload_images/120748-9100b83bb7ebf3b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步项目到本地"></p><p>之后打开同步的项目，确认当前的branch是master，否则同步之后网站不会显示。<br><a href="http://jixiaoyong.github.io/jixiaoyong.github.io/blog/2016/04/%E5%B0%8F%E7%99%BD%E7%AC%94%E8%AE%B0%EF%BC%9Agithub%20+%20hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/images/1461461275758.jpg"><img src="http://upload-images.jianshu.io/upload_images/120748-620f9db488c0c384.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确认是 master"></a></p><p>在 github 同步的目录下找到上次建好的项目yourname.github.io ,进入之后，将上文获得到的public内容放入目标文件夹，我选择的是将博客放在子目录，所以这里新建了一个blog文件夹用于放置博客，所以就是将public<br>全部内容 放入./yourname.github.io/blog/目录下，这样子在网站上显示的时候，博客的网址就是<a href="http://yourname.github.io/blog/" target="_blank" rel="noopener">http://yourname.github.io/blog/</a></p><p>这样一个简单的利用 github 托管的 hexo 博客就搭建好了。<br>注：本文内容是根据我建立博客时的做法整理而成，其中有部分内容是参考网上的教程，文中引用的文字全部来自<a href="http://blog.fens.me/hexo-bootstarp-github/" target="_blank" rel="noopener">http://blog.fens.me/hexo-bootstarp-github/</a> ，此文对我帮助很大，感谢作者张丹(Conan)的分享。</p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/利用Hexo和Github建立个人博客.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/posts/4a17b156/"/>
      <url>/blog/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><script src="https://jixiaoyong.github.io/js/edit_on_github.js"></script></p><iframe id="iframeid" scrolling="false" height="50" frameborder="no" border="0" marginwidth="0" marginheight="0" onload="Javascript:editOnGithub()" srcdoc="<div id=&quot;url&quot;>https://github.com/jixiaoyong/jixiaoyong.github.io/blob/hexo_blog/blog/source/_posts/HelloWorld.md</div>"></iframe>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
