<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python自动化部署文章]]></title>
    <url>%2Fblog%2F2018%2F01%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[python脚本实现一键自动新建文章，编译，预览，发布github. just test]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fblog%2F2018%2F01%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[update]Python爬取gityuan所有文章列表]]></title>
    <url>%2Fblog%2F2018%2F01%2Fupdate-Python%E7%88%AC%E5%8F%96gityuan%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简介更新内容： 爬取gityuan.com网站所有文章列表并输出json 汇总信息输出config.json为后面的客户端做准备 更新文件： spider_main.py html_output.py gityuan_urls.py html_downloader.py 代码 spider_main.py 作为入口类，主要增加了初始化所有URL，以及便利这些URL的功能。 12345678910sp = SpiderMain()gityuan = gityuan_urls.GitYuanUrls()gityuan_urls = gityuan.get_urls(17)file_name = 'gityuan_page_'sp.craw(gityuan_urls,file_name) 其craw()方法修改如下： 12345678910111213141516171819202122232425262728293031from time import sleepdef craw(self, root_urls, file_name): #将所有有效链接全部加入 self.urls.add_new_urls(root_urls) i = 0 #循环遍历这些链接 while self.urls.has_next(): i = i + 1 new_url = self.urls.get_new_url() html_cont = self.downloader.download(new_url) new_url, new_data = self.parser.parse(new_url, html_cont) self.output.collect_data(new_data) new_file_name = file_name + ('%d.json'%i) self.output.output_html(new_file_name) #等待3s，防止太频繁访问被识别 sleep(3) #结束遍历，输出汇总信息 self.output.end(file_name,root_urls[0],i) html_output.py 主要改动如下： output_html(self,file_name)方法增加一个file_name的参数，并在内部调用self.mkdir()方法生成output目录，方便同时输出多个文档 mkdir()方法，创建文件 end(self,file_name_start, url, num)方法，输出汇总文档，代码如下 1234567891011121314def end(self,file_name_start, url, num): self.mkdir() file_name = self.output_dir + 'config.json' file_out = open(file_name,'w') current_time = time.time() config_str = ('&#123;"url":"%s","total":"%d","update_time":"%d","file_name":"%s"&#125;' % (url,num,current_time,file_name_start)) file_out.write(config_str) gityuan_urls.py 主要代码如下，通过循环遍历获取所有文章列表信息 12345678910111213class GitYuanUrls(object): """docstring for GitYuanUrls""" def get_urls(self, num): urls = [] urls.append('http://www.gityuan.com') for x in xrange(1,num): url_ = ('http://www.gityuan.com/page%d/'%x) urls.append(url_) return urls html_downloader.py 就在本文编辑的过程中，爬虫被识别，并且限制访问文件数量，所以对下载功能做了简单的伪装、增加超时处理。 1234567891011121314151617181920def download2(self, url): #升级版 if url is None: return None #伪装为浏览器 req_header = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36'&#125; try: request = urllib2.Request(url,None,req_header) response = urllib2.urlopen(request,None,300) return response.read() except socket.timeout as e: #超时处理 print(type(e)) return None 结语当前爬虫主体功能以及实现，可以爬取gityuan.com所有有效文章列表，可以满足客户端需求。但仍然存在以下问题： 没有伪装，爬虫很容易被识别并被拒绝服务（就在刚刚写下这句话的时候，就发生了被限制访问，真*乌鸦嘴）。 由于原网站特性，其置顶文章每页都有，会导致部分数据重复。 未爬取具体文章内容。 说明 本文只为学术研究，其中涉及到的第三方网站及其所有资源均属原主所有。向gityuan大神致敬，欢迎访问其blog。 源码github链接 tag为gityuan_spider1.5]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫爬取gityuan.com数据并输出json]]></title>
    <url>%2Fblog%2F2018%2F01%2FPython%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96gityuan-com%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%BE%93%E5%87%BAjson%2F</url>
    <content type="text"><![CDATA[简介 本文基于Python2.7 这篇文章基于我在慕课网上面学习Python简单爬虫写的内容，教程内容是爬取1000条百度百科的数据，但是教程中爬虫截止2018-01-27已经失效，刚好看到大神gityuan.com的内容，于是用Python实现爬取其网页内容并生成json数据。 本文即上述过程整理。 本文涉及源代码已上传github（点这里查看）。 框架爬虫主要活动是： 爬取目标网页内容 对获取到的内容进行分析，获取有用数据 将处理好的数据按格式输出 此外还需要有一个专门管理爬虫活动的主类，故而文件结构如下： spider_main.py 入口类 url_manager.py 管理要下载的链接 html_downloader.py 下载网页内容 html_paeser.py 对获取到的数据进行解析、加工 html_out.py 输出格式化的数据 目前只实现了爬取gityuan.com第一页内容并输出json，所以暂时不需要实现url_manager.py 关键代码spider_main.py 12345678910111213141516171819202122232425#导入用到的各个类import html_downloader...#定义入口类class SpiderMain(object): def __init__(self): #初始化各个变量downloader、parser、output... self.downloader = html_downloader.HtmlDownloader() #略 def craw(self,root_url): html_cont = self.downloader.download(root_url) new_data = self.parser.parse(html_cont) self.output.collect_data(new_data) self.output.output_json() root_url = 'http://www.gityuan.com/'sp = SpiderMain()sp.craw(root_url) 在__init__() 方法初始化各个变量； 在craw()中分别实现下载、解析网页内容、输出加工数据 html_download.py 1234567891011121314import urllib2class HtmlDownLoader(object): def download(self,url): if url is None: return None respone = urllib2.urlopen(url,timeout=300) if respone.getcode() != 200: return None return respone.read() 下载并返回网页内容，比较简单 html_parser.py 12345678910111213141516171819202122232425262728293031323334353637import urlparsefrom bs4 import BeautifulSoup #第三方包，需要单独下载import reclass HtmlParser(object): def parse(self,html_cont): if html_cont is None: return #用BeautifulSoup解析文档内容 soup = BeautifulSoup(html_cont,'html.parser') res_data = [] #数组 #获取所有的文章节点nodes post_div_nodes = soup.find_all('div',class_='post-preview') #遍历nodes，读取每一项内容并保存 for post_div_node in post_div_nodes: post_div_soup = BeautifulSoup(str(post_div_node)) post_info = &#123;&#125; #字典dict #判断URL是否是完整 url_ = post_div_soup.a['href'] if 'http://' not in url_: url_ = "http://gityuan.com" + url_ #保存数据 post_info['url'] = url_ post_info['title'] = post_div_soup.find('h2').get_text() post_info['summary'] = post_div_soup.find('div',class_='post-content-preview').get_text() res_data.append(post_info) return res_data 这是爬虫功能的重点之一：对网页数据进行解析，由此数据才变为可用数据 主要是通过第三方插件BeautifulSoup解析数据，并保存到数组res_data中，具体见代码中实现 html_output.py 1234567891011121314151617181920212223242526272829303132import sys#下面两行代码解决编码问题，强制使用utf-8，而非默认的unicode编码reload(sys)sys.setdefaultencoding('utf-8')class JsonOutput(object): def __init__(self): self.datas = [] def collect_data(self,new_data): if new_data is not None: self.datas.append(new_data) def output_json(self): #打开文件，并以json格式输出 fout = open('output.json','w') fout.write('&#123;') fout.write(r'"data":[') for data in self.datas: for post_info in data: fout.write('&#123;') fout.write('"url":"%",' % post_info['url']) fout.write('"title":"%",' % post_info['title']) fout.write('"summary":"%",' % post_info['summary']) fout.write('&#125;,') #为了符合json规范，最后一个输入空数据，无末尾逗号 fout.write(r'&#123;&#125;') fout.write(']&#125;') 本类也很重要，主要是数据存取，以及将解析好的数据格式化输出 说明本文中代码经二次处理，不一定与源代码一致，但思路如此，以供参考。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义透明背景的Dialog]]></title>
    <url>%2Fblog%2F2018%2F01%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%8F%E6%98%8E%E8%83%8C%E6%99%AF%E7%9A%84Dialog%2F</url>
    <content type="text"><![CDATA[简介通过自定义Dialog类，使用Style、AnimationDrawable等实现一个透明背景的、带进度更新的弹窗。 主要涉及Style自定义以及AnimationDrawable的使用。 代码 布局文件 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:background="@drawable/dialog_bg"&gt; &lt;ImageView android:id="@+id/image" android:layout_width="250dp" android:layout_height="250dp" /&gt;&lt;/LinearLayout&gt; 资源文件 1）下载对应进度条的图片资源，放到drawable目录下 2）在drawable下新建dialog_progress.xml 1234567891011121314&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/progress_1" //资源文件 android:duration="300" /&gt; //持续时间ms &lt;item android:drawable="@drawable/progress_2" android:duration="300" /&gt; ... &lt;/animation-list&gt; 3）dialog圆角背景（非必须） 123456&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;solid android:color="#6fb6d4" /&gt; &lt;corners android:radius="500dp" /&gt;&lt;/shape&gt; 4）自定义dialog的style windowBackground使背景透明 backgroundDimEnabled则可以去除半透明遮罩效果 123456&lt;style name="diyDialogStyle" parent="@android:style/Theme.Dialog" &gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt;&lt;!--背景透明--&gt; &lt;item name="android:backgroundDimEnabled"&gt;false&lt;/item&gt;&lt;!--半透明，模糊--&gt;&lt;/style&gt; DIYDialog.java 继承自Dialog.java ，并用构造函数调用initView()方法初始化dialog样式，有其他需求可以再自己实现。 123456789//初始化view、控件View view = View.inflate(context, R.layout.layout_dialog, null);ImageView imageView = view.findViewById(R.id.image);imageView.setBackgroundResource(R.drawable.dialog_progress);//填充布局setContentView(view);//实现动画AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getBackground();animationDrawable.run(); 源码github源码路径]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现AES加密解密应用]]></title>
    <url>%2Fblog%2F2018%2F01%2Fjava%E5%AE%9E%E7%8E%B0AES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[简介最近手机中涉及到用户账户密码保存的问题，选用AES加密算法进行加密后，再通过SharedPreferences保存在手机端。 本文主要介绍AES的加密、解密用法。 代码初始化秘钥 123456789101112131415161718192021private static final String AES = "AES";private static final String PASSWPRD = "123456";public static SecretKeySpec initKey()&#123; SecretKeySpec key = null; try &#123; KeyGenerator kg = KeyGenerator.getInstance(AES); kg.init(128,new SecureRandom(PASSWPRD.getBytes()));//通过这种算法，每次生成的key都是一样的 //也可以kg.init(128),这样每次生成的key都不一样 SecretKey securityKey = kg.generateKey(); byte[] encodedKey = securityKey.getEncoded(); key = new SecretKeySpec(encodedKey, AES);//AES也可以替换为"AES/CBC/PKCS5PADDING" &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return key;&#125; 加密 123456//核心代码//source是要加密的内容Cipher cipher = Cipher.getInstance(AES);//创建密码器byte[] byteContent = source.getBytes("utf-8");cipher.init(Cipher.ENCRYPT_MODE, key);//创建密码器byte[] result = cipher.doFinal(byteContent);//加密 解密 1234//核心代码Cipher cipher = Cipher.getInstance(AES);cipher.init(Cipher.DECRYPT_MODE, key);byte[] result = cipher.doFinal(source); 加密和解密的结果都是二进制的，无法直接转化为字符串，所以还需要将二进制与十六进制互转 1234567891011121314151617181920212223242526public static String parseByte2HexStr(byte buf[]) &#123; StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; buf.length; i++) &#123; String hex = Integer.toHexString(buf[i] &amp; 0xff); if (hex.length() == 1) &#123; hex = '0' + hex; &#125; stringBuffer.append(hex.toUpperCase()); &#125; return stringBuffer.toString();&#125;public static byte[] parseHexStr2Byte(String hexStr)&#123; if (hexStr.length() &lt; 1) &#123; return null; &#125; byte[] result = new byte[hexStr.length() / 2]; for (int i = 0; i &lt; hexStr.length() / 2; i++) &#123; int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16); int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16); result[i] = (byte) (high * 16 + low); &#125; return result;&#125; 这样就可以在初始化一个key后，对文本进行加密和解密 123456//初始化keySecretKeySpec key = initKey();//加密文本并转化为16进制，方便保存String eStr = parseByte2HexStr(encrypt(resource,key));//将加密16进制文本转为二进制，进行解密String dStr = decrypt(parseHexStr2Byte(estr)); 参考文献JAVA实现AES加密 - CSDN博客 源码github链接]]></content>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2Fblog%2F2018%2F01%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解，是描述Java代码的代码，它能够被编译器解析，向编译器、虚拟机说明一些事情，就像java中给程序员看的注释一样。 Android应用开发这方面比较火的是Butter Knife ,本文讲述如何自定义注解替换findViewById()。 实现注解（annotation）的思路：通过反射获取到类中使用注解的变量，方法，再调用不同的方法对这些变量，方法进行处理以达到目的。 主要涉及三方面： 定义一个注解类 定义一个注解帮助类 使用注解 java元注解java语言有四个预留的注解，用来生成其他自定义的注解： @Target 说明注解所能修饰的范围。其值一般为ElementType.xxx，主要有： CONSTRUCTOR 描述构造器 FIELD 描述域 LOCAL_VARIABLE 描述局部变量 METHOD 描述方法 PACKAGE 描述包 PARAMETER 描述参数 TYPE 描述类，接口，enum声明 @Retention 说明注解存活的生命周期,其值一般为RetentionPolicy.xxx，主要有 SOURCE 仅源文件有效，被编译器丢弃 CLASS 在class文件中有效，可能被虚拟机忽略 RUNTIME 在运行时有效，在class被装载时被获取 @Documented 用于描述其它类型的annotation应该被作为被标注的程序成员的公共API 表示是否将注解信息添加在java文档中。有该注解则会被Javadoc工具文档化 是一个标记注解，没有值 @Inherited 表示该标记会被标记的class的子类继承，在查找该注解时，如果当前类没有，会自动向上到其父类中查找，直到该注解类型被找到或是查找完了Object类还未找到 是一个标记注解，没有值 注解不能继承其他注解或接口 内建注解java中常见的内建注解： @Override 重写父类方法 @Deprecated 不赞成使用的api @SuppressWarnings() 忽略指定警告 参数如下： 参数 含义 deprecation 使用了过时的类或方法时的警告 unchecked 执行了未检查的转换时的警告 fallthrough 当Switch程序块进入进入下一个case而没有Break时的警告 path 在类路径、源文件路径等有不存在路径时的警告 serial 当可序列化的类缺少serialVersionUID定义时的警告 finally 任意finally子句不能正常完成时的警告 all 以上所有情况的警告 自定义注解注解类12345678910@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface BindView &#123; //注解参数只可以为public或者默认 //如果注解中的值不是value，那么在进行注解的时候，需要给出对应的值的名字 //如@ViewInject(id = R.id.buy) int value(); //注解元素必须有明确的值，要不在定义注解时指定默认值，要不在使用注解时指定 public int age() default 18;//指定默认值&#125; 注解参数支持数据类型如下： 1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)2.String类型3.Class类型4.enum类型5.Annotation类型6.以上所有类型的数组 注解帮助类主要提供使用注解的方法，代码中的注解替换为真正要实现的逻辑，为注解和使用注解的类搭建一个桥梁。 1234567891011121314151617181920212223242526272829//核心方法如下public static void bindViews(Activity activity) &#123; //获取到使用注解的类 Class&lt;? extends Activity&gt; clazz = activity.getClass(); //获取该类中的所有域变量 Field[] fields = clazz.getDeclaredFields(); //通过遍历，将使用到注解的变量初始化 for (Field field : fields) &#123; //获取注解对象 BindView bindView = field.getAnnotation(BindView.class); if (bindView != null) &#123; //获取注解的值 int viewId = bindView.value(); if (viewId != -1) &#123; try &#123; //注解要实现的逻辑，此处为替代clazz中的findViewById()方法，注意getMethod()是获取该类及其实现的接口中所有的public方法 Method findViewById = clazz.getMethod("findViewById", int.class); findViewById.setAccessible(true); Object o = findViewById.invoke(activity, viewId); //修改要注解的类，到此注解目的达到 field.setAccessible(true); field.set(activity,o); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 使用注解在类中通过@xxx() 使用注解，并通过帮助类真正实现注解逻辑 123456789//标记注解@BindView(R.id.text)private TextView textView;//调用帮助类方法AnnotationUtils.bindViews(ASampleActivity.this);//使用初始化之后的变量textView.setText("hello annotation"); 参考文章 Java核心技术点之注解 - ImportNew java注解–gityuan]]></content>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门知识]]></title>
    <url>%2Fblog%2F2018%2F01%2FPython%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[基于Python3.x Python文件默认格式.py 首行默认以下命令： 12#!/usr/bin/python# -*- coding: UTF-8 -*- 数据类型 数字 整数int 1，2，3 长整数long 1112L 浮点数float （小数）1.23，3.14 复数complex 3.14j 字符串 ‘abc’，”abc”，’’’abc‘’‘ ‘x’和”x” 区别不大 ‘’’abc‘’‘ 文本可以跨行 字符串前面加r或者R表示字符串内部不需要转义，否则要用\ 转义 支持a[0]取值 布尔值 True 和False 布尔值可以用and、or和not运算 空值 None 变量 命名规则：开头aA_，其后可以包含aA_1 常量 不能变的变量 集合 列表list [1,2,3,3] 插入list.insert(1,’vaule’) 删除list.pop() / list.pop(1) 元组tuple (1,2,3,3) 与列表类似，但是一旦初始化就不能再修改 字典dict {‘a’:1,’b’:’vaule’} 键值对，读取快，相当于java的map set set([1,2,3]) 键的集合，不能有重复的，相当于java的set 逻辑语句 if … : … elif … : … else : … for x in xs : … while x : … 自定义函数12def fun(n) return n return 可以没有return，默认返回None 可以return 多个值，实际上返回的是一个tuple pass 不想执行任何语句，但是为了符合语法规范，可以用pass当做占位符 12def fun() pass 抛出异常 1raise TypeError('an error') 其中TypeError需要继承自error或者Exception 参数 位置参数 12def fun(arg) pass 默认参数 12def fun(arg0,arg1 = 1) pass 注意 默认参数必须是参数中后面的几位；默认值必须不可变，如int，string等 可变参数 12def fun(arg,*args) pass *args 表示参数个数可变，可以输入list/tuple等，或者依次输入多个参数，用逗号分隔 关键词参数 123def fun(arg,**keywords) if 'city' in kw: pass **keywords 表示接受关键词作为参数传入，可以传入dict，或者依次输入多个关键词参数 命名关键词参数 1234def fun0(args,*，name,age) passdef fun1(arg.*args,name,age)#如果命名关键词前面有可变参数，则不用*分隔 pass 限制输入的关键字，限制只有name和age作为关键词参数 使用其他文件的函数123456#使用时 sys.fun()import sys#使用时直接fun()from xxFile import funform sys import *form sys import fun 类 定义类 12345678910111213class AClass(object): '''doc for AClass you can use this by AClass.__doc__''' def __init__(self): #默认的初始化方法 pass def aFun(self): pass#创建类对象a = AClass()#调用方法a.aFun() 所有的类方法必须至少有一个参数，推荐命名为self，系统会自动传入类对象，无需手动传入。 继承 123456789101112131415161718192021class Father(object): def __init__(self): print("father") def say(self): print("i am f") class Child(Father): def __init__(self): #子类方法不会自己调用父类方法，需要手动调用 super(Child,self).__init__() #调用父类方法2： #Father.__init__(self) print("child") def say(self): print('i am c') def go(self,where): print('go to %s'%where)c = Child() #father childc.say() #i am cc.go('home') #go ro home 子类继承父类，则需要在子类定义时传入父类 子类如果有与父类同名方法，则优先调用子类方法，除非子类特别调用父类的方法]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射简单应用]]></title>
    <url>%2Fblog%2F2018%2F01%2FJava%E5%8F%8D%E5%B0%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介反射，用来在运行时获取给定类的构造函数，变量，方法，并对其作以修改，而不必在编译时获取该类。 Reflection allows programmatic access to information about the fields, methods and constructors of loaded classes, and the use of reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. –https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html 简单使用定义一个待反射的类ATestClass.java 12345678910111213141516171819202122package cf.android666.reflect;public class ATestClass &#123; public String name; private int age; public ATestClass() &#123; // TODO Auto-generated constructor stub &#125; private void init(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getAge() &#123; // TODO Auto-generated method stub return " age: " + age; &#125; &#125; 在TestReflect.java中反射 1234567891011121314151617181920//核心代码public static void main(String[] args)&#123; //注意这里需要是完整的类名，包括包名 Class&lt;?&gt; clazz = Class.forName("cf.android666.reflect.ATestClass"); ATestClass aTestClsObj=(ATestClass) clazz.newInstance(); //反射获取变量 Field mName = clazz.getDeclaredField("name"); mName.setAccessible(true); mName.set(aTestClsObj, "aReflect"); System.out.println(aTestClsObj.name); //反射获取方法 Method mInit= clazz.getDeclaredMethod("init", String.class,int.class); mInit.setAccessible(true);//解除私有限定，让我们在用反射时访问私有变量 mInit.invoke(aTestClsObj, "aInitName",66); System.out.println(aTestClsObj.name + aTestClsObj.getAge());&#125; 小结反射的用法较为简单 通过Class.froName() 获取Class对象clazz ，获取要反射的Class对象aTestClsObj 通过clazz 获取要反射Class的变量、方法 通过aTestClsObj 操作这些变量，方法 其中需要注意的有 f.setAccessible(true); 方法可以解除private 限制，进而可以操作类的私有变量，方法 clazz.getXXX() 方法获取全部公有变量、方法 ，包括父类或接口的xx，clazz.getDeclaredXXX() 方法获取全部 变量、方法，包括私有的，实现接口的方法，但是不包括父类的]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android通过Hook启动未注册Activity]]></title>
    <url>%2Fblog%2F2018%2F01%2FAndroid%E9%80%9A%E8%BF%87Hook%E5%90%AF%E5%8A%A8%E6%9C%AA%E6%B3%A8%E5%86%8CActivity%2F</url>
    <content type="text"><![CDATA[简介hook是钩子的意思，hook的过程是通过反射、代理等改变系统原有的行为以达到自己的目的。 本文主要是通过hook android 中的ActivityManagerService和Handler.CallBack，欺骗系统调起activity的过程，在调用startActivity时将targetIntent通过proxy伪装为proxyIntent，等到通过系统验证，正式启动activity时，再讲proxyIntent恢复为targetIntent，从而实现调用未在AndroidManifest.xml中注册的activity。 需要注意，本方法只在Api&lt;26下有效。具体原因见后面。 具体实现1.新建Activity等IndexActivity.java用于启动targetIntent 1234567((Button)findViewById(R.id.btn1)).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //启动未在AndroidManifest.xml注册的activity mContext.startActivity(new Intent(mContext,TargetActivity.class)); &#125; &#125;); TargetActivity.java 和ProxyActivity.java 分别设置对应页面布局setContentView(R.layout.activity_xxx); HookApplication.java 用于调用hook方法 12345678public class HookApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); Utils.hookAms(this); Utils.hookHandle(); &#125;&#125; 在AndroidManifest.xml中注册IndexActivity和ProxyActivity，Application使用HookApplication。 2.Utils.java实现hook具体逻辑Utils.hookAms() 实现拦截targetIntent并发起proxyIntent，欺骗系统对activity是否已注册的验证，其中proxyIntent通过proxyIntent.putExtra(TARGET_KEY, targetIntent); 方法携带targetIntent。 1234567891011121314151617181920//hookAms()核心代码Class hookActivityManagerNative = Class.forName("android.app.ActivityManagerNative"); //在api&gt;26时无此变量：gDefault，该方法失效 Field gDefault = hookActivityManagerNative.getDeclaredField("gDefault"); gDefault.setAccessible(true); Object object = gDefault.get(null); Class hookSingleton = Class.forName("android.util.Singleton"); Field mInstance = hookSingleton.getDeclaredField("mInstance"); mInstance.setAccessible(true); Object oldAms = mInstance.get(object); Class hookIActivityManagerService = Class.forName("android.app.IActivityManager"); Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[]&#123;hookIActivityManagerService&#125;, new MAmsInvocationHandler(context,oldAms)); //将原有的ActivityManagerService替换为我们自定义的 mInstance.set(object,proxy); 在MAmsInvocationHandler 里面实现targetIntent和proxy的转换 123456789101112131415161718192021222324//MAmsInvocationHandler核心代码public class MAmsInvocationHandler implements InvocationHandler&#123; public static final String TARGET_KEY = "targetIntent"; ... public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if ("startActivity".equals(method.getName())) &#123; int index = 0; Intent targetIntent = null; for (int i = 0; i &lt; args.length; i++) &#123; if (args[i] instanceof Intent) &#123; index = i; targetIntent = (Intent) args[i]; break; &#125; &#125; if (targetIntent != null) &#123; Intent proxyIntent = new Intent(mContext, ProxyActivity.class); proxyIntent.putExtra(TARGET_KEY, targetIntent); args[index] = proxyIntent; &#125; &#125; return method.invoke(mOldAms,args); &#125;&#125; 至此，已经对activity.startActivity做了拦截，所有的targetIntent都会被拦截，存储在proxyIntent中，以通过系统的检查。 接下来，通过系统检查后，hookHandle()通过重写Handler.CallBack，对启动proxyIntent事件做拦截，使之启动targetIntent对应的Activity。 12345678910111213//hookHandle()核心代码Class activityThreadCls = Class.forName("android.app.ActivityThread");Method currentActivityThread = activityThreadCls.getDeclaredMethod("currentActivityThread");currentActivityThread.setAccessible(true);Object activityThread = currentActivityThread.invoke(null);Field mH = activityThreadCls.getDeclaredField("mH");mH.setAccessible(true);Handler handler = (Handler) mH.get(activityThread);Field callBack = Handler.class.getDeclaredField("mCallback");callBack.setAccessible(true);callBack.set(handler, new ActivityThreadHandlerCallBack(handler)); 其中ActivityThreadHandlerCallBack 将返回我们自定义的CallBack以替换系统的，实现启动targetIntent而非proxyIntent。 1234567891011121314151617181920212223242526272829//ActivityThreadHandlerCallBack核心代码public class ActivityThreadHandlerCallBack implements Handler.Callback&#123; @Override public boolean handleMessage(Message msg) &#123; if (msg.what == 100) &#123; handleLaunchActivity(msg); &#125; mHandler.handleMessage(msg); return true; &#125; //主要代码，在这里将proxyIntent转化为targetIntent private void handleLaunchActivity(Message msg) &#123; Object object = msg.obj; try &#123; Field intent = object.getClass().getDeclaredField("intent"); intent.setAccessible(true); Intent proxyIntent = (Intent) intent.get(object); Intent targetIntent = proxyIntent.getParcelableExtra(MAmsInvocationHandler.TARGET_KEY); if (targetIntent != null) &#123; proxyIntent.setComponent(targetIntent.getComponent()); &#125; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 到这里，就实现了启动通过已经注册了的ProxyActivity启动未注册TargetActivity的全过程。 主要思想是找到系统实现该过程的逻辑，在对应地方通过反射获取到对应变量，插入自己的逻辑，从而达到目的。 附录上面涉及到的代码路径： github源代码路径 参考了几篇文章，其中较为完整的一篇如下： Android插件化系列第（一）篇—Hook技术之Activity的启动过程拦截]]></content>
      <tags>
        <tag>Android hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidService详解]]></title>
    <url>%2Fblog%2F2018%2F01%2FAndroidService%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[启动一个Service MyServices.java 必须继承自Service，或者如IntentService本身就是等其子类 123456789101112131415161718192021public class MyServices extends Service &#123; @Nullable @Override public IBinder onBind(Intent intent) &#123; Log.d("TAG","onBind"); return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d("TAG","onCreate"); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d("TAG", "onDestroy: "); &#125;&#125; ​ AndroidManifest.xml 注册MyServices 12345678&lt;application&gt; &lt;service android:name=".MyServices" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="cf.android666.myservices" /&gt; &lt;/intent-filter&gt; &lt;/service&gt;&lt;/application&gt; ​ MainActivity.java 在java中调用Service，需要ServiceConnection类 123456789101112131415ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG, "onServiceConnected: 服务绑定"); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(TAG, "onServiceDisconnected: 服务解绑"); &#125; &#125;;Intent intent = new Intent(context, MyServices.class);bindService(intent, mConnection, Service.BIND_AUTO_CREATE);//绑定Service//startService(intent); 启动serviceunbindService(mConnection);//解绑Service bindService()和startService()的区别在于： ** bindService()将service和当前的activity绑定在一起，activity销毁时，service也会被销毁； ** startService()则只是“启动”service，在此后service的活动和activity无关，并一直存活。 Service具体分析Service在AndroidManifest.xml中的属性： 1234android:name=".MyService"//必须被指定android:exported=true/false //是否能被其他应用隐式调用//有intent-filter则默认为true，否则默认false；若手动指定为false则即使有intent-filter也无法隐式调用android:process="remote"/":remote"//前者在共有的进程中进行，后者在名字为&#123;packageName&#125;:remote 的私有进程中进行，其他进行不可访问；如果不设置该属性，则service在应用自己的进程里面运行 Service默认运行在创建他的线程中，要是进行耗时操作，最好在service中单独创建一个线程，这样子可以在子线程工作，在主线程中更新工作进度。 Service中的方法： 1234567891011121314//在初次创建服务时调用，并且直至服务死亡，只会被调用一次void onCreate()//在绑定服务是才会被调用，必须实现该方法IBinder onBind(Intent intent) //每一次通过startService()方法启动Service的时候都会被调用int onStartCommand(Intent intent, int flags, int startId) //1.intent 启动时，启动组件传递过来的Intent //2.flags 表示启动请求时是否有额外数据，可以是： // 0：无 // START_FLAG_REDELIVERY：表示该方法返回值为START_REDELIVER_INTENT，在上个服务被杀死之前调用stopSelf()停止服务 // START_FLAG_RETRY：在onStartCommand()被调用后一直无返回值时，会尝试重新调用onStartCommand() //3.当前服务id 其中onStartCommand()方法的返回值意义如下： START_STICKY:service在内存不足被杀死后，内存空闲时系统会重新创建service，一旦成功创建会回调onStartCommand()方法，此时intent是null，除非是挂起的intent如pendingintent，无限期运行 START_NOT_STICKY：service因内存不足被杀死，内存再次空闲系统也不会再重新创建服务，最安全 START_REDELIVER_INTENT：service因内存不足被杀死，会重建服务并传递给最后一个intent（最后一次调用startService() 时的intent），用于连续作业，如下载等 Service绑定服务的三种方式1.拓展Binder类要求客户端和服务在同一应用的同一进程内。客户端通过其访问service中的公共方法。 步骤如下： 创建BindService服务端，在类中创建一个实现了IBinder接口的实力对象并提供公共方法给客户端使用 在onBind()回调方法返回此Binder实例 在客户端的onServiceConnected()方法接收Binder，使用提供的方法绑定服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445//service服务端public class LocalService extends Service&#123; LocalService mService; private LocalBinder binder = new LocalBinder(); ... public IBinder onBind(Intent intent)&#123; return binder; &#125; public void doSomeThing()&#123; //服务中公共方法，可以被客户端通过IBInder获取实例调用 &#125; public class LocalBinder extends Binder&#123; LocalService getService()&#123; return LocalService.this; &#125; &#125;&#125;//客户端public class BindActivity extends Activity&#123; protected void onCreate(...)&#123; ServiceConnection conn = new ServiceConnection()&#123; //绑定服务时被调用，实现客户端和服务端交互（IBinder） public void onServiceConnected(ComponentName name, IBinder service)&#123; LocalService.LocalBinder binder = (LocalService.LocalBinder)service;//获取服务端IBinder mService = binder.getService();//获取服务实例，以调用服务的公共方法 &#125; //取消绑定时回调，多数时候是service被意外销毁，如内存不足 //当客户端取消绑定时，系统“绝对不会”调用该方法。 public void onServiceDisconnected(ComponentName name)&#123; mService = null; &#125; &#125;; //创建绑定对象 Intent intent = new Intent(this,LocalService.class); //绑定服务 //参数3 flags则是指定绑定时是否自动创建Service。0代表不自动创建、BIND_AUTO_CREATE则代表自动创建 bindService(intent,conn,Service.BIND_AUTO_CREATE); //调用服务中的方法，最好先判断是否为null mService.doSomeThing(); //解除绑定 unbindService(conn); &#125;&#125; 2.Messageservice与不同进程通信（IPC） 。 步骤如下： Service实现一个Handler，接收客户端每个调用的回调 用Handler创建Messenger对象 用Messenger创建IBinder对象，并通过onBind()返回客户端 客户端使用IBinder实例化Messenger，用其将Message对象发送给Service Service在Handler接收并处理Message 12345678910111213141516171819202122232425//Servicepublic class MessageService extends Service&#123; public final static int MSG_WHAT = 1; //创建Handler接收、处理客户端msg class IncomingHanler extends Handler&#123; public void handleMessage(Message msg)&#123; //do sth with msg... &#125; &#125; Messenger messenger = new Messenger(new IncomingHanlder()); public IBinder onBind(Intent intent)&#123; return messenger.getBinder(); &#125;&#125;//客户端//onCreate()方法中：mConnection = new ServiceConnection()&#123; public void onServiceConnected(ComponentName className, IBinder service)&#123; Messenger mService = new Messenger(service); &#125;&#125;;//给服务发消息Message msg = Message.obtain(null,MessengerService.MSG_WHAT,0,0);mService.send(msg); 注意service要在不同的进程中： 1234AndroidMinafast.xml&lt;service android:name=".messenger.MessengerService" android:process=":remote" /&gt; 服务与客户端双向通信 服务端，修改IncomingHandler，回复客户端消息 12345678910111213class IncomingHandler extends Handler&#123; public void handleMessage(Message msg)&#123; //回复消息 Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null,MessengerService.MSG_WHAT); Bundle bundle = new Bundle(); bundle.putString("key","value"); replyMsg.setData(bundle); try&#123; client.send(replyMsg); &#125;catch()&#123;&#125; &#125;&#125; 客户端，增加Messenger和Handler处理服务端回复 1234567private static class RecyclerReplyMsgHandler extends Hanlder&#123; public void handleMessage(Message msg)&#123; //接收服务端返回的msg //do sth ... &#125;&#125;private Messenger mRecevierReplyMsg = new Messenger(new RecyclerReplyMsgHandler()); 此外，在发送消息是需要将接收服务端回复的Messenger通过Message的replyTo传递给服务端 123//create msg...msg.replyTo = mRecevierReplyMsg;//send msg... 3.AIDL一般不会使用 绑定服务时的注意事项 多个客户端可连接一个服务端，只有第一个客户端绑定时才会调用服务onBind()方法来检索IBinder，此后无需调用就可将同一个IBinder传递给其他客户端 bindService() 绑定服务是异步进行的 一般在activity可见生命周期内绑定-取消服务，不要在onResume()、onPause()期间执行绑定/解绑 Service绑定和启动转换 顺序 结果 先绑定后启动service 启动service 先启动后绑定service 会绑定宿主，但是宿主死后仍按照启动service方式存活 前台服务和通知 startForeground(int id, Notification notification)该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。 stopForeground(boolean removeNotification)该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true为删除。 注意该方法并不会停止服务。 但是，如果在服务正在前台运行时将其停止，则通知也会被删除。 文章参考： 关于Android Service真正的完全详解，你需要知道的一切 - CSDN博客]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[之前发布的几个App]]></title>
    <url>%2Fblog%2F2018%2F01%2F%E4%B9%8B%E5%89%8D%E5%8F%91%E5%B8%83%E7%9A%84%E5%87%A0%E4%B8%AAApp%2F</url>
    <content type="text"><![CDATA[在之前学习android的过程中，跟着教程做了几个app，虽然随着使用的api的失效，大多数应用如今已经不能正常使用了，但是作为初入编程的一点点小纪念，还是为他们写一个索引文章，至少能够晚一些消寂于这广阔的数据海洋中。 NiceNewsPosted on 2016-05-30 NieceNews我制作的第二款APP，一个实时新闻软件。 IWeatherPosted on 2016-07-16 IWeather，我的第三个Android应用，一个天气预报APP。 2048Posted on 2016-07-21 2048，我的第四个Android应用，同时也是我的第一款游戏APP。 I看知乎Posted on 2016-07-24 | i看知乎，我的第五个Android应用。 学习的过程需要不断的重复，更需要有条理的总结，我会把平时学习的心得体会，经验，以及无聊时瞎琢磨得出来的稀奇古怪的想法放到这里，主要是为了自己能够在学习的过程中有计划的总结学习到的知识，同时也方便之后查阅。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android控件组]]></title>
    <url>%2Fblog%2F2017%2F09%2FAndroid%E6%8E%A7%E4%BB%B6%E7%BB%84%2F</url>
    <content type="text"><![CDATA[这几天的工作中用到了控件组来实现复杂布局，效果不错，记录下来备用。 1. 定义控件组布局xxx_layout.xml在这里定义要使用的控件组布局，这里的布局决定了布局显示的样子。 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="wrap_content" android:padding="10dp"&gt; &lt;ImageView ... /&gt; &lt;EditText .../&gt; &lt;ImageView ... /&gt; &lt;/LinearLayout&gt; 2.新建自定义属性文件attr.xml（可选） 在123456789101112131415```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;!-- MSearchBar表明是给该控件使用的自定义属性 --&gt; &lt;declare-styleable name=&quot;MSearchBar&quot;&gt; &lt;!-- 以下为示例，可以根据需求增减 --&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在该自定义控件的类xxx.java中，通过如下语句获取从用户使用时赋给这些属性的值： 12TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar);float textSize = array.getDimension(R.styleable.MSearchBar_textSize, 13); ​ 用户动态给这些属性赋值： 12345 &lt;cf.android666.jixiaoyong.weightgroup.weight.MSearchBar ... app:textColor="@color/colorPrimaryDark"&gt;&lt;/cf.android666.jixiaoyong.weightgroup.weight.MSearchBar&gt; 注意，这里写的是1234567891011121314151617 ​# 3. 新建组合控件的类XXX.java* 新建XXX.java，继承自布局文件的父布局LinearLayout* 更改参数少的构造方法的```super(a1,a2,a3)```为```this(a1,a2,a3)```，其中```this()```中的参数个数为参数最多的构造方法的参数数。 **注意** ：一定要做这一步，否则在使用该自定义控件组时，新建该类的对象会提示出错* 在最终会被调用的构造方法里面将xml里面定义的布局加载进来： ```java //注意三个参数：布局文件：R.layout.weight_group_layout, root：this,是否依附到root：true //必须有前两个参数，否则控件的宽高等会有异常 View view = LayoutInflater.from(context).inflate(R.layout.weight_group_layout, this,true); 使用自定义属性： 12345678910public MSearchBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //do sth TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MSearchBar); float textSize = array.getDimension(R.styleable.MSearchBar_textSize, 13); editText.setTextSize(textSize); &#125; 给控件组内部控件添加点击事件监听： xxx.java 要实现点击事件监听接口： 1public class MSearchBar extends LinearLayout implements View.OnClickListener&#123;&#125; 自定义接口，供使用xxx.java类时实现对监听事件的处理： 123456789public void setImgLeftOnClickListener(OnImgClickListener listener)&#123; listenerL = listener;&#125;public interface OnImgClickListener&#123; public void onClick();&#125;private OnImgClickListener listenerL; 对要监听点击事件的控件设置监听，并调用1234567891011121314151617181920212223```java //在构造方法等地方设置监听事件 imageViewLeft.setOnClickListener(this); //在xxx.java中重写onClick()方法 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; //ImageLeft case R.id.imageView: if (listenerL != null) &#123; listenerL.onClick(); &#125; break; //imageRight case R.id.imageView2: if (listenerR != null) &#123; listenerR.onClick(); &#125; break; &#125; &#125; 4. 使用自定义控件组xxx.java 在布局文件main_activity.xml中添加该控件 1234567&lt;cf.android666.jixiaoyong.weightgroup.weight.MSearchBar android:id="@+id/search_bar" android:layout_width="match_parent" android:layout_height="wrap_content" app:textColor="@color/colorPrimaryDark"&gt;&lt;/cf.android666.jixiaoyong.weightgroup.weight.MSearchBar&gt; ​ 在java中使用该控件，设置监听事件 12345678MSearchBar searchBar = (MSearchBar) findViewById(R.id.search_bar);searchBar.setImgLeftOnClickListener(new MSearchBar.OnImgClickListener() &#123; @SuppressLint("WrongConstant") @Override public void onClick() &#123; Toast.makeText(MainActivity.this, "Click on Left", Toast.LENGTH_SHORT).show(); &#125; &#125;); 5.效果预览 6.源码demo的github链接:github]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android常用知识]]></title>
    <url>%2Fblog%2F2017%2F09%2Fandroid%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[自定义view 画矩形 1canvas.drawRect(left, top, right, bottom, paint); 其中：left/top 是该view的左上顶点到父容器左边和顶端的距离right/bottom 是该view的右下顶点到父容器左边和顶端的距离 写字 12345678Rects bounds = new Rects();mPaint.setColor(mColorText);mPaint.setTextSize(mSizeText);mPaint.setTextAlign(Paint.Align.CENTER);mPaint.getTextBounds(text, 0, text.length(), bounds);float x = width / 2;float y = -bounds.centerY() + childHeight / 2 + i * childHeight;canvas.drawText(text, x, y, mPaint); ​ 当text为居中对齐时，centerX和centerY是该字的正中心，以text的左下角为原点，故而centerY为-sizeOfText/2。 自定义属性 attrs.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="LetterIndex"&gt; &lt;attr name="color_text" format="color" /&gt; &lt;attr name="color_index_bg" format="color" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; ​ MyView.java 123AttributeSet attrs = ***;TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.LetterIndex);mColorText = arr.getColor(R.styleable.LetterIndex_color_text, 0x52000000); 注意默认值可以为123456​ **main_act.xml**```xml&lt;com.text.MyView***app:color_text = &quot;#003903&quot;/&gt; 对外预留onClick监听接口MyView.java12345678910//定义 private onIndexClickListener mClickListener; public interface onIndexClickListener&#123; void onIndexClick(int chooseId); &#125; public void setOnIndexClickListener(onIndexClickListener listener)&#123; this.mOnIndexClick = listener; &#125;//使用，在需要监听的动作发生时调用该方法 mClickListener.onIndexClick(mChooseId); ​ MainAct.java123456mView.setOnIndexClickListener(new LetterIndex.onIndexClickListener() &#123; @Override public void onIndexClick(int chooseId) &#123; Log.d("TAG", "onIndexClick: chooseid is" + chooseId); &#125; &#125;); RecyclerView滑动事件manager.scrollToPositionWithOffset(n, 0);n为要滑到顶端的position]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View实现联系人列表]]></title>
    <url>%2Fblog%2F2017%2F09%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E7%8E%B0%E8%81%94%E7%B3%BB%E4%BA%BA%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[自定义的view LetterIndex.java extends View ContactsListView.java extends RecyclerView#分析 联系人列表有两个要点 字母导航栏通过自定义View画出26个字母，设置滑动监听事件，根据上下滑动的距离判断当前选中的字母，并相应更新界面。 列表中的字母标题针对item中的联系人姓名首字母对应的tag作比较，若与前一个相同则不显示title，否则显示。 事件联动 当滑动字母导航栏时，除了处理本身的变化外，还要留出接口，以便其他控件获取当前选中的字母。 联系人列表滑动时，除了处理本身变化外，同样要留出接口以便获取当前置顶的item对应的字母 字母导航栏要留出方法，以便其他控件指定选中的字母，并更新界面#具体代码ContactsListView.java重写该类主要是为了实现ItemDecoration根据不同的item变化，同时可以从xml布局文件中获取ItemDecoration的自定义属性。主要代码：12345678910111213public ContactsListView(Context context) &#123; this(context, null, 0);&#125;public ContactsListView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0);&#125;public ContactsListView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); mTypeArray = context.obtainStyledAttributes(attrs, R.styleable.MyRecyclerDecoration); mContext = context;&#125; 故而在其内部自定义了一个继承自ItemDecoratio得静态内部类Decorationn类：12345678910111213141516171819202122232425262728293031323334353637383940public Decoration(List&lt;String&gt; data)&#123;//获取要显示的联系人数据对应的英文tag集合//初始化各种自定义属性//例如颜色：mColorLetterText = mTypeArray.getColor(R.styleable.MyRecyclerDecoration_color_letter_text, 0xff152648);&#125;@Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state)&#123;//画出各个导航title&#125;@Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;//画出置顶的导航title&#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;//判断是否画出导航title super.getItemOffsets(outRect, view, parent, state); int position = ((RecyclerView.LayoutParams) (view.getLayoutParams())).getViewAdapterPosition(); if (position != -1) &#123; String text = mDatas.get(position).substring(0, 1).toUpperCase(); if (position == 0) &#123; outRect.set(0, mTitleHeight, 0, 0); &#125; else if (text != null &amp;&amp; !text.equals(mDatas.get(position - 1).substring(0, 1).toUpperCase())) &#123; outRect.set(0, mTitleHeight, 0, 0); &#125; else &#123; outRect.set(0, 0, 0, 0); &#125; &#125;&#125;private void drawText(Canvas canvas, float left, float right, View child, String text) &#123;//画出文字&#125; LetterIndex.java该类用来画出字母导航栏，并且提供方法获取/设置当前选中的字母123456789101112131415public interface onIndexClickListener &#123; void onIndexClick(int chooseId); void onActionUp(); &#125; public void setOnIndexClickListener(onIndexClickListener listener) &#123; this.mClickListener = listener; &#125; public void setChooseId(int chooseId) &#123; if (chooseId &gt;= 0 &amp;&amp; chooseId &lt; mIndexTexts.length) &#123; mChooseId = chooseId; invalidate(); &#125; &#125; 然后重写event)```方法，在ACTION_DOWN、ACTION_MOVE、ACTION_UP时调用对应的方法即可。12重写onDraw()方法，画出对应的界面 @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); int height = getHeight() - getPaddingTop() - getPaddingBottom(); float width = getWidth(); //childHeight 是每一个字母所在单元的高度 float childHeight = (float) height / mIndexTexts.length; //如果被点击了，就画出背景 if (isClick) { mPaint.setColor(mColorIndexBg); canvas.drawRect(0, 0, width, height, mPaint); } Rect bounds = new Rect(); mPaint.setTextSize(mSizeText); mPaint.setTextAlign(Paint.Align.CENTER); for (int i = 0; i &lt; mIndexTexts.length; i++) { String text = mIndexTexts[i]; mPaint.setColor(mColorText); //在被选中的字后面画一个圆，并改变字的颜色 if (i == mChooseId) { mPaint.setColor(mColorChooseTextBg); canvas.drawCircle(width / 2, childHeight / 2 + i * childHeight, mSizeText / 2 + 2, mPaint); mPaint.setColor(mColorChooseText); } mPaint.getTextBounds(text, 0, text.length(), bounds); //bounds里面保存着要画的字的一些属性，如x，y，centerX，centerY等， //要注意 canvas.drawText（text,x,y,mpaint）中y并不是text的最低端，而是baseline。 float x = width / 2; float y = -bounds.centerY() + childHeight / 2 + i * childHeight; canvas.drawText(text, x, y, mPaint); } } ``` 源码源代码在我的Github，点这里可以找到。 预览如下]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android开发常用设置]]></title>
    <url>%2Fblog%2F2017%2F08%2FAndroid-%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Android Studio 国内较快的仓库： maven {url&apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;} RecyclerView添加依赖注意RecyclerView的版本号要和当前工程中其他android.support包版本保持一致，否则虽然导入了对应的包，但是仍然无法正常使用。 compile &apos;com.android.support:recyclerview-v7:26+&apos; 设置：自动添加依赖：insert imports on paste: None自动删除无用依赖：Optimize imports on the fly Linux 设置ndk环境变量 /etc/profile #set ndk env NDKROOT=/home/jixiaoyong/AndroidDev/Sdk/ndk-bundle export PATH=$NDKROOT:$PATH]]></content>
  </entry>
  <entry>
    <title><![CDATA[java中三种常用的排序方法]]></title>
    <url>%2Fblog%2F2016%2F12%2FJava%E4%B8%AD%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天重新学习类三种排序方法，按照排序速度依次是冒泡排序，选择排序和插入排序。以下示例皆为从小到大的排序 1.冒泡排序每一次比较都可能要交换元素。冒泡排序的思想是：每一轮开始的时候，将第一个元素（a）开始与其后的元素（b）依次进行比较，将较大的元素（设为m）放到后面，并将m与其后的另外一个元素继续进行比较，直到最后一个没有排好序的元素。在接下来一轮的排序中，刚才以及之前选出来的、已经排好顺序的最大值不用参与排序。依次类推，总共遍历n-1轮，即可完成排序。具体代码如下： void bubble(int[] arr){ int temp; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } System.out.println(&quot;\n--bubble :&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } } 2.选择排序每次比较的时候不交换选择排序的思想：每次比较的时候找到的两个数中的较大值并记下其位置，等到当前一轮的遍历完成之后，将最后一个未排序元素与这一轮遍历找到的最大值交换最多交换n-1次代码如下： void select(int[] arr){ for (int i = 0; i &lt; arr.length; i++) { int maxIndex = 0; int temp = 0; for (int j = 1; j &lt; arr.length - i; j++) { if (arr[maxIndex] &lt; arr[j]) { maxIndex = j; } } temp = arr[maxIndex]; arr[maxIndex] = arr[arr.length - i - 1]; arr[arr.length - i - 1] = temp; } System.out.println(&quot;\n--select :&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } } 3.插入排序法插入排序法思想：将待排序的元素分为有序和无序两种，刚开始排序的时候假设只有第一个元素是有序的，其余n-1个元素都是无序的；排序开始的时，将无序部分的一个元素（a）与有序部分的最后一个元素（b）进行比较，如果a&lt;b，则将a与b交换，再将a与下一个有序元素进行比较；否则，将a加到b后面，作为有序部分的最后一个元素。接着再从无序部分取出一个元素与有序部分的元素依次比较，直达所有元素都为有序元素。遍历n-1次代码如下： void insertSort(int[] arr){ for (int i = 1; i &lt; arr.length; i++) { int instertValue = arr[i]; for (int j = i - 1; j &gt;= 0; j--) { if (instertValue &lt; arr[j]) { arr[j+1] = arr[j]; arr[j] = instertValue; }else { break; } } } /* 第二种表示形式 for (int i = 1; i &lt; arr.length; i++) { int instertVal = arr[i]; int index = i - 1; while (index &gt;= 0 &amp;&amp; instertVal &lt; arr[index]) { arr[index + 1] = arr[index]; index--; } arr[index + 1] = instertVal; } */ System.out.println(&quot;\n--insertSort :&quot;); for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + &quot; &quot;); } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux下配置Git，使用AndroidStudio同步工程到Github]]></title>
    <url>%2Fblog%2F2016%2F04%2FLinux%E4%B8%8B%E9%85%8D%E7%BD%AEGit%EF%BC%8C%E4%BD%BF%E7%94%A8AndroidStudio%E5%90%8C%E6%AD%A5%E5%B7%A5%E7%A8%8B%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[这篇文章介绍了如何在 linux 环境下安装和配置 git 与 github ，并且使用 Android Studio 将本地的项目同步到 github 上面。 安装 git1sudo apt-gat install git 配置 git 和 github 创建 Github 账号 生成 ssh key 1ssh-keygen -t rsa -C &quot;your_email@youremail.com 在 github 上面添加 ssh key 进入 Account Settings –&gt; SSH Keys –&gt; Add SSH Key 添加 SSH Keys ：名字起一个容易识别的名字，key 是生成的 /home/username/.ssh/id_rsa.pub. 中的内容，直接粘贴到指定位置就行 测试 ssh key 是否成功 1ssh -T git@github.com 提示如You’ve successfully authenticated, but GitHub does not provide shell access则说明成功连接 github 配置 Github 12git config --global user.name &quot;your name&quot; //配置用户名git config --global user.email &quot;your email&quot; //配置email 用 Android Studio 同步工程到 Github 启动android studio 进入android studio/bin，终端输入./studio.sh 选择 VCS ---&gt; Import into Version Control --&gt; Share Project on Github 第一次进入会要求输入 github 的账号和密码 按照要求输入即可此后还会要求你输入一个本地密码，当下次同步的时候需要输入之后就进入到选择同步的仓库，新建一个仓库，开始同步就可以了 到这里就顺利的在 Android Studio 上面将工程同步到 Github 上面了 以下为原文提到的其他方法，摘录如下，以备后用： 利用Git从本地上传到GitHub第一步： 进入要所要上传文件的目录 输入命令 git init 第二步： 创建一个本地仓库 origin 使用命令 1git remote add origin git@github.com:yourName/yourRepo.git youname是你的GitHub的用户名，yourRepo是你要上传到GitHub的仓库 第三步： 比如你要添加一个文件xxx到本地仓库，使用命令 git add xxx，可以使用 git add . 自动判断添加哪些文件 然后把这个添加提交到本地的仓库，使用命令 git commit -m说明这次的提交 最后把本地仓库origin提交到远程的GitHub仓库，使用命令 git push origin master 从GitHub克隆项目到本地第一步： 到GitHub的某个仓库，然后复制右边的有个HTTPS clone url 第二步： 回到要存放的目录下，使用命令 git clone https://github.com/chenguolin/scrapy.git，这里的url只是一个例子 第三步： 如果本地的版本不是最新的，可以使用命令 git fetch origin，origin是本地仓库 第四步： 把更新的内容合并到本地分支，可以使用命令 git merge origin/master 如果你不想手动去合并，那么你可以使用：git pull &lt;本地仓库&gt; master // 这个命令可以拉去最新版本并自动合并 GitHub的分支管理 创建 1 创建一个本地分支： git branch &lt;新分支名字&gt; 2 将本地分支同步到GitHub上面： git push &lt;本地仓库名&gt; &lt;新分支名&gt; 3 切换到新建立的分支： git checkout &lt;新分支名&gt; 4 为你的分支加入一个新的远程端： git remote add &lt;远程端名字&gt; &lt;地址&gt; 5 查看当前仓库有几个分支: git branch 删除 1 从本地删除一个分支： git branch -d &lt;分支名称&gt; 2 同步到GitHub上面删除这个分支： git push &lt;本地仓库名&gt; :&lt;GitHub端分支&gt; 说明这篇文章是我今天在 linux 下安装 git ，上传工程到 github 上面时的步骤的总结，大部分内容都参考/摘录自下面这篇文章，感谢原作者的分享，原文信息及链接如下： Linux下Git和GitHub使用方法总结[日期：2014-03-07] 来源：Linux社区 作者：chenguolinhttp://www.linuxidc.com/Linux/2014-03/97821.htm]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux下配置JDK和AndroidStudio开发环境]]></title>
    <url>%2Fblog%2F2016%2F04%2Flinux%E4%B8%8B%E9%85%8D%E7%BD%AEJDK%E5%92%8CAndroidStudio%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[下载 JDK 并解压 到官网下载 jdk 下载到的 JDK 文件解压 设置环境变量管理员权限进入 etc/environment 写入以下代码 1JAVA_HOME=&quot;JDK主目录的绝对路径&quot; 配置 alternatives打开终端执行以下命令： 123sudo update-alternatives --install /usr/bin/java java JDK主目录的绝对路径/bin/java 300sudo update-alternatives --install /usr/bin/javac javac JDK主目录的绝对路径/bin/javac 300 到这里 JDK 的环境就配置好了 运行 Android Studio进入 android studio/bin 目录下，打开终端， 输入 ./studio.sh 到这里，就可以正常运行 android studio 了]]></content>
  </entry>
  <entry>
    <title><![CDATA[AppWidget的使用之PendingIntent]]></title>
    <url>%2Fblog%2F2016%2F04%2FAppWidget%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8BPendingIntent%2F</url>
    <content type="text"><![CDATA[这几天学习 AppWidget ，很简单的组件却花费了不少功夫，今天对 PendingIntent 的用法做了一些简单的整理。 PendingIntent PandingIntent 就像是一个设计好的处理预案，当达到某个特定条件时，便会调用该 Intent 所指定动作（打开服务，Activity或者发送广播）。 这里使用该方法在 AppWidget 里面为按钮添加监听事件，当按钮被点击的时候触发相应的动作 AppWidget 和应用程序不再同一个进程当中，而是在 HomeScreen 上面执行,所以不能直接为 AppWidget 中的 Button 添加监听事件，需要用 remoteViews.setPendingIntent(R.id.widget_button,pendingIntent);意思是当按下按钮的时候 pendingIntent 中的 Intent 就会执行 PendingIntent 当某个事件出现之后才会执行 RemoteViews对象 代表了一系列的 View 对象，和主程序不在同一个进程为 AppWidget 控件绑定处理器 流程概述： 添加 appwidget_provider_info.xml 在 res/xml 下新建 appwidget_provider_info.xml 描述 AppWidget 的基本信息如最小高度、宽度等，还有就是该挂件的布局文件 在 res/layout 下面为该挂件设置具体的布局样式 向 AppWidget 的布局文件中添加一个 Button 向 AppWidget 的布局文件中添加一个 TextView 新建 MyAppWidget.java 继承自 AppWidgetProvider 在该类的 onUpdate() 方法中为 Button 设置、添加监听事件 建立一个 Intent 对象 用该 Intent 对象创建一个 PendingIntent 对象 创建一个 RemoteViews 对象 用该 RemoveViews 对象为 按钮绑定事件处理器 更新按钮 注册事件 备注：要是为 AppWidget 中的 Button 设置的事件是打开一个 TargetActivity ，还需要添加一个 TargetActivity 类和对应的布局文件 以下是代码 appwidget_provider_info.xml 这个布局文件是 AppWidget 的信息 描述了 AppWidget 的最小高，最小宽以及它的布局文件 123456&lt;appwidget-provider android:minHeight=&quot;200dp&quot; android:minWidth=&quot;300dp&quot; android:initialLayout=&quot;@layout/app_widget&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;&lt;/appwidget-provider&gt; app_widget.xml 这个布局文件是 Widget 在桌面上显示的样式 定义了 AppWidget 中各个组件及其样式 其中 Button 用来响应点击事件，加入 TargetActivity 1234567891011121314151617&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:orientation=&quot;vertical&quot;&gt;&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;hello,world!&quot;/&gt;&lt;Button android:id=&quot;@+id/app_widget_btn&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;#ff00ff&quot; android:text=&quot;this is my app widget button&quot;/&gt;&lt;/LinearLayout&gt; target_activity.xml 123456789101112&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;50sp&quot; android:background=&quot;#00ff00&quot; android:text=&quot;\n hello,welcome to target activity!&quot;/&gt;&lt;/LinearLayout&gt; MyAppWidget.java 主要是修改了 update() 方法： 定义了一个预先设定的动作—- Intent 对象； 利用该 Intent 读写，创建一个 PendingIntent 对象； 创建一个 RemoteView 对象，并为按钮绑定监听事件 刷新 AppWidget。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyAppWidget extends AppWidgetProvider &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Auto-generated method stub super.onReceive(context, intent); &#125; @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; // TODO Auto-generated method stub super.onUpdate(context, appWidgetManager, appWidgetIds); //appWidgetIds 每一次向屏幕添加 AppWidget 的时候都会增加一个唯一的 appWidget 的 Id for(int i = 0; i &lt; appWidgetIds.length;i++)&#123; //创建一个 Intent 对象 Intent intent = new Intent(context,TargetActivity.class); //创建一个 PendingIntent 对象 PendingIntent pendingIntent = PendingIntent.getActivity(context,0,intent,0); // remoteViews 代表 AppWidget 上所有的控件 RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.app_widget); //为按钮绑定事件处理器 /* * 参1，指定被绑定处理器的控件id * 参2，指定事件发生时会被执行的 PendingIntent */ remoteViews.setOnClickPendingIntent(R.id.app_widget_btn,pendingIntent); //更新 AppWidget ，参1是用于指定被更新 appWidget 的ID appWidgetManager.updateAppWidget(appWidgetIds[i],remoteViews); &#125; &#125; @Override public void onDeleted(Context context, int[] appWidgetIds) &#123; // TODO Auto-generated method stub super.onDeleted(context, appWidgetIds); &#125; @Override public void onEnabled(Context context) &#123; // TODO Auto-generated method stub super.onEnabled(context); &#125; @Override public void onDisabled(Context context) &#123; // TODO Auto-generated method stub super.onDisabled(context); &#125;&#125; TargetActivity.java 1234567public class TargetActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.target_activity); &#125;&#125; AndroidManifest.xml 在 AndroidManifest.xml 中注册 TargetActivity 和 MyAppWidget 123456789101112131415&lt;application&gt;... &lt;activity android:name=&quot;.TargetActivity&quot;&gt; &lt;/activity&gt; &lt;!-- 注意这里注册了一个 MyAppWidget 接收数据--&gt; &lt;receiver android:name=&quot;.MyAppWidget&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@xml/appwidget_provider_info&quot;/&gt; &lt;/receiver&gt;&lt;/application&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo+github=blog]]></title>
    <url>%2Fblog%2F2016%2F03%2F%E5%B0%8F%E7%99%BD%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Hello World！ 一直以来，为了有一个合适的在线写字的地方，我尝试过许多种工具，从最初的 QQ 空间开始，到各种门户网站的博客，再到自己开始尝试搭建博客，一路奔忙，门户网站的限制太多，自己搭建的博客又时常由于空间提供商的各种问题而无法访问。许多时候一个平台只能使用一段时间，这样子颠颠撞撞大概也有五六年的时间了。 一直听说 github 这个平台的各种优点，尤其是可以作为稳定而免费的空间托管博客最令我心动，但是之前多次尝试不得其道，终以失败告终。最近在学习 Android 语言的时候，又再次用起了 github ，不过这次是用它来存储代码。不得不承认，使用 github 来控制程序版本真是一件令人愉悦的事件。 机缘巧合，因为需要将学习过程中的一些笔记，心得总结找个地方整理，显然单纯的使用 github 并不是一个好办法，而其他的平台的博客限制又太多，于是又尝试用 github 搭建一个博客，虽然对这些知识并不是很熟悉，但误打误撞竟然也成功的搭建好了博客。下面就把整个建站的过程大概梳理一下，以便以后查看。 准备软件 下载软件： node 客户端 git github windows 客户端 装 git 和 github windows 客户端 安装 git:git 安装时按照默认的配置，一路点击确定就可以。 安装 githubgithub 安装分为两种：一种是直接用官网的安装包，在安装的时候需要从网上下载资料，受网速限制，这种方法很慢，而且容易出错；另一种直接找一份github离线安装包解压到本地即可使用，我就是使用后一种方法。 安装node 安装 node 客户端下载并安装 node ,我使用的版本是 node-v5.7.1-x64。 在安装完 git, node 之后 win 键 + R 输入cmd 打开 windows 自带命令行，输入git /npm之后，如果显示出帮助信息而非不是内部或外部命令，也不是可运行的程序或批处理文件这样的提示，就说明 git 和 node 已经配置好了环境变量，否则就需要手动配置。 配置环境变量方法： 此电脑 –&gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 找到用户环境变量 –&gt; path ，如下图 如下图修改 这样子 node 应该就可以正常使用了。 安装hexo打开命令行，全局安装 Hexo ,加 -g 参数： 1npm install -g hexo 查看 hexo 版本 1hexo version 结果： 1Blockquotehexo-cli: 1.0.1os: Windows_NT 10.0.14316 win32 x64http_parser: 2.6.2node: 5.7.1v8: 4.6.85.31uv: 1.8.0zlib: 1.2.8ares: 1.10.1-DEVicu: 56.1modules: 47openssl: 1.0.2g 到这里 hexo 就在电脑上面安装好了。 配置hexo 进入存放 hexo 文件的目录下，创建一个文件夹blog存储 hexo 的文件 1hexo init blog 然后进入这个文件夹 1cd blog 启动 hexo 服务器 1hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop 打开本地地址：http://localhost:4000/，就可以看到本地搭建好的 hexo 博客了这样子一个 hexo 博客就在本地搭建好了 目录的解释：scaffolds 脚手架，也就是一个工具模板 scripts 写文件的js，扩展hexo的功能source 存放博客正文内容source/_drafts 草稿箱source/_posts 文件箱themes 存放皮肤的目录themes/landscape默认的皮肤_config.yml 全局的配置文件db.json 静态常量 一些 hexo 语句解释help 查看帮助信息init 创建一个hexo项目migrate 从其他系统向hexo迁移version 查看hexo的版本–config参数，指定配置文件，代替默认的_config.yml–debug参数，调试模式，输出所有日志信息–safe参数，安全模式，禁用所有的插件和脚本–silent参数，无日志输出模式 新建文章命名为“新的文章”，输入命令： 1hexo new 新的文章 hexo 默认生成 md 文件，新生成的文章在目录：.\blog\source_posts\新的文章.md ，对其进行相应的编辑即可文章格式： 1title: 新的文章date: 2014-05-07 18:44:12updated : 2014-05-10 18:44:12permalink: abctags:- 开始- 我- 日记categories:- 日志- 第一天--- 配置github 注册并登录 github进入 https://github.com/ ，注册新账户，并且登录 新建 respositoy在主页点击 New respositoy 新建一个名字为yourname.github.io 的 respositoy； 设置新建一个 github pages进入仓库主页，选择settings –&gt; github pages –&gt; Launch automatic page generator ,按照默认的主题配置选择一个就好 上传网站对于 hexo 的相关配置：打开_config.yml，修改以下部分： 12345678910Sitetitle: 季小勇的博客subtitle:description:author: 季小勇language: zh-CNtimezone:# URL#If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.github.io/root: http://yoursite.github.io/blog/ 此处由于我是将网站放在二级目录 ./blog/ 下面，所以 root 目录设置如此，使用的是绝对路径，否则在网页上显示的时候，css 等由于路径不对，加载可能会有问题。 1deploy: type: git repo:https://github.com/yourname/yourname.github.io.git 这行语句是使用 hexo 自动 deploy 到 github 时的设置，如果正常的话，当用 hexo 对网站静态化处理后，再执行 hexo deploy 就可以自动部署到 github 上面了，但是我的电脑 git 或者 node 由于是不同时间装的期间还重装了几次系统，可能导致某些设置有误，所以在执行 hexo deploy 的时候一直提示有问题，故而采用另一种办法手动同步网站，这句话也可以不修改。 用 hexo 对文章进行静态化处理： 1hexo generate 在blog\public目录下生成的 public 包含所有的静态化文件,此时，这个文件夹内所有的内容就是处理好的网站，将其发布到合适的空间就可以正常显示。由于之前的 git 或者 node 配置有误，所以这时候采用手动同步网站: 将上次在 github 上建立的项目yourname.github.io同步到本地。同步的方法很多，这里我选择的是使用 github 的 windows 客户端，比较方便： 打开 github 客户端，找到项目，选择clone到本地即可。 之后打开同步的项目，确认当前的branch是master，否则同步之后网站不会显示。 在 github 同步的目录下找到上次建好的项目yourname.github.io ,进入之后，将上文获得到的public内容放入目标文件夹，我选择的是将博客放在子目录，所以这里新建了一个blog文件夹用于放置博客，所以就是将public全部内容 放入./yourname.github.io/blog/目录下，这样子在网站上显示的时候，博客的网址就是http://yourname.github.io/blog/ 这样一个简单的利用 github 托管的 hexo 博客就搭建好了。注：本文内容是根据我建立博客时的做法整理而成，其中有部分内容是参考网上的教程，文中引用的文字全部来自http://blog.fens.me/hexo-bootstarp-github/ ，此文对我帮助很大，感谢作者张丹(Conan)的分享。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2016%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
